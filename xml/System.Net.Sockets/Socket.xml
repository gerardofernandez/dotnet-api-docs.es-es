<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d793dbfba1e015e8ad221802f824241e34411f4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52240786" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="d9a09-101">Implementa la interfaz de sockets Berkeley.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-101">Implements the Berkeley sockets interface.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-102">La <xref:System.Net.Sockets.Socket> clase proporciona un amplio conjunto de métodos y propiedades para las comunicaciones de red.</span><span class="sxs-lookup"><span data-stu-id="d9a09-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="d9a09-103">El <xref:System.Net.Sockets.Socket> clase le permite realizar ambos sincrónica y transferencias de datos asincrónicas mediante cualquiera de los protocolos de comunicación que se enumeran en la <xref:System.Net.Sockets.ProtocolType> enumeración.</span><span class="sxs-lookup"><span data-stu-id="d9a09-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="d9a09-104">La <xref:System.Net.Sockets.Socket> clase sigue el patrón de nomenclatura de .NET Framework para los métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="d9a09-105">Por ejemplo, sincrónico <xref:System.Net.Sockets.Socket.Receive%2A> método corresponde a la asincrónica <xref:System.Net.Sockets.Socket.BeginReceive%2A> y <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="d9a09-106">Si la aplicación requiere sólo un subproceso durante la ejecución, utilice los métodos siguientes, que están diseñados para el modo de funcionamiento sincrónico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="d9a09-107">Si usa un protocolo orientado a conexiones como TCP, el servidor puede escuchar las conexiones mediante el <xref:System.Net.Sockets.Socket.Listen%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="d9a09-108">El <xref:System.Net.Sockets.Socket.Accept%2A> método procesa las solicitudes de cualquier conexión entrante y devuelve un <xref:System.Net.Sockets.Socket> que puede usar para intercambiar datos con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="d9a09-109">Use este valor devuelto <xref:System.Net.Sockets.Socket> para llamar a la <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="d9a09-110">Llame a la <xref:System.Net.Sockets.Socket.Bind%2A> método antes de llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método si desea especificar el número de puerto y la dirección IP local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="d9a09-111">Use un número de puerto de cero si desea que el proveedor de servicios subyacente para asignar un puerto libre para usted.</span><span class="sxs-lookup"><span data-stu-id="d9a09-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="d9a09-112">Si desea conectarse a un host de escucha, llame a la <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-113">Para comunicar datos, llame a la <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="d9a09-114">Si usa un protocolo sin conexión, como UDP, no es necesario escuchar las conexiones en absoluto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="d9a09-115">Llame a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método para aceptar los datagramas entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="d9a09-116">Use el <xref:System.Net.Sockets.Socket.SendTo%2A> método para enviar datagramas a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="d9a09-117">Para procesar las comunicaciones que usan subprocesos independientes durante la ejecución, use los métodos siguientes, que están diseñados para el modo de operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="d9a09-118">Si usa un protocolo orientado a conexiones como TCP, use el <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, y <xref:System.Net.Sockets.Socket.EndConnect%2A> métodos para establecer conexión con un host de escucha.</span><span class="sxs-lookup"><span data-stu-id="d9a09-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="d9a09-119">Use la <xref:System.Net.Sockets.Socket.BeginSend%2A> y <xref:System.Net.Sockets.Socket.EndSend%2A> o <xref:System.Net.Sockets.Socket.BeginReceive%2A> y <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos para comunicarse de forma asincrónica los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="d9a09-120">Se pueden procesar solicitudes de conexión entrantes mediante <xref:System.Net.Sockets.Socket.BeginAccept%2A> y <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="d9a09-121">Si usa un protocolo sin conexión, como UDP, puede usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> y <xref:System.Net.Sockets.Socket.EndSendTo%2A> para enviar datagramas, y <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> y <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> para recibir datagramas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="d9a09-122">Si realiza varias operaciones asincrónicas en un socket, no necesariamente se completan en el orden en el que se inician.</span><span class="sxs-lookup"><span data-stu-id="d9a09-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="d9a09-123">Cuando haya terminado de enviar y recibir datos, use el <xref:System.Net.Sockets.Socket.Shutdown%2A> método para deshabilitar el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-124">Después de llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos los recursos asociados con la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="d9a09-125">El <xref:System.Net.Sockets.Socket> clase le permite configurar su <xref:System.Net.Sockets.Socket> utilizando el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="d9a09-126">Recuperar estos valores mediante el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-127">Si está escribiendo una aplicación relativamente sencilla y no requieren el máximo rendimiento, considere el uso de <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, y <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="d9a09-128">Estas clases proporcionan una interfaz sencilla y más fácil de usar para <xref:System.Net.Sockets.Socket> las comunicaciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-129">El siguiente ejemplo de código muestra cómo el <xref:System.Net.Sockets.Socket> clase puede utilizarse para enviar datos a un servidor HTTP y recibir la respuesta.</span><span class="sxs-lookup"><span data-stu-id="d9a09-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="d9a09-130">En este ejemplo se bloquea hasta que se recibe la página completa.</span><span class="sxs-lookup"><span data-stu-id="d9a09-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">
      <span data-ttu-id="d9a09-131">Para establecer una conexión saliente o Aceptar una solicitud entrante.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-131">To establish an outgoing connection or accept an incoming request.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="d9a09-132">Las instancias de esta clase son seguros para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-132">Instances of this class are thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">
      <span data-ttu-id="d9a09-133">Programación para redes en .NET Framework</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-133">Network Programming in the .NET Framework</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">
      <span data-ttu-id="d9a09-134">Procedimientos recomendados para las clases System.Net</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-134">Best Practices for System.Net Classes</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">
      <span data-ttu-id="d9a09-135">Administración de la memoria caché para aplicaciones de red</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-135">Cache Management for Network Applications</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">
      <span data-ttu-id="d9a09-136">Protocolo de Internet versión 6</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-136">Internet Protocol Version 6</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">
      <span data-ttu-id="d9a09-137">Ejemplos de programación de red</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-137">Network Programming Samples</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">
      <span data-ttu-id="d9a09-138">Traza de la red en .NET Framework</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-138">Network Tracing in the .NET Framework</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">
      <span data-ttu-id="d9a09-139">Seguridad en la programación para redes</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-139">Security in Network Programming</span>
      </span>
    </related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">
      <span data-ttu-id="d9a09-140">Mejoras de rendimiento de socket en la versión 3.5</span>
      <span class="sxs-lookup">
        <span data-stu-id="d9a09-140">Socket Performance Enhancements in Version 3.5</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-141">Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-141">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <span data-ttu-id="d9a09-142">Información sobre el socket devuelta por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-142">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-143">Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.Socket" /> utilizando el valor devuelto por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-143">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-144">Si se llama a la <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor varias veces con la misma matriz de bytes que el argumento para cada llamada, creará varios administrados <xref:System.Net.Sockets.Socket>s con el mismo socket subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-144">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="d9a09-145">Esta práctica es recomendable.</span><span class="sxs-lookup"><span data-stu-id="d9a09-145">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="d9a09-146">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-146">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="d9a09-147">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-147">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-148">Inicializa una instancia nueva de la clase <see cref="T:System.Net.Sockets.Socket" /> usando el tipo de socket y el protocolo que se especifiquen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-148">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-149">El `socketType` parámetro especifica el tipo de la <xref:System.Net.Sockets.Socket> clase y el `protocolType` parámetro especifica el protocolo utilizado por <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-149">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-150">Los dos parámetros no son independientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-150">The two parameters are not independent.</span></span> <span data-ttu-id="d9a09-151">A menudo el <xref:System.Net.Sockets.Socket> tipo está implícito en el protocolo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-151">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="d9a09-152">Si la combinación de <xref:System.Net.Sockets.Socket> tipo y tipo de protocolo resultados en un no válido <xref:System.Net.Sockets.Socket>, el constructor produce una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-152">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-153">Si el constructor produce una <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-153">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-154">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-154">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-155">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-156">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-157">La combinación de <paramref name="socketType" /> y <paramref name="protocolType" /> da como resultado un socket no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-157">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <span data-ttu-id="d9a09-158">Uno de los valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-158">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </param>
        <param name="socketType">
          <span data-ttu-id="d9a09-159">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-159">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="d9a09-160">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-160">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-161">Inicializa una instancia nueva de la clase <see cref="T:System.Net.Sockets.Socket" /> con la familia de direcciones, el tipo de socket y el protocolo que se especifiquen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-161">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-162">El `addressFamily` parámetro especifica el esquema de direcciones que el <xref:System.Net.Sockets.Socket> clase utiliza, el `socketType` parámetro especifica el tipo de la <xref:System.Net.Sockets.Socket> (clase) y el `protocolType` parámetro especifica el protocolo utilizado por <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-162">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-163">Los tres parámetros no son independientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-163">The three parameters are not independent.</span></span> <span data-ttu-id="d9a09-164">Algunas familias de direcciones restringen qué protocolos se pueden usar con ellos y, a menudo el <xref:System.Net.Sockets.Socket> tipo está implícito en el protocolo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-164">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="d9a09-165">Si la combinación de la familia de direcciones, <xref:System.Net.Sockets.Socket> tipo y escriba los resultados no es válido de protocolo <xref:System.Net.Sockets.Socket>, el constructor produce una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-165">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-166">Si el constructor produce una <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-166">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-167">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-167">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-168">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-168">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-169">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-169">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-170">En el ejemplo de código siguiente se muestra cómo crear una instancia de la <xref:System.Net.Sockets.Socket> clase.</span><span class="sxs-lookup"><span data-stu-id="d9a09-170">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-171">La combinación de <paramref name="addressFamily" />, <paramref name="socketType" /> y <paramref name="protocolType" /> tiene como resultado un socket no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-171">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-172">Crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para una conexión recién establecida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-172">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-173">Objeto <see cref="T:System.Net.Sockets.Socket" /> para una conexión recién establecida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-173">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-174"><xref:System.Net.Sockets.Socket.Accept%2A> sincrónicamente extrae la primera solicitud de conexión pendiente de la cola de solicitudes de conexión del socket de escucha y, a continuación, crea y devuelve un nuevo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-174"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-175">No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-175">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d9a09-176">Sin embargo, puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> devuelto del método de <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-176">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="d9a09-177">En modo de bloqueo, <xref:System.Net.Sockets.Socket.Accept%2A> bloquea hasta que se pone en cola un intento de conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-177">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="d9a09-178">Una vez que se acepte una conexión, el original <xref:System.Net.Sockets.Socket> continúa la puesta en cola solicitudes de conexión entrantes hasta que cierre se.</span><span class="sxs-lookup"><span data-stu-id="d9a09-178">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="d9a09-179">Si se llama a este método mediante sin bloqueo <xref:System.Net.Sockets.Socket>y sin conexión se ponen en cola las solicitudes, <xref:System.Net.Sockets.Socket.Accept%2A> produce una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-179">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-180">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-181">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-181">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-182">Antes de llamar a la <xref:System.Net.Sockets.Socket.Accept%2A> método, primero debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-182">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-183">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-184">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-185">El ejemplo de código siguiente acepta una sencilla <xref:System.Net.Sockets.Socket> conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-185">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-186">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-186">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-187">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-187">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-188">El socket receptor no realiza escuchas de conexiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-188">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="d9a09-189">Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-189">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-190">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-191">Comienza una operación asincrónica para aceptar un intento de conexión entrante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-191">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-192">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-192">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-193">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-193">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-194">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-194">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-195">El evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-195">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-196">Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> intentos de método para procesar conexiones entrantes de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-196">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d9a09-197">Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-197">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-198">Antes de llamar a la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-198">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d9a09-199">Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y enlazarlo a la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-199">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d9a09-200">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:</span><span class="sxs-lookup"><span data-stu-id="d9a09-200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-201">El llamador puede especificar opcionalmente una existente <xref:System.Net.Sockets.Socket> que se usará para la conexión entrante especificando el <xref:System.Net.Sockets.Socket> para usar con el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-201">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="d9a09-202">Si el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad es null, un nuevo <xref:System.Net.Sockets.Socket> se construye con el mismo <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, y <xref:System.Net.Sockets.Socket.ProtocolType%2A> como actual <xref:System.Net.Sockets.Socket> y establecer como el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-202">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="d9a09-203">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-203">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-204">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-204">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-205">Opcionalmente, se puede proporcionar un búfer para recibir el bloque inicial de datos en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-205">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d9a09-206">En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para recibir y el <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número máximo de bytes de datos para el búfer de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-206">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="d9a09-207">Estas propiedades se pueden establecer mediante el <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-207">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-208">Parte del búfer pasado se usarán internamente para su uso por la llamada de Winsock AcceptEx subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-208">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="d9a09-209">Esto significa que la cantidad de datos devueltos siempre será menor que el valor de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instancia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-209">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="d9a09-210">La cantidad de búfer utilizado internamente varía en función de la familia de direcciones del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-210">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="d9a09-211">El tamaño de búfer mínimo necesario es 288 bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-211">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="d9a09-212">Si se especifica un tamaño de búfer mayor, el <xref:System.Net.Sockets.Socket> esperan algunos datos adicionales que no sean los datos de direcciones recibidos por la llamada de Winsock AcceptEx y esperará hasta que se reciben estos datos innecesarios.</span><span class="sxs-lookup"><span data-stu-id="d9a09-212">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="d9a09-213">Si se produce un tiempo de espera, se restablece la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-213">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="d9a09-214">Por lo que si se esperan que los datos adicionales de una cantidad específica, el tamaño del búfer debe establecerse en el tamaño de búfer mínimo más esta cantidad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-214">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="d9a09-215">El método de devolución de llamada de finalización debe examinar el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propiedad para determinar si el <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operación fue correcta.</span><span class="sxs-lookup"><span data-stu-id="d9a09-215">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="d9a09-216">El <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento puede producirse en algunos casos, cuando no se ha aceptado ninguna conexión y hacer que el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propiedad se establece en <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-216">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="d9a09-217">Esto puede ocurrir como resultado de la exploración de puertos mediante un examen de tipo semiabierto SYN (SYN -> SYN-ACK-> secuencia RST).</span><span class="sxs-lookup"><span data-stu-id="d9a09-217">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="d9a09-218">Las aplicaciones que usan el <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método debe estar preparado para controlar esta condición.</span><span class="sxs-lookup"><span data-stu-id="d9a09-218">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-219">Un argumento no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-219">An argument is not valid.</span>
          </span>
          <span data-ttu-id="d9a09-220">Esta excepción produce si el búfer proporcionado no es suficientemente grande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-220">This exception occurs if the buffer provided is not large enough.</span>
          </span>
          <span data-ttu-id="d9a09-221">El búfer debe ser de al menos 2 bytes \* (sizeof(SOCKADDR_STORAGE + 16).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-221">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span>
          </span>
          <span data-ttu-id="d9a09-222">Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-222">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-223">Un argumento está fuera de intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-223">An argument is out of range.</span>
          </span>
          <span data-ttu-id="d9a09-224">La excepción produce si <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-224">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-225">Se ha solicitado una operación no válida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-225">An invalid operation was requested.</span>
          </span>
          <span data-ttu-id="d9a09-226">Esta excepción se produce si el <see cref="T:System.Net.Sockets.Socket" /> de aceptación no realiza escuchas para las conexiones o el socket aceptado está enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-226">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span>
          </span>
          <span data-ttu-id="d9a09-227">Debe llamar al método <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar al método <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-227">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span>
          </span>
          <span data-ttu-id="d9a09-228">Esta excepción también se produce si el socket ya está conectado o si ya hay una operación de socket en curso con el parámetro <paramref name="e" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-228">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-229">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-229">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-230">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-230">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-231">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-232">Obtiene la familia de direcciones de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-232">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-233">Uno de los valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-233">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-234">El <xref:System.Net.Sockets.AddressFamily> especifica el esquema de direcciones que una instancia de la <xref:System.Net.Sockets.Socket> puede utilizar la clase.</span><span class="sxs-lookup"><span data-stu-id="d9a09-234">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="d9a09-235">Esta propiedad es de solo lectura y se establece cuando el <xref:System.Net.Sockets.Socket> se crea.</span><span class="sxs-lookup"><span data-stu-id="d9a09-235">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-236">El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-236">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-237">Obtiene la cantidad de datos que se recibieron de la red y están disponibles para leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-237">Gets the amount of data that has been received from the network and is available to be read.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-238">Número de bytes de datos recibidos de la red y disponibles para su lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-238">The number of bytes of data received from the network and available to be read.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-239">Si está utilizando sin bloqueo <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> es una buena forma de determinar si se pone en cola datos para la lectura, antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-239">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-240">Los datos disponibles están que la cantidad total de datos en cola en el búfer de red para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-240">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="d9a09-241">Si no hay datos se pone en cola en el búfer de red, <xref:System.Net.Sockets.Socket.Available%2A> devuelve 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-241">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="d9a09-242">Si el host remoto se apaga o cierra la conexión, <xref:System.Net.Sockets.Socket.Available%2A> puede producir un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-242">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-243">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-243">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-244">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-244">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-245">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-245">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-246">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-246">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-247">En el ejemplo de código siguiente se compara los resultados de llamar a IOControl con FIONREAD y la propiedad disponible.</span><span class="sxs-lookup"><span data-stu-id="d9a09-247">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-248">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-248">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-249">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-250">Comienza una operación asincrónica para aceptar un intento de conexión entrante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-250">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="d9a09-251">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-251">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-252">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-252">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-253">Comienza una operación asincrónica para aceptar un intento de conexión entrante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-253">Begins an asynchronous operation to accept an incoming connection attempt.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-254">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-254">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-255">Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-255">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d9a09-256">Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-256">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-257">Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-257">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d9a09-258">Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-258">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-259">Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-259">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d9a09-260">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-260">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-261">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-261">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-262">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-262">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d9a09-263">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-263">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="d9a09-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> objeto que puede usar para enviar y recibir datos con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d9a09-265">No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-265">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d9a09-266">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-266">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-267">Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-267">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d9a09-268">El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-268">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d9a09-269">En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-269">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d9a09-270">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-270">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-271">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-271">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-272">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-272">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d9a09-273">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-273">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-274">Puede usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-274">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-275">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-275">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-276">Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-276">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-277">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-277">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-278">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-278">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-279">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-279">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-280">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-280">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-281">En el ejemplo de código siguiente se intenta recibir una conexión entrante de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-281">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-282">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-282">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-283">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-283">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-284">El socket receptor no realiza escuchas de conexiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-284">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="d9a09-285">Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-285">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="d9a09-286">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-286">-or-</span>
          </span>
          <span data-ttu-id="d9a09-287">El socket aceptado se encuentra enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-287">The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-288">
            <paramref name="receiveSize" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-288">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-289">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-289">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-290">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-290">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-291">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-291">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">
          <span data-ttu-id="d9a09-292">Número de bytes que se han de aceptar del remitente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-292">The number of bytes to accept from the sender.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-293">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-293">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-294">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-294">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-295">Comienza una operación asincrónica para aceptar un intento de conexión entrante y recibe el primer bloque de datos enviado por la aplicación cliente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-295">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-296">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-296">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-297">Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-297">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d9a09-298">Aceptar conexiones de forma asincrónica permite enviar y recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-298">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-299">Esta sobrecarga permite especificar el número de bytes que se acepte en la transferencia inicial en el `receiveSize` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-299">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-300">Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-300">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d9a09-301">Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-301">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-302">Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-302">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d9a09-303">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-303">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-304">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-304">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-305">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-305">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d9a09-306">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-306">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="d9a09-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede usar para enviar y recibir datos con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d9a09-308">No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-308">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d9a09-309">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-309">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-310">Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-310">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d9a09-311">El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-311">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d9a09-312">En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-312">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d9a09-313">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-313">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-314">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-314">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="d9a09-315">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-315">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d9a09-316">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-316">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-317">Puede llamar a usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> objeto para identificar el número de puerto y la dirección de red del host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-317">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-318">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-318">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-319">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-319">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-320">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-321">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-322">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-322">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-323">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-323">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-324">En el ejemplo de código siguiente se abre un socket y acepta una conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-324">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="d9a09-325">En este ejemplo, el socket acepta los 10 bytes iniciales de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-325">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="d9a09-326">El número de bytes recibidos y los datos se muestran en la consola por el delegado de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-326">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="d9a09-327">Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obtener una descripción de cómo se reciben los datos restantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-327">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-328">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-328">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-329">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-329">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-330">El socket receptor no realiza escuchas de conexiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-330">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="d9a09-331">Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-331">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="d9a09-332">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-332">-or-</span>
          </span>
          <span data-ttu-id="d9a09-333">El socket aceptado se encuentra enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-333">The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-334">
            <paramref name="receiveSize" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-334">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-335">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-335">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-336">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-336">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-337">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-337">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">
          <span data-ttu-id="d9a09-338">Objeto <see cref="T:System.Net.Sockets.Socket" /> aceptado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-338">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
          <span data-ttu-id="d9a09-339">Este valor puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-339">This value may be <see langword="null" />.</span>
          </span>
        </param>
        <param name="receiveSize">
          <span data-ttu-id="d9a09-340">Número máximo de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-340">The maximum number of bytes to receive.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-341">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-341">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-342">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-342">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-343">Comienza una operación asincrónica para aceptar un intento de conexión entrante desde un socket específico y recibe el primer bloque de datos enviado por la aplicación cliente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-343">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-344">Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-344">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-345">Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-345">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d9a09-346">Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-346">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-347">Esta sobrecarga permite especificar el socket aceptado en el `acceptSocket` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-347">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="d9a09-348">Si este parámetro es `null`, se crea el socket aceptado por el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-348">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-349">Puede especificar el número de bytes que se acepte en la transferencia inicial en el `receiveSize` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-349">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-350">Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-350">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d9a09-351">Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-351">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-352">Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-352">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d9a09-353">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-353">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-354">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-354">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-355">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-355">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d9a09-356">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-356">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="d9a09-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> objeto que puede usar para enviar y recibir datos con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d9a09-358">No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-358">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d9a09-359">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-359">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-360">Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-360">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d9a09-361">El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-361">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d9a09-362">En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-362">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d9a09-363">Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-363">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-364">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-364">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-365">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-365">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d9a09-366">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-366">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-367">Puede usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> objeto para identificar el número de puerto y la dirección de red del host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-367">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-368">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-368">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-369">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-369">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-370">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-370">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-371">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-371">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-372">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-372">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-373">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-373">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-374">En el ejemplo de código siguiente se abre un socket y acepta una conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-374">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="d9a09-375">En este ejemplo, el socket acepta los 10 bytes de datos iniciales y la `acceptSocket` parámetro es `null`, que fuerza la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método para crear el socket aceptado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-375">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="d9a09-376">El número de bytes recibidos y los datos se muestran en la consola por el delegado de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-376">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="d9a09-377">Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obtener una descripción de cómo se reciben los datos restantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-377">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-378">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-378">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-379">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-379">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-380">El socket receptor no realiza escuchas de conexiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-380">The accepting socket is not listening for connections.</span>
          </span>
          <span data-ttu-id="d9a09-381">Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-381">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
          <span data-ttu-id="d9a09-382">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-382">-or-</span>
          </span>
          <span data-ttu-id="d9a09-383">El socket aceptado se encuentra enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-383">The accepted socket is bound.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-384">
            <paramref name="receiveSize" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-384">
              <paramref name="receiveSize" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-385">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-385">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-386">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-386">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-387">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-387">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-388">Inicia una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-388">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-389">
            <see cref="T:System.Net.EndPoint" /> que representa el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-389">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span>
          </span>
        </param>
        <param name="end_point">
          <span data-ttu-id="d9a09-390">
            <see cref="T:System.Net.EndPoint" /> que representa el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-390">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-391">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-391">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-392">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-392">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-393">Inicia una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-393">Begins an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-394">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-394">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-395">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.BeginConnect%2A> método inicia una solicitud asincrónica para una conexión a la `remoteEP` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-395">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="d9a09-396">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-396">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d9a09-397">Conectar o establecer el host remoto predeterminado de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-397">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-398">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-398">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="d9a09-399">Como mínimo, debe pasar el <xref:System.Net.Sockets.Socket> a <xref:System.Net.Sockets.Socket.BeginConnect%2A> a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-399">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="d9a09-400">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket>y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-400">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="d9a09-401">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-401">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-402">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-402">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d9a09-403">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndConnect%2A> hasta que el <xref:System.Net.Sockets.Socket> se conecta correctamente o produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-403">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="d9a09-404">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-404">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="d9a09-405">Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-405">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-406">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-406">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-407">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-407">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-408">Puede usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> y <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> para comunicarse con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-408">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d9a09-409">Si se llama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-409">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-410">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-410">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d9a09-411">Si no es posible, <xref:System.Net.Sockets.Socket.BeginConnect%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-411">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-412">Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-412">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-413">Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección de red local hasta que llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-413">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-414">Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-414">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d9a09-415">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-415">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-416">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-416">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d9a09-417">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-417">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-418">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-418">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-419">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-419">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-420">Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-420">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d9a09-421">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-421">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-422">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-422">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-423">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-423">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-424">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-424">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-425">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-425">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-426">El ejemplo de código siguiente inicia un intento de conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-426">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-427">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-427">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-428">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-428">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-429">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-430">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-430">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-431">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-431">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-432">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-432">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-433">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-433">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-434">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-434">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="d9a09-435">
            <see cref="T:System.Net.IPAddress" /> del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-435">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-436">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-436">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="d9a09-437">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-437">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-438">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-438">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-439">Objeto definido por el usuario que contiene información sobre la operación de conexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-439">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="d9a09-440">Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-440">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-441">Inicia una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-441">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="d9a09-442">El host se especifica mediante una <see cref="T:System.Net.IPAddress" /> y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-442">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-443">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-443">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-444">Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-444">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d9a09-445">Normalmente, se invoca el método por el `requestCallback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-445">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-446">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-446">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-447">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método o <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-447">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-448">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-448">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-449">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-449">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d9a09-450">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-450">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d9a09-451">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="d9a09-451">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-452">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-452">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-453">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-453">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-454">Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-454">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d9a09-455">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-455">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d9a09-456">También la <xref:System.Net.EndPoint> que es usado debe ser diferente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-456">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-457">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-457">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-458">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-458">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-459">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-459">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-460">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-460">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-461">El ejemplo de código siguiente inicia un intento de conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-461">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-462">El valor de <paramref name="address" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-462">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-463">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-463">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-464">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-465">El <see cref="T:System.Net.Sockets.Socket" /> no está en la familia de sockets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-465">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-466">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-466">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-467">La longitud de <paramref name="address" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-467">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-468">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-468">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-469">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-469">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-470">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-470">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-471">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-471">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="d9a09-472">Al menos una <see cref="T:System.Net.IPAddress" />, que designa el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-472">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-473">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-473">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="d9a09-474">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-474">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-475">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-475">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-476">Objeto definido por el usuario que contiene información sobre la operación de conexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-476">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="d9a09-477">Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-477">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-478">Inicia una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-478">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="d9a09-479">El host se especifica mediante una matriz <see cref="T:System.Net.IPAddress" /> y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-479">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-480">
            <see cref="T:System.IAsyncResult" /> que hace referencia a las conexiones asincrónicas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-480">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-481">Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-481">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d9a09-482">Normalmente, se invoca el método por el `requestCallback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-482">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-483">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-483">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-484">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-484">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-485">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-485">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-486">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-486">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d9a09-487">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-487">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d9a09-488">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-488">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-489">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-489">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-490">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-490">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-491">Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-491">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d9a09-492">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-492">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d9a09-493">También la <xref:System.Net.EndPoint> que es usado debe ser diferente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-493">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-494">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-495">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-496">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-496">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-497">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-497">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-498">El ejemplo de código siguiente inicia un intento de conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-498">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-499">El valor de <paramref name="addresses" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-499">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-500">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-500">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-501">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-501">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-502">Este método es válido para sockets que usan <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-502">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-503">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-503">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-504">La longitud de <paramref name="address" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-504">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-505">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-505">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-506">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-506">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-507">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-507">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-508">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-508">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="d9a09-509">Nombre del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-509">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-510">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-510">The port number of the remote host.</span>
          </span>
        </param>
        <param name="requestCallback">
          <span data-ttu-id="d9a09-511">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-511">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-512">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-512">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-513">Objeto definido por el usuario que contiene información sobre la operación de conexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-513">A user-defined object that contains information about the connect operation.</span>
          </span>
          <span data-ttu-id="d9a09-514">Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-514">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-515">Inicia una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-515">Begins an asynchronous request for a remote host connection.</span>
          </span>
          <span data-ttu-id="d9a09-516">El host se especifica mediante un nombre de host y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-516">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-517">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-517">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-518">Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-518">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d9a09-519">Normalmente, se invoca el método por el `requestCallback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-519">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-520">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-520">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-521">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-521">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-522">Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-522">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-523">Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-523">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d9a09-524">Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-524">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d9a09-525">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="d9a09-525">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-526">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-526">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-527">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-527">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-528">Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-528">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d9a09-529">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-529">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d9a09-530">También la <xref:System.Net.EndPoint> que es usado debe ser diferente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-530">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-531">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-531">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-532">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-532">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-533">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-533">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-534">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-534">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-535">El ejemplo de código siguiente inicia un intento de conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-535">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-536">El valor de <paramref name="host" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-536">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-537">Se cerró el <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-538">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-538">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-539">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-539">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-540">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-540">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span>
          </span>
        </exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-541">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-541">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-542">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-542">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-543">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-543">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="d9a09-544">
            <see langword="true" /> si se puede reutilizar el socket una vez cerrada la conexión; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-544">
              <see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-545">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-545">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-546">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-546">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-547">Comienza una solicitud asincrónica para la desconexión de un extremo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-547">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-548">Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-548">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-549">Si utiliza un protocolo orientado a conexiones, puede llamar a la <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método para solicitar una desconexión de un extremo remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-549">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="d9a09-550">Si `reuseSocket` es `true`, se puede reutilizar el socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-550">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="d9a09-551">El <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método usa un subproceso independiente para invocar el método de devolución de llamada especificadas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-551">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="d9a09-552">El <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método se bloquea hasta que la desconexión pendiente completada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-552">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="d9a09-553">Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-553">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-554">Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-554">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-555">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-555">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-556">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-557">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-558">En el ejemplo de código siguiente se crea un socket para la comunicación asincrónica y envía datos a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-558">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d9a09-559">Cuando los datos se ha enviado, <xref:System.Net.Sockets.Socket.Shutdown%2A> se llama para detener el envío y recepción de actividad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-559">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="d9a09-560">A continuación, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> se llama para iniciar una solicitud de desconexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-560">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="d9a09-561">Cuando se completa la solicitud, el <xref:System.Net.Sockets.Socket.Connected%2A> es consultar la propiedad para comprobar si el socket está desconectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-561">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-562">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-562">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-563">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-563">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-564">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-564">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-565">Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-565">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-566">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-566">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-567">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-567">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-568">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-568">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-569">Objeto definido por el usuario que contiene información sobre la operación de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-569">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="d9a09-570">Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-570">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-571">Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-572">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-572">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-573">Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-573">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d9a09-574">Normalmente, se invoca el método por el `callback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-574">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-575">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-575">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-576">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-576">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-577">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-577">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-578">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-578">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-579">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-580">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-580">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-581">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-581">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-582">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-582">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-583">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-583">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-584">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-584">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-585">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-585">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-586">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-586">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-587">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-587">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-588">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-588">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-589">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-589">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-590">
            <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-590">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-591">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-591">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-592">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-592">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-593">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-593">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-594">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-594">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-595">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-595">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-596">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-596">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-597">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-597">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-598">Objeto definido por el usuario que contiene información sobre la operación de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-598">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="d9a09-599">Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-599">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-600">Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-600">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-601">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-601">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-602">Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-602">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d9a09-603">Normalmente, se invoca el método por el `callback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-603">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-604">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-604">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-605">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-605">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-606">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-606">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-607">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-607">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-608">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-608">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-609">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-609">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-610">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-610">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-611">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-611">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-612">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-612">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-613">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-613">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-614">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-614">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-615">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-615">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-616">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-616">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-617">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-617">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-618">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-618">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-619">
            <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-619">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-620">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-620">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-621">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-621">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-622">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-622">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-623">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-623">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-624">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-624">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-625">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-625">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-626">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-626">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="d9a09-627">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-627">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-628">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-628">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-629">Objeto definido por el usuario que contiene información sobre la operación de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-629">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="d9a09-630">Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-630">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-631">Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-631">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-632">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-632">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-633">Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-633">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d9a09-634">Normalmente, se invoca el método por el `callback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-634">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-635">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-635">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-636">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-636">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-637">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-637">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-638">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-638">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-639">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-639">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-640">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-640">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-641">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-641">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-642">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-642">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-643">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-643">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-644">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-644">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-645">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-645">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-646">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-646">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-647">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-647">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-648">En el siguiente ejemplo se comienza a recibir asincrónicamente los datos desde un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-648">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-649">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-649">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-650">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-650">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-651">
            <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-651">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-652">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-652">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-653">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-653">-or-</span>
          </span>
          <span data-ttu-id="d9a09-654">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-654">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-655">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-655">-or-</span>
          </span>
          <span data-ttu-id="d9a09-656">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-656">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-657">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-657">-or-</span>
          </span>
          <span data-ttu-id="d9a09-658">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-658">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-659">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-659">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-660">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-660">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-661">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-661">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-662">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-662">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-663">Ubicación de <paramref name="buffer" /> en la que se almacenarán los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-663">The location in <paramref name="buffer" /> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-664">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-664">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-665">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-665">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="d9a09-666">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-666">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-667">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-667">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="error">
          <span data-ttu-id="d9a09-668">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-668">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-669">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-669">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-670">Objeto definido por el usuario que contiene información sobre la operación de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-670">A user-defined object that contains information about the receive operation.</span>
          </span>
          <span data-ttu-id="d9a09-671">Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-671">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-672">Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-672">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-673">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-673">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-674">Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-674">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d9a09-675">Normalmente, se invoca el método por el `callback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-675">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-676">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-676">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d9a09-677">Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-677">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d9a09-678">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-678">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-679">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-679">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-680">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-681">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-681">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-682">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-682">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-683">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-683">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-684">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-684">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-685">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-685">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-686">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-686">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-687">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-687">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-688">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-688">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-689">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-689">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-690">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-690">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-691">
            <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-691">
              <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-692">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-692">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-693">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-693">-or-</span>
          </span>
          <span data-ttu-id="d9a09-694">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-694">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-695">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-695">-or-</span>
          </span>
          <span data-ttu-id="d9a09-696">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-696">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-697">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-697">-or-</span>
          </span>
          <span data-ttu-id="d9a09-698">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-698">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-699">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-699">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-700">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-700">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-701">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-701">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-702">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-702">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-703">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-703">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-704">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-704">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-705">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-705">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="d9a09-706">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-706">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-707">
            <see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-707">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="remote_end">
          <span data-ttu-id="d9a09-708">
            <see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-708">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-709">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-709">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-710">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-710">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-711">Comienza a recibir asincrónicamente los datos de un dispositivo de red especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-711">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-712">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-712">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-713">El <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método comienza a leer de forma asincrónica datagramas sin conexión desde un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-713">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="d9a09-714">Una llamada a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método le permite recibir datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-714">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-715">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-715">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-716">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-716">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-717">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-717">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-718">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-718">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-719">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-719">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-720">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y bloqueará en <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> hasta que el <xref:System.Net.Sockets.Socket> lee datos o produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-720">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="d9a09-721">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-721">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-722">Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-722">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-723">Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-723">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-724">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-724">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-725">Este método lee los datos en el `buffer` parámetro y el host remoto desde el que se envían los datos de punto de conexión de capturas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-725">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="d9a09-726">Para obtener información sobre cómo recuperar este punto de conexión, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-726">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="d9a09-727">Este método es muy útil si va a recibir asincrónicamente los datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-727">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="d9a09-728">En estos casos, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-728">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d9a09-729">Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-729">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-730">Si usa un protocolo no confiable, el exceso de datos se perderá.</span><span class="sxs-lookup"><span data-stu-id="d9a09-730">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d9a09-731">Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método con un búfer suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="d9a09-731">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d9a09-732">Para garantizar que siempre se devuelve el punto de conexión del host remoto, una aplicación debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método y, después, llame el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método con el `optionLevel` parámetro establecido en <xref:System.Net.Sockets.SocketOptionLevel.IP>o <xref:System.Net.Sockets.SocketOptionLevel.IPv6> según corresponda, el `optionName` parámetro establecido en <xref:System.Net.Sockets.SocketOptionName.PacketInformation>y el `optionValue` parámetro para habilitar esta opción antes de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-732">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-733">En caso contrario, es posible que el punto de conexión del host remoto no se devolverá cuando el remitente ha enviado un número de datagramas antes de que el receptor haya llamado el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-733">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-734">Aunque <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-734">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d9a09-735">Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> método o Aceptar una solicitud de conexión entrantes mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-735">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-736">Si se llama a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método antes de establecer o Aceptar una conexión, obtendrá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-736">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-737">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-737">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-738">En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-738">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-739">Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-739">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-740">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-740">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-741">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-741">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-742">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-742">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-743">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-743">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-744">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-744">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-745">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-745">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-746">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-746">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-747">El ejemplo de código siguiente recibe datagramas sin conexión desde un host remoto de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-747">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-748">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-748">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-749">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-749">-or-</span>
          </span>
          <span data-ttu-id="d9a09-750">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-750">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-751">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-751">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-752">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-752">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-753">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-753">-or-</span>
          </span>
          <span data-ttu-id="d9a09-754">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-754">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-755">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-755">-or-</span>
          </span>
          <span data-ttu-id="d9a09-756">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-756">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-757">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-757">-or-</span>
          </span>
          <span data-ttu-id="d9a09-758">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-758">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-759">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-760">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-760">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-761">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-761">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-762">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-762">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-763">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-763">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-764">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-764">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-765">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-765">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-766">
            <see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-766">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-767">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-767">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-768">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-768">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-769">Comienza a recibir de forma asincrónica el número especificado de bytes de datos en la ubicación indicada del búfer de datos, mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado, y almacena el extremo e información sobre paquetes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-769">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-770">
            <see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-770">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-771">Operación de recepción asincrónica debe realizarse mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-771">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="d9a09-772">Normalmente, se invoca el método por el `asyncCallback` delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-772">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="d9a09-773">Este método no se bloquea hasta que se complete la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-773">This method does not block until the operation completes.</span></span> <span data-ttu-id="d9a09-774">Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-774">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-775">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-775">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-776">Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="d9a09-776">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="d9a09-777">Este método lee los datos en el `buffer` parámetro y el host remoto desde el que se envían los datos de punto de conexión de capturas, así como información sobre el paquete recibido.</span><span class="sxs-lookup"><span data-stu-id="d9a09-777">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="d9a09-778">Para obtener información sobre cómo recuperar este punto de conexión, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-778">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="d9a09-779">Este método es muy útil si va a recibir asincrónicamente los datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-779">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-780">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-781">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-781">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-782">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-782">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-783">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-783">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-784">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-784">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-785">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-785">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-786">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-786">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-787">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-787">-or-</span>
          </span>
          <span data-ttu-id="d9a09-788">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-788">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-789">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-789">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-790">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-790">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-791">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-791">-or-</span>
          </span>
          <span data-ttu-id="d9a09-792">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-792">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-793">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-793">-or-</span>
          </span>
          <span data-ttu-id="d9a09-794">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-794">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-795">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-795">-or-</span>
          </span>
          <span data-ttu-id="d9a09-796">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-796">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-797">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-797">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-798">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-798">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-799">Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-799">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-800">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-800">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-801">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-801">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-802">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-802">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-803">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-803">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-804">Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-805">
            <see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-805">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-806">El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-806">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-808">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-808">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-809">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-809">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d9a09-810">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-810">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-811">Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-811">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-812">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-812">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-813">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-813">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d9a09-814">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-814">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d9a09-815">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-815">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-816">Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-816">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-817">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-817">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-818">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-818">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-819">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-819">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d9a09-820">No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-820">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-821">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-821">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-822">Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-822">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-823">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-823">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-824">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-824">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-825">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-825">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-826">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-826">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-827">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-827">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-828">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-828">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-829">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-829">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-830">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-830">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-831">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-831">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-832">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-833">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-834">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-834">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-835">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-835">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-836">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-836">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-837">
            <paramref name="buffers" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-837">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-838">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-838">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-839">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-839">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-840">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-840">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-841">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-841">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-842">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-842">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-843">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-843">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-844">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-844">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-845">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-845">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-846">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-846">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-847">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-847">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-848">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-848">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-849">Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-849">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-850">
            <see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-850">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-851">El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-851">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-853">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-853">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-854">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-854">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d9a09-855">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-855">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-856">Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-856">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-857">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-857">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-858">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-858">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d9a09-859">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-859">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d9a09-860">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-860">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-861">Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-861">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-862">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-862">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-863">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-863">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-864">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-864">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d9a09-865">No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-865">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-866">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-866">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-867">Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-867">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-868">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-868">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-869">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-869">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-870">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-870">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-871">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-871">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-872">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-872">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-873">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-873">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-874">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-874">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-875">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-875">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-876">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-876">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-877">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-877">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-878">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-878">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-879">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-879">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-880">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-880">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-881">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-881">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-882">
            <paramref name="buffers" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-882">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-883">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-883">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-884">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-884">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-885">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-885">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-886">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-886">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-887">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-887">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-888">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-888">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-889">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-889">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-890">Posición de base cero del parámetro <paramref name="buffer" /> donde se empezará a enviar los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-890">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-891">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-891">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-892">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-893">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-894">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-894">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-895">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-895">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-896">Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-896">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-897">
            <see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-897">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-898">El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-898">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-900">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-900">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-901">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-901">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d9a09-902">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-902">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-903">Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-903">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-904">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-904">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-905">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-905">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d9a09-906">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-906">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d9a09-907">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-907">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-908">Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-908">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-909">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-909">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-910">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-910">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-911">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d9a09-912">No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-912">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-913">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-914">Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-914">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-915">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-915">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-916">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-916">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-917">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-918">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-918">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-919">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-919">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-920">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-920">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-921">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-921">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-922">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-922">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-923">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-923">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-924">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-925">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-926">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-926">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-927">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-927">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-928">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-928">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-929">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-929">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-930">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-930">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-931">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-931">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-932">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-932">-or-</span>
          </span>
          <span data-ttu-id="d9a09-933">
            <paramref name="offset" /> es menor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-933">
              <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-934">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-934">-or-</span>
          </span>
          <span data-ttu-id="d9a09-935">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-935">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-936">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-936">-or-</span>
          </span>
          <span data-ttu-id="d9a09-937">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-937">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-938">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-938">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-939">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-939">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-940">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-940">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-941">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-941">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-942">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-942">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-943">Posición de base cero del parámetro <paramref name="buffer" /> donde se empezará a enviar los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-943">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-944">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-944">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-945">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-945">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="d9a09-946">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-946">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-947">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-947">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-948">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-948">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-949">Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-949">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-950">
            <see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-950">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-951">El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-951">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d9a09-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-953">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-953">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-954">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-954">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d9a09-955">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-955">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-956">Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-956">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-957">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-957">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-958">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-958">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d9a09-959">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-959">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d9a09-960">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-960">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-961">Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-961">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-962">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-962">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-963">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-963">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-964">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-964">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d9a09-965">No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-965">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-966">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-966">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-967">Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-967">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-968">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-968">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-969">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-970">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-970">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-971">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-971">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-972">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-972">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-973">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-973">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-974">`state` es una instancia de una clase definida por el usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-974">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-975">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-975">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-976">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-976">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-977">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-978">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-979">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-979">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-980">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-980">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-981">El siguiente ejemplo de código comienza a enviar datos a un host remoto de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-981">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-982">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-982">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-983">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-983">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-984">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-984">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-985">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-985">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-986">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-986">-or-</span>
          </span>
          <span data-ttu-id="d9a09-987">
            <paramref name="offset" /> es menor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-987">
              <paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-988">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-988">-or-</span>
          </span>
          <span data-ttu-id="d9a09-989">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-989">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-990">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-990">-or-</span>
          </span>
          <span data-ttu-id="d9a09-991">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-991">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-992">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-993">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-993">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">
          <span data-ttu-id="d9a09-994">Ejemplo de sockets de cliente asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-994">Asynchronous Client Socket Example</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">
          <span data-ttu-id="d9a09-995">Ejemplo de sockets de servidor asincrónicos</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-995">Asynchronous Server Socket Example</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-996">Envía, de forma asincrónica, un archivo a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-996">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="d9a09-997">Cadena con la ruta de acceso y el nombre del archivo que se ha de enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-997">A string that contains the path and name of the file to send.</span>
          </span>
          <span data-ttu-id="d9a09-998">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-998">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-999">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-999">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-1000">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1000">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1001">Envía el archivo <paramref name="fileName" /> a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el marcador <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1001">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1002">Objeto <see cref="T:System.IAsyncResult" /> que representa el envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1002">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1003">Esta sobrecarga envía el archivo `fileName` al socket conectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="d9a09-1004">Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1004">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d9a09-1005">Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1005">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d9a09-1006">Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1006">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d9a09-1007">Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1007">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d9a09-1008">Para obtener más información sobre la `TransmitFile` función y sus marcas, consulte la documentación de Windows Sockets en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1008">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="d9a09-1009">El <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1009">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="d9a09-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-1011">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método le permite enviar un archivo en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1011">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-1012">Para completar la operación, puede crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> parámetro del delegado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1012">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="d9a09-1013">Para ello, como mínimo, el `state` parámetro debe contener el <xref:System.Net.Sockets.Socket> objeto utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1013">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="d9a09-1014">Si la devolución de llamada, necesita más información, puede crear una clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1014">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-1015">Pasar una instancia de este objeto personalizado a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1015">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1016">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1016">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="d9a09-1017">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, el sistema utiliza un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndSendFile%2A> hasta que el <xref:System.Net.Sockets.Socket> envía todo el archivo o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1017">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="d9a09-1018">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1018">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-1019">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1019">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-1020">Protocolos sin conexión, debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1020">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-1021">Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1021">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1022">Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1022">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1023">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1023">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1024">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1024">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1025">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1025">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1026">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1026">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-1027">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1027">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1028">En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1028">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="d9a09-1029">En primer lugar, el archivo "text.txt" se envía de forma asincrónica al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1029">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="d9a09-1030">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1030">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1031">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1032">El socket no está conectado a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1032">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d9a09-1033">No se encontró el archivo <paramref name="fileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1033">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1034">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1034">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1035">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1035">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="d9a09-1036">Cadena con la ruta de acceso y el nombre del archivo que se ha de enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1036">A string that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="d9a09-1037">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1037">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="d9a09-1038">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar antes de enviar el archivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1038">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="d9a09-1039">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1039">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="d9a09-1040">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar después de enviar el archivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1040">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="d9a09-1041">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1041">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="d9a09-1042">Combinación bit a bit de valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1042">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-1043">Delegado <see cref="T:System.AsyncCallback" /> al que invocar una vez completada la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1043">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span>
          </span>
          <span data-ttu-id="d9a09-1044">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1044">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-1045">Objeto definido por el usuario con información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1045">A user-defined object that contains state information for this request.</span>
          </span>
          <span data-ttu-id="d9a09-1046">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1046">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1047">Envía, de forma asincrónica, un archivo y búferes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1047">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1048">Objeto <see cref="T:System.IAsyncResult" /> que representa la operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1048">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1049">Esta sobrecarga requiere el nombre del archivo que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1049">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="d9a09-1050">El `preBuffer` parámetro contiene todos los datos debe preceder el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1050">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="d9a09-1051">`postBuffer` contiene los datos que desea que siga el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1051">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="d9a09-1052">Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1052">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d9a09-1053">Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1053">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d9a09-1054">Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1054">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d9a09-1055">El `flags` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1055">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d9a09-1056">Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1056">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d9a09-1057">Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1057">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d9a09-1058">Para obtener más información sobre la `TransmitFile` función y sus marcas, consulte la documentación de Windows Sockets en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1058">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="d9a09-1059">El <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1059">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="d9a09-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d9a09-1061">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método le permite enviar un archivo dentro de un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1061">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-1062">Para completar la operación, puede crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> parámetro del delegado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1062">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="d9a09-1063">Para ello, como mínimo, el `state` parámetro debe contener el <xref:System.Net.Sockets.Socket> objeto utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1063">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="d9a09-1064">Si la devolución de llamada, necesita más información, puede crear una clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1064">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d9a09-1065">Pasar una instancia de este objeto personalizado a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1065">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1066">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1066">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="d9a09-1067">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, el sistema utiliza un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndSendFile%2A> hasta que el <xref:System.Net.Sockets.Socket> envía todo el archivo o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1067">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="d9a09-1068">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1068">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-1069">Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1069">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-1070">Protocolos sin conexión, también debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1070">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-1071">Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1071">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1072">Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1072">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1073">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1073">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1074">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1074">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1075">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1075">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1076">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1076">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-1077">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1077">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1078">En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica y comienza a enviar el archivo "text.txt" asincrónicamente al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1078">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="d9a09-1079">En este ejemplo, un `preBuffer` y un `postBuffer` de datos se crea para enviar con el archivo y el valor predeterminado <xref:System.Net.Sockets.TransmitFileOptions> se usa el valor.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1079">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="d9a09-1080">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1080">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1081">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1081">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1082">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1082">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1083">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1083">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1084">El sistema operativo no es Windows NT o una versión posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1084">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="d9a09-1085">\- o -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1085">\- or -</span>
          </span>
          <span data-ttu-id="d9a09-1086">El socket no está conectado a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1086">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d9a09-1087">No se encontró el archivo <paramref name="fileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1087">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-1088">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1088">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-1089">Posición de base cero en el parámetro <paramref name="buffer" /> donde comienza el envío de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1089">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-1090">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1090">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-1091">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1091">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="socket_flags">
          <span data-ttu-id="d9a09-1092">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1092">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-1093">
            <see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1093">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <param name="remote_end">
          <span data-ttu-id="d9a09-1094">
            <see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1094">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="d9a09-1095">Delegado <see cref="T:System.AsyncCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1095">The <see cref="T:System.AsyncCallback" /> delegate.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="d9a09-1096">Objeto que contiene la información de estado para esta solicitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1096">An object that contains state information for this request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1097">Envía datos de forma asincrónica a un host remoto concreto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1097">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1098">
            <see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1098">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1099">El <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método inicia una operación de envío asincrónico al host remoto especificado en el `remoteEP` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1099">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="d9a09-1100">Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1100">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-1101">Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funciona con los protocolos sin conexión y orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1101">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d9a09-1102">Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1102">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="d9a09-1103">Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1103">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d9a09-1104">Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket>y otra información necesaria.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1104">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="d9a09-1105">Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método a través de la `state` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1105">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1106">El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1106">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="d9a09-1107">Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSendTo%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1107">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d9a09-1108">Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1108">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d9a09-1109">Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1109">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d9a09-1110">Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1110">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="d9a09-1111">Si utiliza un protocolo orientado a conexiones, primero debe llamar a la <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1111">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> pasará por alto el `remoteEP` parámetro y envía los datos a la <xref:System.Net.EndPoint> establecidos en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1113">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1113">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-1114">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1114">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d9a09-1115">Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1115">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-1116">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1116">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-1117">En este caso, el proveedor de servicios subyacente asignará al número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1117">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-1118">Use un número de puerto de cero si desea que el proveedor de servicios subyacente para seleccionar un puerto libre.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1118">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="d9a09-1119">Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.EndSendTo%2A> método se completa correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1119">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d9a09-1120">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1120">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-1121">-También debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1121">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-1122">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.EndSendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1122">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-1123">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1124">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1125">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1125">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1126">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1127">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1128">El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1128">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d9a09-1129">Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1129">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1130">En el ejemplo de código siguiente se envía de forma asincrónica datos al host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1130">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1131">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1131">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-1132">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1132">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1133">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1133">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1134">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1134">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-1135">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1135">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-1136">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1136">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1137">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1137">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-1138">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1138">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1139">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1139">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-1140">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1140">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1141">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1141">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1142">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1142">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1143">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1143">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">
          <span data-ttu-id="d9a09-1144">Serialización de un delegado como un método de devolución de llamada</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1144">Marshaling a Delegate as a Callback Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <span data-ttu-id="d9a09-1145">
            <see cref="T:System.Net.EndPoint" /> local que se va a asociar a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1145">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1146">Asocia un objeto <see cref="T:System.Net.Sockets.Socket" /> a un extremo local.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1146">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1147">Utilice el <xref:System.Net.Sockets.Socket.Bind%2A> método si tiene que utilizar un extremo local específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1147">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="d9a09-1148">Debe llamar a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar el <xref:System.Net.Sockets.Socket.Listen%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1148">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="d9a09-1149">No es necesario llamar a <xref:System.Net.Sockets.Socket.Bind%2A> antes de usar el <xref:System.Net.Sockets.Socket.Connect%2A> método a menos que necesite utilizar un extremo local específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1149">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="d9a09-1150">Puede usar el <xref:System.Net.Sockets.Socket.Bind%2A> método en protocolos sin conexión y orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1150">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d9a09-1151">Antes de llamar a <xref:System.Net.Sockets.Socket.Bind%2A>, primero debe crear la variable local <xref:System.Net.IPEndPoint> desde que se va a comunicar los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1151">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="d9a09-1152">Si no te importa qué dirección local se asigna, puede crear un <xref:System.Net.IPEndPoint> utilizando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como el parámetro de dirección y el servicio subyacente proveedor asignará la dirección de red más adecuada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1152">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="d9a09-1153">Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1153">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="d9a09-1154">Si no te importa qué puerto local se utiliza, puede crear un <xref:System.Net.IPEndPoint> con 0 para el número de puerto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1154">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="d9a09-1155">En este caso, el proveedor de servicios asignará a un número de puerto disponible entre 1024 y 5000.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1155">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="d9a09-1156">Si utiliza el enfoque anterior, puede detectar qué número de puerto y la dirección de red local se asignó mediante una llamada a la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1156">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="d9a09-1157">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> no devolverá la dirección de red asignada localmente hasta después de haber realizado una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1157">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d9a09-1158">Si usa un protocolo sin conexión, no tendrá acceso a esta información hasta que se ha realizado un envío o recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1158">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="d9a09-1159">Si un socket UDP desea recibir información de la interfaz en los paquetes recibidos, el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método debe llamarse explícitamente con la opción de socket establecida en <xref:System.Net.Sockets.SocketOptionName.PacketInformation> inmediatamente después de llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1159">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1160">Si tiene previsto recibir datagramas de multidifusión, debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método con un número de puerto de multidifusión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1160">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1161">Debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método si desea recibir datagramas sin conexión utilizando la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1161">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1162">Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1162">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1163">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1163">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1164">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1164">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1165">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1165">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1166">El siguiente código de ejemplo se enlaza un <xref:System.Net.Sockets.Socket> con el extremo local especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1166">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1167">El valor de <paramref name="localEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1167">
              <paramref name="localEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1168">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1168">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1169">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1169">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1170">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1170">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-1171">para aceptar conexiones desde el host definido por <paramref name="localEP" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1171">for accepting connections from the host defined by <paramref name="localEP" />.</span>
          </span>
          <span data-ttu-id="d9a09-1172">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1172">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1173">Obtiene o establece un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> está en modo de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1173">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1174">Es <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> se bloquea; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1174">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-1175">El valor predeterminado es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1175">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1176">El <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad indica si un <xref:System.Net.Sockets.Socket> está en modo de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1176">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="d9a09-1177">Si está en modo de bloqueo, y llamar a un método que no se completa inmediatamente, la aplicación bloqueará la ejecución hasta que se complete la operación solicitada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1177">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="d9a09-1178">Si desea que la ejecución continúe aunque la operación solicitada no está completa, cambie el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1178">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="d9a09-1179">El <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad no tiene ningún efecto sobre los métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="d9a09-1180">Si son enviar y recibir datos de forma asincrónica y desea bloquear la ejecución, use el <xref:System.Threading.ManualResetEvent> clase.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1180">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1181">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1182">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1182">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1183">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1184">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1185">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1185">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1186">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-1187">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para solicitar la conexión al host remoto llamando a uno de los métodos <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1187">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1188">Cancela una solicitud asincrónica de una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1188">Cancels an asynchronous request for a remote host connection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1189">El <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> método cancela una solicitud asincrónica de una conexión al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1189">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1190">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1190">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1191">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1191">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1192">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1193">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1193">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1194">Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1194">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1195">Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1195">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1196">El <xref:System.Net.Sockets.Socket.Close%2A> método cierra la conexión del host remoto y las versiones todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1196">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1197">Al cerrarse, el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad está establecida en `false`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1197">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="d9a09-1198">Para protocolos orientados a conexiones, se recomienda que llame <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1198">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="d9a09-1199">Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1199">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d9a09-1200">Si necesita llamar a <xref:System.Net.Sockets.Socket.Close%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede asegurarse de que los datos en cola para transmisión de salida que se enviará al establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opción `false` y especificando un intervalo de tiempo de espera distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1200">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="d9a09-1201"><xref:System.Net.Sockets.Socket.Close%2A> a continuación, se bloqueará hasta que estos datos se envían o hasta que expire el tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1201"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d9a09-1202">Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1202">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1203">Para establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción de socket `false`, cree un <xref:System.Net.Sockets.LingerOption>, establezca la propiedad habilitada en `true`y establezca el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad para el período de tiempo de espera deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1203">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="d9a09-1204">Use esta <xref:System.Net.Sockets.LingerOption> junto con el <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket opción para llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1204">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1205">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1206">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1207">El siguiente código en el ejemplo se cierra un <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1207">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="d9a09-1208">Espere hasta <paramref name="timeout" /> segundos para enviar los datos restantes y, después, cierre el socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1208">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1209">Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados con un tiempo de espera especificado para permitir el envío de los datos en cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1209">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1210">El <xref:System.Net.Sockets.Socket.Close%2A> método cierra la conexión del host remoto y las versiones todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1210">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1211">Al cerrarse, el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad está establecida en `false`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1211">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="d9a09-1212">Para protocolos orientados a conexiones, se recomienda que llame <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1212">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="d9a09-1213">Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1213">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d9a09-1214">Si necesita llamar a <xref:System.Net.Sockets.Socket.Close%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede asegurarse de que los datos en cola para transmisión de salida que se enviará al establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción `false` y especificando un intervalo de tiempo de espera distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1214">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="d9a09-1215"><xref:System.Net.Sockets.Socket.Close%2A> a continuación, se bloqueará hasta que estos datos se envían o hasta que expire el tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1215"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d9a09-1216">Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1216">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1217">Para establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción de socket `false`, cree un <xref:System.Net.Sockets.LingerOption>, establezca la propiedad habilitada en `true`y establezca el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad en el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1217">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="d9a09-1218">Use esta <xref:System.Net.Sockets.LingerOption> junto con el <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket opción para llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1218">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1219">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1219">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1220">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1220">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1221">El ejemplo de código siguiente muestra cómo cerrar una <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1221">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1222">Establece una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1222">Establishes a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-1223">
            <see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1223">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1224">Establece una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1224">Establishes a connection to a remote host.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1225">Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1225">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d9a09-1226">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1226">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d9a09-1227">Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1227">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1228">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1228">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1229">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1229">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1230">Si se llama <xref:System.Net.Sockets.Socket.Connect%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1230">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1231">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1231">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1232">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1233">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1233">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d9a09-1234">El <xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1234">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-1235">Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1235">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d9a09-1236">Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1236">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d9a09-1237">Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1237">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1238">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1238">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-1239">Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1239">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d9a09-1240">Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1240">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1241">Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1241">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d9a09-1242">Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1242">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d9a09-1243">Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1243">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1244">Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1244">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d9a09-1245">Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1245">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d9a09-1246">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1246">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1247">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1247">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1248">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1248">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1249">El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1249">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1250">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1250">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1251">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1251">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1252">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1252">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1253">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1253">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1254">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1254">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-1255">para conectarse al host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1255">for connecting to the remote host.</span>
          </span>
          <span data-ttu-id="d9a09-1256">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1256">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="d9a09-1257">Dirección IP del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1257">The IP address of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-1258">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1258">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1259">Establece una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1259">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="d9a09-1260">El host se especifica mediante una dirección IP y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1260">The host is specified by an IP address and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1261">Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1261">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d9a09-1262">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1262">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d9a09-1263">Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1263">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1264">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1264">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1265">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1265">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1266">Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1266">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1267">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1267">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1268">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1268">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1269">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1269">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d9a09-1270"><xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1270"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-1271">Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1271">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d9a09-1272">Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1272">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d9a09-1273">Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1273">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1274">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1274">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-1275">Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1275">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d9a09-1276">Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1276">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1277">Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1277">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d9a09-1278">Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1278">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d9a09-1279">Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1279">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1280">Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1280">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d9a09-1281">Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1281">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d9a09-1282">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1282">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1283">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1284">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1285">El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1285">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1286">El valor de <paramref name="address" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1286">
              <paramref name="address" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-1287">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1287">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1288">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1288">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1289">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1289">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1290">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1290">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1291">La longitud de <paramref name="address" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1291">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1292">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1292">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <span data-ttu-id="d9a09-1293">Direcciones IP del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1293">The IP addresses of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-1294">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1294">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1295">Establece una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1295">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="d9a09-1296">El host se especifica mediante una matriz de direcciones IP y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1296">The host is specified by an array of IP addresses and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1297">Este método se utiliza normalmente inmediatamente después de llamar a <xref:System.Net.Dns.GetHostAddresses%2A>, que puede devolver varias direcciones IP para un solo host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1297">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="d9a09-1298">Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1298">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d9a09-1299">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d9a09-1300">Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1300">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1301">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1301">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1302">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1302">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1303">Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1303">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1304">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1304">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1305">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1305">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1306">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1306">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d9a09-1307"><xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1307"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-1308">Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1308">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d9a09-1309">Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1309">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d9a09-1310">Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1310">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1311">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1311">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-1312">Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1312">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d9a09-1313">Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1313">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1314">Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1314">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d9a09-1315">Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1315">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d9a09-1316">Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1316">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1317">Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1317">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d9a09-1318">Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1318">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d9a09-1319">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1319">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1320">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1321">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1322">El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1322">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1323">El valor de <paramref name="addresses" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1323">
              <paramref name="addresses" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-1324">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1324">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1325">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1325">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1326">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1327">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1327">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1328">La longitud de <paramref name="address" /> es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1328">The length of <paramref name="address" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1329">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1329">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">
          <span data-ttu-id="d9a09-1330">Nombre del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1330">The name of the remote host.</span>
          </span>
        </param>
        <param name="port">
          <span data-ttu-id="d9a09-1331">Número de puerto del host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1331">The port number of the remote host.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1332">Establece una conexión a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1332">Establishes a connection to a remote host.</span>
          </span>
          <span data-ttu-id="d9a09-1333">El host se especifica mediante un nombre de host y un número de puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1333">The host is specified by a host name and a port number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1334">Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1334">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="d9a09-1335">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1335">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d9a09-1336">Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1336">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1337">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1337">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1338">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1338">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1339">Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1339">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1340">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1340">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1341">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1341">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1342">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1342">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d9a09-1343"><xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1343"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-1344">Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1344">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d9a09-1345">Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1345">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d9a09-1346">Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1346">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1347">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1347">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-1348">Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1348">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d9a09-1349">Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1349">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="d9a09-1350">Si IPv6 está habilitado y el <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> método se llama para conectarse a un host que se resuelve en ambos IPv6 y direcciones IPv4, la conexión a la dirección será de IPv6 intenta primero antes de la dirección IPv4.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1350">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="d9a09-1351">Esto puede tener el efecto de retrasar el tiempo para establecer la conexión si el host no está escuchando en la dirección IPv6.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1351">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1352">Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1352">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d9a09-1353">Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1353">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d9a09-1354">Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1354">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1355">Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1355">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d9a09-1356">Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1356">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d9a09-1357">Esta es una limitación del proveedor subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1357">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1358">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1359">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1360">El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1360">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1361">El valor de <paramref name="host" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1361">
              <paramref name="host" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-1362">El número de puerto no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1362">The port number is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1363">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1363">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1364">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1365">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1365">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1366">
            <see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1366">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1367">Comienza una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1367">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-1368">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1368">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1369">Comienza una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1369">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1370">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1370">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-1371">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1371">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-1372">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1372">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-1373">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1373">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1374">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicia una solicitud asincrónica para una conexión al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1374">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="d9a09-1375">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establece un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1375">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-1376">Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1376">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d9a09-1377">El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto al que conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1377">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="d9a09-1378">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1378">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-1379">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1379">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-1380">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1380">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1381">Puede usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> y <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para comunicarse con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1381">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1382">Si se llama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1382">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1383">Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1383">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d9a09-1384">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1384">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d9a09-1385">Si no se hace esto, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1385">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-1386">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:</span><span class="sxs-lookup"><span data-stu-id="d9a09-1386">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-1387">Opcionalmente, se puede proporcionar un búfer que se enviarán automáticamente en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1387">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d9a09-1388">En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para enviar y <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número de bytes de datos para enviar desde el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1388">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="d9a09-1389">Una vez establecida una conexión, se envía este búfer de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1389">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="d9a09-1390">Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1390">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="d9a09-1391">Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección IP de red local hasta que llame a la <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1391">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="d9a09-1392">El <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicie una excepción <xref:System.NotSupportedException> si la familia de direcciones de la <xref:System.Net.Sockets.Socket> y <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> no son la misma familia de direcciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1392">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1393">Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a este método, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1393">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1394">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1394">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1395">Un argumento no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1395">An argument is not valid.</span>
          </span>
          <span data-ttu-id="d9a09-1396">Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1396">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1397">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1397">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1398">El objeto <see cref="T:System.Net.Sockets.Socket" /> está escuchando o ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1398">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1399">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1399">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1400">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1400">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="d9a09-1401">Esta excepción también se produce si el extremo local y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no son la misma familia de direcciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1401">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1402">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1402">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1403">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1403">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <span data-ttu-id="d9a09-1404">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1404">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </param>
        <param name="protocolType">
          <span data-ttu-id="d9a09-1405">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1405">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="d9a09-1406">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1406">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1407">Comienza una solicitud asincrónica para una conexión a host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1407">Begins an asynchronous request for a connection to a remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1408">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1408">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-1409">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1409">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-1410">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1410">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-1411">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1411">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1412">Si utiliza un protocolo orientado a conexiones, el método System.NET.Sockets.ProtocolType inicia una solicitud asincrónica de un conexión al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1412">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="d9a09-1413">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establece un host remoto predeterminado especificado por el `socketType` y `protocolType` parámetros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1413">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="d9a09-1414">Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1414">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d9a09-1415">El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto al que conectarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1415">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="d9a09-1416">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1416">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-1417">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1417">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-1418">Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar y recibir datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1418">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="d9a09-1419">Puede usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> y <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para comunicarse con un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1419">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d9a09-1420">Si se llama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1420">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d9a09-1421">Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método nuevo con el punto de conexión deseado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d9a09-1422">Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1422">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d9a09-1423">Si no se hace esto, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1423">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-1424">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:</span><span class="sxs-lookup"><span data-stu-id="d9a09-1424">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-1425">Opcionalmente, se puede proporcionar un búfer que se enviarán automáticamente en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1425">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d9a09-1426">En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para enviar y <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número de bytes de datos para enviar desde el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1426">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="d9a09-1427">Una vez establecida una conexión, se envía este búfer de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1427">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="d9a09-1428">Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1428">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="d9a09-1429">Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección IP de red local hasta que llame a la <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1429">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="d9a09-1430">El <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicie una excepción <xref:System.NotSupportedException> si la familia de direcciones de la <xref:System.Net.Sockets.Socket> y <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> no son la misma familia de direcciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1430">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1431">Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a este método, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1431">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1432">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1432">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1433">Un argumento no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1433">An argument is not valid.</span>
          </span>
          <span data-ttu-id="d9a09-1434">Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1434">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1435">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1435">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1436">El objeto <see cref="T:System.Net.Sockets.Socket" /> está escuchando o ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1436">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1437">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1437">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1438">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1438">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="d9a09-1439">Esta excepción también se produce si el extremo local y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no son la misma familia de direcciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1439">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1440">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1441">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1441">A caller higher in the call stack does not have permission for the requested operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1442">Obtiene un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> se conecta con un host remoto a partir de la última operación <see cref="Overload:System.Net.Sockets.Socket.Send" /> u <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1442">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1443">Es <see langword="true" /> si el objeto <see cref="T:System.Net.Sockets.Socket" /> estaba conectado a un recurso remoto desde la operación más reciente; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1443">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1444">El `Connected` propiedad obtiene el estado de conexión de la <xref:System.Net.Sockets.Socket> a partir de la última operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1444">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="d9a09-1445">Cuando devuelve `false`, el <xref:System.Net.Sockets.Socket> nunca se conectó o ya no está conectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1445">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="d9a09-1446">El valor de la <xref:System.Net.Sockets.Socket.Connected%2A> propiedad refleja el estado de la conexión a partir de la operación más reciente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1446">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="d9a09-1447">Si necesita determinar el estado actual de la conexión, llamar a un envío de no bloqueo, cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1447">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="d9a09-1448">Si la llamada se devuelve correctamente o produce un código de error WAEWOULDBLOCK (10035), el socket aún está conectado; en caso contrario, el socket ya no está conectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1448">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="d9a09-1449">Si se llama a <xref:System.Net.Sockets.Socket.Connect%2A> en un socket de protocolo de datagramas de usuario (UDP), el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad siempre devuelve `true`; sin embargo, esta acción no cambia la naturaleza sin conexión inherente de UDP.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1449">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1450">El siguiente ejemplo de código se conecta a un punto de conexión remota, comprueba la <xref:System.Net.Sockets.Socket.Connected%2A> propiedad y comprueba el estado actual de la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1450">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="d9a09-1451">
            <see langword="true" /> si se puede reutilizar el socket una vez cerrada la conexión actual; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1451">
              <see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1452">Cierra la conexión del socket y permite reutilizarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1452">Closes the socket connection and allows reuse of the socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1453">Si utiliza un protocolo orientado a conexiones, puede usar este método para cerrar el socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1453">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="d9a09-1454">Este método de extremos la conexión y establece el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad `false`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1454">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="d9a09-1455">Sin embargo, si `reuseSocket` es `true`, se puede reutilizar el socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1455">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="d9a09-1456">Para asegurarse de que todos los datos se envía y recibe antes de cerrar el socket, debe llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a la <xref:System.Net.Sockets.Socket.Disconnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1456">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1457">Si necesita llamar a <xref:System.Net.Sockets.Socket.Disconnect%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opción `false` y especifique un intervalo de tiempo de espera distinto de cero para asegurarse de que los datos en cola de transmisión de salida se envía.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1457">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="d9a09-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> a continuación, se bloquea hasta que los datos se envían o hasta que expire el tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d9a09-1459">Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1459">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1460">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1461">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1461">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1462">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1463">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1464">En el ejemplo de código siguiente se crea un socket para la comunicación sincrónica y se envía algunos datos a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1464">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d9a09-1465">A continuación, llama <xref:System.Net.Sockets.Socket.Shutdown%2A>para detener el envío y recepción de actividad, y <xref:System.Net.Sockets.Socket.Disconnect%2A>para cerrar la conexión de socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1465">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="d9a09-1466">Este método requiere Windows 2000 o anterior, o se iniciará la excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1466">This method requires Windows 2000 or earlier, or the exception will be thrown.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1467">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1468">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1468">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-1469">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1470">Comienza una solicitud asincrónica para la desconexión de un extremo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1471">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1471">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-1472">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-1473">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1473">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-1474">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1475">Cuando se usa un protocolo orientado a conexiones, una llamada a la <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> método solicita una desconexión de un extremo remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="d9a09-1476">Si establece <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> a `true` en el `e` parámetro, se puede reutilizar el socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1477">El parámetro <paramref name="e" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1477">The <paramref name="e" /> parameter cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1478">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1479">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1479">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1480">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1481">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1481">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1482">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1483">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1484">Llame a `Dispose` cuando haya terminado de usar <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1485">El método `Dispose` deja el <xref:System.Net.Sockets.Socket> en un estado no utilizable.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="d9a09-1486">Después de llamar a `Dispose`, debe liberar todas las referencias a la <xref:System.Net.Sockets.Socket> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Net.Sockets.Socket> estaba ocupando.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="d9a09-1487">Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1487">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1488">Realice siempre una llamada a `Dispose` antes de liberar la última referencia al objeto <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1489">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Net.Sockets.Socket> del objeto `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="d9a09-1490">Es <see langword="true" /> para liberar los recursos administrados y no administrados; es <see langword="false" /> para liberar sólo los recursos no administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1490">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1491">Libera los recursos no administrados que usa <see cref="T:System.Net.Sockets.Socket" /> y, de forma opcional, desecha los recursos administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1492">Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="d9a09-1493">`Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="d9a09-1494"><xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="d9a09-1495">Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Net.Sockets.Socket> hace referencia.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="d9a09-1496">Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1497">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1498">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d9a09-1499">
              <see langword="Dispose" /> puede recibir varias llamadas de otros objetos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d9a09-1499">
                <see langword="Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="d9a09-1500">Al invalidar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d9a09-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span>
            </span>
            <span data-ttu-id="d9a09-1501">Para obtener más información sobre cómo implementar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="d9a09-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="d9a09-1502">Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span>
            <span class="sxs-lookup">
              <span data-stu-id="d9a09-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1503">Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> permite fragmentar los datagramas de protocolo Internet (IP).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1504">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite la fragmentación de datagramas; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1504">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-1505">El valor predeterminado es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1505">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1506">Necesario fragmentar los datagramas cuando su tamaño supera la unidad de transmisión máxima (MTU) del medio de transmisión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="d9a09-1507">Pueden fragmentar los datagramas por el host de envío (todas las versiones de protocolo de Internet) o un enrutador intermedio (Protocolo de Internet versión 4 solo).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="d9a09-1508">Si un datagrama debe fragmentarse y el <xref:System.Net.Sockets.Socket.DontFragment%2A> opción está establecida, se descarta el datagrama y se envía un mensaje de error de protocolo de mensajes de Control de Internet (ICMP) al remitente del datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="d9a09-1509">Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1510">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.DontFragment%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1511">Esta propiedad sólo se puede establecer para sockets de las familias de <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1512">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1512">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1513">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1514">Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> es un socket de modo dual que se usa tanto para IPv4 como para IPv6.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1515">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> es un socket de modo dual; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1515">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-1516">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1516">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">
          <span data-ttu-id="d9a09-1517">Identificador del proceso de destino donde se crea un duplicado de la referencia del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1517">The ID of the target process where a duplicate of the socket reference is created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1518">Duplica la referencia del socket para el proceso de destino y cierra el socket para este proceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1519">Referencia del socket que se va a pasar al proceso de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1519">The socket reference to be passed to the target process.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1520">El proceso de destino debe utilizar <xref:System.Net.Sockets.Socket.%23ctor%2A> para crear la instancia de socket duplicado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="d9a09-1521">Si se llama a la <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor varias veces con la misma matriz de bytes que el argumento para cada llamada, creará varios administrados <xref:System.Net.Sockets.Socket> instancias con el mismo socket subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="d9a09-1522">Esta práctica es recomendable.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="d9a09-1523">Si el proceso de crear el socket usa los métodos asincrónicos (<xref:System.Net.Sockets.Socket.BeginReceive%2A> o <xref:System.Net.Sockets.Socket.BeginSend%2A>), primero debe establecer el proceso de la <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propiedad en true; de lo contrario, se enlaza el socket para el puerto de terminación del proceso de creación, lo cual puede provocar un <xref:System.ArgumentNullException> que se produzca en el proceso de destino.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1524">
            <paramref name="targetProcessID" /> no es un identificador de proceso válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1524">
              <paramref name="targetProcessID" /> is not a valid process id.</span>
          </span>
          <span data-ttu-id="d9a09-1525">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1525">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1526">Se produjo un error al duplicar la referencia del socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1526">Duplication of the socket reference failed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1527">Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> puede enviar o recibir paquetes de difusión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1528">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite la difusión de paquetes; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1528">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-1529">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1529">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1530">Difusión se limita a una subred específica y debe usar el protocolo de datagramas de usuario (UDP). Protocolo de Internet versión 4, puede difundir a la subred local enviando un paquete a 255.255.255.255; o bien, puede usar la dirección de difusión dirigida, que es la parte de la red de una dirección de protocolo de Internet (IP) con todos los bits establecidos en la parte del host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="d9a09-1531">Por ejemplo, si su dirección IP es 192.168.1.40 (una dirección de clase C, con una máscara de red de 255.255.255.0, la parte de la red es los tres primeros octetos y la parte del host es el último octeto), es de su dirección de difusión dirigida 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="d9a09-1532">Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1533">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1534">Esta opción sólo es válida para un socket de datagramas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1534">This option is valid for a datagram socket only.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1535">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1536">Acepta de forma asincrónica un intento de conexión entrante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1536">Asynchronously accepts an incoming connection attempt.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-1537">Matriz de tipo <see cref="T:System.Byte" /> que contiene los bytes transferidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1538">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1539">Acepta de forma asincrónica un intento de conexión entrante y crea un objeto <see cref="T:System.Net.Sockets.Socket" /> nuevo para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="d9a09-1540">Este método devuelve un búfer que contiene los datos iniciales transferidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1540">This method returns a buffer that contains the initial data transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1541">Objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d9a09-1543">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1544">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="d9a09-1545">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d9a09-1546">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="d9a09-1547">El `buffer` parámetro de esta sobrecarga contiene los datos que se reciben en la llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A> y `bytesTransferred` parámetro contiene el número de bytes transferidos en la llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="d9a09-1548">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d9a09-1549">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1550">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1551">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1551">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1552">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1553">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1554">El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para crear y conectar un socket y aceptan los 10 bytes iniciales de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="d9a09-1555">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndAccept%2A> para finalizar la solicitud asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d9a09-1556">El número de bytes transmitidos y los datos se devuelven en el `buffer` y `bytesTransferred` parámetros de este método y se muestran en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1557">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1557">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1558">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1559">
            <paramref name="asyncResult" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1559">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1560">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1560">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1561">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1561">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1562">Error al intentar acceder a <see cref="T:System.Net.Sockets.Socket" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1563">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1564">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1565">Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1566">
            <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d9a09-1568">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1569">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="d9a09-1570">Debe aceptar el `asyncResult` parámetro devuelto desde el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1571">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d9a09-1572">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="d9a09-1573">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d9a09-1574">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1575">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1576">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1576">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1577">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1578">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1578">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1579">En el siguiente ejemplo se finaliza una solicitud asincrónica y crea un nuevo <xref:System.Net.Sockets.Socket> para aceptar una solicitud de conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="d9a09-1580">Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1581">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1581">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1582">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1582">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1583">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1583">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1584">Vea la sección Comentarios para obtener más información.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1584">See the Remarks section for more information.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1585">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1586">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1586">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1587">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1587">Windows NT is required for this method.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-1588">Matriz de tipo <see cref="T:System.Byte" /> que contiene los bytes transferidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span>
          </span>
        </param>
        <param name="bytesTransferred">
          <span data-ttu-id="d9a09-1589">Número de bytes transferidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1589">The number of bytes transferred.</span>
          </span>
        </param>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1590">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1591">Acepta de forma asincrónica un intento de conexión entrante y crea un objeto <see cref="T:System.Net.Sockets.Socket" /> nuevo para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span>
          </span>
          <span data-ttu-id="d9a09-1592">Este método devuelve un búfer que contiene los datos iniciales y el número de bytes transferidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1593">Objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d9a09-1595">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1596">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="d9a09-1597">Debe aceptar el `asyncResult` parámetro devuelto desde el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1598">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d9a09-1599">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="d9a09-1600">El `buffer` parámetro de esta sobrecarga contiene los datos que se reciben en la llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A> y `bytesTransferred` parámetro contiene el número de bytes transferidos en la llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="d9a09-1601">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d9a09-1602">El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1603">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1604">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1604">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1605">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1606">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1607">El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para crear y conectar un socket y aceptan los 10 bytes iniciales de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="d9a09-1608">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndAccept%2A> para finalizar la solicitud asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d9a09-1609">El número de bytes transmitidos y los datos se devuelven en el `buffer` y `bytesTransferred` parámetros de este método y se muestran en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1610">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1610">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1611">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1612">
            <paramref name="asyncResult" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1612">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1613">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1613">
              <paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1614">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1614">
              <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1615">Error al intentar obtener acceso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1616">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1617">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1618">Finaliza una solicitud de conexión asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1618">Ends a pending asynchronous connection request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> se inicia un método de bloqueo que se completa la solicitud de conexión asincrónica host remoto en el <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1620">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1621">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginConnect%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="d9a09-1622">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1623">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d9a09-1624">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método para completar correctamente el intento de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1625">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1626">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1626">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1627">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1628">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1628">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1629">El siguiente ejemplo de código finaliza el intento de conexión asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="d9a09-1630">Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1631">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1631">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1632">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1632">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1633">
            <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> fue llamado previamente para la conexión asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1633">
              <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1634">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1634">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1635">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1636">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1637">Finaliza una solicitud de desconexión asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1637">Ends a pending asynchronous disconnect request.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="d9a09-1639">El <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método se bloquea hasta que se complete la desconexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="d9a09-1640">Para obtener información acerca de las operaciones asincrónicas, vea el tema de información general de programación asincrónica en MSDN library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1641">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1642">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1642">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1643">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1644">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1644">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1645">En el ejemplo de código siguiente se crea un socket para la comunicación asincrónica y envía datos a un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d9a09-1646">Cuando los datos se ha enviado, <xref:System.Net.Sockets.Socket.Shutdown%2A> se llama para detener el envío y recepción de actividad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="d9a09-1647">A continuación, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> se llama para iniciar una solicitud de desconexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="d9a09-1648">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndDisconnect%2A> para finalizar la solicitud asincrónica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d9a09-1649">Cuando se completa la solicitud, el <xref:System.Net.Sockets.Socket.Connected%2A> es consultar la propiedad para comprobar si el socket está desconectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1650">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1650">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1651">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1651">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1652">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1652">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1653">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1653">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1654">
            <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> fue llamado previamente para la conexión asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1654">
              <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1655">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1655">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.WebException">
          <span data-ttu-id="d9a09-1656">La petición de desconexión ha agotado su tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1656">The disconnect request has timed out.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1657">Finaliza una lectura asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1657">Ends a pending asynchronous read.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1658">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1659">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1659">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1660">Finaliza una lectura asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1660">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1661">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1661">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1662">El <xref:System.Net.Sockets.Socket.EndReceive%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1662">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1663">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceive%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1663">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1664">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1664">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d9a09-1665">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1665">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1666">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1666">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d9a09-1667">Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1667">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d9a09-1668">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1668">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d9a09-1669">El <xref:System.Net.Sockets.Socket.EndReceive%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1669">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-1670">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceive%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1670">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d9a09-1671">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1671">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d9a09-1672">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1672">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-1673">Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult>y extraiga el búfer que contiene el objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1673">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="d9a09-1674">Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1674">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1675">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1675">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1676">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1676">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1677">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1677">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-1678">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1678">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1679">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1679">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1680">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1680">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1681">En el siguiente ejemplo se finaliza una lectura asincrónica pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1681">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="d9a09-1682">Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1682">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1683">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1683">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1684">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1684">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1685">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> para la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1685">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1686">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1686">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1687">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1688">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1688">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-1689">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1689">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1690">Finaliza una lectura asincrónica pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1690">Ends a pending asynchronous read.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1691">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1691">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1692">El <xref:System.Net.Sockets.Socket.EndReceive%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1692">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1693">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceive%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1693">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1694">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1694">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d9a09-1695">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1695">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1696">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1696">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d9a09-1697">Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1697">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d9a09-1698">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1698">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d9a09-1699">El <xref:System.Net.Sockets.Socket.EndReceive%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1699">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-1700">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceive%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1700">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d9a09-1701">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1701">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d9a09-1702">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1702">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-1703">Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult>y extraiga el búfer que contiene el objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1703">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1704">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1704">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1705">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1705">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1706">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1706">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-1707">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1707">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1708">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1708">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1709">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1709">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1710">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1710">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1711">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1711">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1712">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> para la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1712">
              <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1713">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1713">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1714">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1715">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1716">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1716">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="endPoint">
          <span data-ttu-id="d9a09-1717">
            <see cref="T:System.Net.EndPoint" /> de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1717">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <param name="end_point">
          <span data-ttu-id="d9a09-1718">
            <see cref="T:System.Net.EndPoint" /> de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1718">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1719">Finaliza una lectura asincrónica pendiente desde un extremo específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1719">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1720">Si se realiza correctamente, el número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1720">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="d9a09-1721">Si no se realiza correctamente, devuelve 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1721">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1722">El <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1722">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1723">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1723">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1724">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1724">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="d9a09-1725">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1725">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1726">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1726">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-1727">Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1727">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d9a09-1728">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1728">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d9a09-1729">El <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1729">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-1730">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d9a09-1731">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1731">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-1732">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1732">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="d9a09-1733">Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> objeto y extraiga el búfer que contiene el objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1733">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="d9a09-1734">Para identificar el host de origen, extraiga el <xref:System.Net.EndPoint> y conviértalo a un <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1734">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="d9a09-1735">Use la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para obtener la dirección IP y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para obtener el número de puerto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1735">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1736">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1736">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1737">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1737">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1738">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1739">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1740">El siguiente ejemplo de código finaliza una lectura asincrónica pendiente desde un determinado <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1740">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1741">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1741">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1742">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1742">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1743">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> para la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1743">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1744">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1744">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1745">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1746">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1746">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-1747">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" /> para el paquete recibido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1747">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span>
          </span>
        </param>
        <param name="endPoint">
          <span data-ttu-id="d9a09-1748">
            <see cref="T:System.Net.EndPoint" /> de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1748">The source <see cref="T:System.Net.EndPoint" />.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="d9a09-1749">
            <see cref="T:System.Net.IPAddress" /> e interfaz del paquete recibido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1749">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1750">Finaliza una lectura asincrónica pendiente desde un extremo específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1750">Ends a pending asynchronous read from a specific endpoint.</span>
          </span>
          <span data-ttu-id="d9a09-1751">Este método también desvela más información sobre el paquete que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1751">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1752">Si se realiza correctamente, el número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1752">If successful, the number of bytes received.</span>
          </span>
          <span data-ttu-id="d9a09-1753">Si no se realiza correctamente, devuelve 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1753">If unsuccessful, returns 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1754">Si no se ha completado la operación, este método se bloquea hasta que lo haga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1754">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="d9a09-1755">Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1755">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-1756">Examinar `ipPacketInformation` si necesita saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1756">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1757">
            <paramref name="asyncResult" /> es <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1757">
              <paramref name="asyncResult" /> is <see langword="null" /></span>
          </span>
          <span data-ttu-id="d9a09-1758">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1758">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1759">El valor de <paramref name="endPoint" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1759">
              <paramref name="endPoint" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1760">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1760">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1761">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> para la lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1761">
              <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1762">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1762">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1763">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1763">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1764">Finaliza un envío asincrónico pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1764">Ends a pending asynchronous send.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1765">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1766">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1766">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1767">Finaliza un envío asincrónico pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1767">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1768">Si se realiza con éxito, el número de bytes enviados al objeto <see cref="T:System.Net.Sockets.Socket" />; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1768">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-1770">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1770">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1771">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSend%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1771">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="d9a09-1772">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSend%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1772">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1773">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1773">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1774">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSend%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1774">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d9a09-1775">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1775">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-1776">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envió a algunos de los búferes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1776">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="d9a09-1777">Si el valor devuelto desde <xref:System.Net.Sockets.Socket.EndSend%2A> indica que el búfer no se ha enviado completamente, llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método nuevo, modifique el búfer para almacenar los datos sin enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1777">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="d9a09-1778">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1778">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-1779">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1779">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-1780">La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1780">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1781">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1781">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1782">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1782">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1783">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1783">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-1784">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1784">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1785">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1785">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-1786">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1786">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1787">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1787">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1788">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1788">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1789">En el siguiente ejemplo se finaliza un envío asincrónico pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1789">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1790">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1790">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1791">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1791">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1792">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1792">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1793">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1793">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1794">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1795">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1795">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-1796">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1796">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1797">Finaliza un envío asincrónico pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1797">Ends a pending asynchronous send.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1798">Si se realiza con éxito, el número de bytes enviados al objeto <see cref="T:System.Net.Sockets.Socket" />; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1798">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-1800">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1800">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1801">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSend%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1801">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="d9a09-1802">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSend%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1802">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1803">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1803">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1804">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSend%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1804">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d9a09-1805">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1805">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-1806">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envió a algunos de los búferes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="d9a09-1807">Si el valor devuelto desde <xref:System.Net.Sockets.Socket.EndSend%2A> indica que el búfer no se ha enviado completamente, llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método nuevo, modifique el búfer para almacenar los datos sin enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1807">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="d9a09-1808">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1808">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-1809">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1809">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-1810">La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1810">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1811">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1812">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1812">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1813">Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1813">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d9a09-1814">Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1814">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1815">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-1816">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1817">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1818">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1819">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1819">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1820">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1820">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1821">
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1821">
              <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1822">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1822">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1823">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1823">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1824">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1824">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1825">Finaliza un envío asincrónico de archivo pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1825">Ends a pending asynchronous send of a file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-1827">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1827">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1828">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSendFile%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1828">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="d9a09-1829">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> objeto devuelto por la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1829">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1830">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1830">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1831">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSendFile%2A> método finalice correctamente la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1831">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="d9a09-1832">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloquea hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1832">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="d9a09-1833">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloquea hasta que se envía el archivo completo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="d9a09-1834">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1834">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-1835">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1835">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-1836">La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1836">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1837">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1838">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1838">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1839">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1840">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1841">En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica y comienza a enviar el archivo "text.txt" asincrónicamente al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1841">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="d9a09-1842">Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1842">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-1843">Se requiere Windows NT para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1843">Windows NT is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1844">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1844">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1845">
            <paramref name="asyncResult" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1845">
              <paramref name="asyncResult" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1846">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1846">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1847">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> para el <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1847">
              <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1848">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1848">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1849">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1849">See remarks section below.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="d9a09-1850">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="d9a09-1851">
            <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1851">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1852">Finaliza un envío asincrónico pendiente en una ubicación específica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1852">Ends a pending asynchronous send to a specific location.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1853">Si se realiza con éxito, el número de bytes enviados; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1853">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-1855">Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1855">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d9a09-1856">Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1856">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d9a09-1857">El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1857">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d9a09-1858">Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1858">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1859">Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSendTo%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1859">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d9a09-1860">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1860">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-1861">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloqueará hasta que se envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1861">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d9a09-1862">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1862">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-1863">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1863">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-1864">La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1864">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1865">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1865">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1866">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1866">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1867">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1867">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1868">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1868">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1869">En el siguiente ejemplo se finaliza un envío asincrónico en una ubicación específica.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1869">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-1870">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1870">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-1871">
            <paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1871">
              <paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1872">
            <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1872">
              <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1873">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1873">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1874">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1874">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1875">Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> permite sólo a un proceso el enlace a un puerto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1875">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1876">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite sólo a un socket el enlace a un puerto concreto; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1876">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-1877">El valor predeterminado es <see langword="true" /> para Windows Server 2003 y Windows XP Service Pack 2 y <see langword="false" /> para todas las demás versiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1877">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1878">Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> es `false`, pueden usar varios sockets el <xref:System.Net.Sockets.Socket.Bind%2A> método para enlazar a un puerto concreto; sin embargo, solo uno de los sockets puede realizar operaciones en el tráfico de red enviado al puerto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1878">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="d9a09-1879">Si más de un socket intenta usar el <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> enlazarse a un puerto determinado, a continuación, en la dirección IP específica más controlará el tráfico de red enviado a ese puerto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1879">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="d9a09-1880">Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> es `true`, el primer uso de la <xref:System.Net.Sockets.Socket.Bind%2A> método intenta enlazar a un puerto determinado, independientemente de la dirección de protocolo de Internet (IP), se realizará correctamente; todos los usos de la <xref:System.Net.Sockets.Socket.Bind%2A> método al que intenta enlazar a ese puerto un error hasta que se destruya el socket del enlace original.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1880">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="d9a09-1881">Esta propiedad debe establecerse antes de <xref:System.Net.Sockets.Socket.Bind%2A> llamado; de lo contrario una <xref:System.InvalidOperationException> se iniciará.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1881">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1882">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1882">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1883">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1883">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1884">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1884">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1885">Se ha llamado a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> para este <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1885">
              <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1886">Libera los recursos que usa la clase <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1886">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1887">El <xref:System.Net.Sockets.Socket> clase llamadas del finalizador el <xref:System.Net.Sockets.Socket.Close%2A> método para cerrar el <xref:System.Net.Sockets.Socket> y liberar los recursos asociados con la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1887">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1888">Devuelve el valor de una opción de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1888">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-1889">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1889">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-1890">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1890">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1891">Devuelve el valor de una opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en forma de objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1891">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1892">Objeto que representa el valor de una opción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1892">An object that represents the value of the option.</span>
          </span>
          <span data-ttu-id="d9a09-1893">Cuando se establece el parámetro <paramref name="optionName" /> en <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, el valor devuelto es una instancia de la clase <see cref="T:System.Net.Sockets.LingerOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1893">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span>
          </span>
          <span data-ttu-id="d9a09-1894">Cuando se establece el parámetro <paramref name="optionName" /> en <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> o <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, el valor devuelto es una instancia de la clase <see cref="T:System.Net.Sockets.MulticastOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1894">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span>
          </span>
          <span data-ttu-id="d9a09-1895">Cuando <paramref name="optionName" /> está establecido en cualquier otro valor, el valor de devolución es un entero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1895">When <paramref name="optionName" /> is any other value, the return value is an integer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1896"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1896"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1897">Utilice esta sobrecarga para obtener el <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, y <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1897">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="d9a09-1898">Para el <xref:System.Net.Sockets.SocketOptionName.Linger> opción, utilice <xref:System.Net.Sockets.Socket> para el `optionLevel` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1898">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d9a09-1899">Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> y <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilice <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1899">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="d9a09-1900">Si desea establecer el valor de cualquiera de las opciones enumeradas anteriormente, use el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1900">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1901">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1901">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1902">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1902">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1903">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1903">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1904">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1904">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1905">El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1905">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1906">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1906">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1907">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1907">-or-</span>
          </span>
          <span data-ttu-id="d9a09-1908">
            <paramref name="optionName" /> se estableció en el valor <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />, que no es compatible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1908">
              <paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1909">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1909">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-1910">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1910">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-1911">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1911">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="d9a09-1912">Matriz de tipo <see cref="T:System.Byte" /> que va a recibir el valor de la opción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1912">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1913">Devuelve el valor de la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada, representado como una matriz de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1913">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1914"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1914"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-1915">Tras la finalización correcta de este método, la matriz especificada por el `optionValue` parámetro contiene el valor del elemento especificado <xref:System.Net.Sockets.Socket> opción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1915">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="d9a09-1916">Cuando la longitud de la `optionValue` matriz es menor que el número de bytes necesarios para almacenar el valor del elemento especificado <xref:System.Net.Sockets.Socket> opción, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1916">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1917">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1918">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1918">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-1919">Utilice esta sobrecarga para cualquiera de los sockets que está representada por valores booleanos o enteros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1919">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1920">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1920">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1921">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1921">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1922">El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1922">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1923">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1923">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1924">\- o -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1924">\- or -</span>
          </span>
          <span data-ttu-id="d9a09-1925">En aplicaciones de .NET Compact Framework, el espacio en búfer predeterminado de Windows CE está establecido en 32768 bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1925">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="d9a09-1926">El espacio en búfer por cada socket puede modificarse mediante una llamada a <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1926">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1927">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1927">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-1928">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1928">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-1929">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1929">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionLength">
          <span data-ttu-id="d9a09-1930">Longitud, en bytes, del valor devuelto previsto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1930">The length, in bytes, of the expected return value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1931">Devuelve el valor de la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1931">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1932">Matriz de tipo <see cref="T:System.Byte" /> que contiene el valor de la opción de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1932">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1933">El `optionLength` parámetro establece el tamaño máximo de la matriz de bytes devuelta.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1933">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="d9a09-1934">Si el valor de opción requiere menos bytes, la matriz contendrá solo que número de bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1934">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="d9a09-1935">Si el valor de opción requiere más bytes <xref:System.Net.Sockets.Socket.GetSocketOption%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1935">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-1936">Utilice esta sobrecarga para cualquiera de los sockets que está representada por valores booleanos o enteros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1936">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1937">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1937">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1938">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1938">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1939">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1939">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1940">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1940">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1941">El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1941">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1942">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1942">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-1943">\- o -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1943">\- or -</span>
          </span>
          <span data-ttu-id="d9a09-1944">En aplicaciones de .NET Compact Framework, el espacio en búfer predeterminado de Windows CE está establecido en 32768 bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1944">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span>
          </span>
          <span data-ttu-id="d9a09-1945">El espacio en búfer por cada socket puede modificarse mediante una llamada a <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1945">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1946">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1946">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1947">Obtiene el identificador del sistema operativo de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1947">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1948">
            <see cref="T:System.IntPtr" /> que representa el identificador del sistema operativo de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1948">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1949">Establece modos operativos de bajo nivel para <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1949">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="d9a09-1950">Valor de <see cref="T:System.Int32" /> que especifica el código de control de la operación que se ha de realizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1950">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="d9a09-1951">Matriz <see cref="T:System.Byte" /> que contiene los datos de entrada requeridos por la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1951">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="d9a09-1952">Matriz <see cref="T:System.Byte" /> que contiene los datos de salida devueltos por la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1952">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1953">Establece modos operativos de bajo nivel para el <see cref="T:System.Net.Sockets.Socket" /> que utiliza códigos de control numéricos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1953">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1954">Número de bytes del parámetro <paramref name="optionOutValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1954">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1955">El <xref:System.Net.Sockets.Socket.IOControl%2A> método proporciona acceso al sistema operativo de bajo nivel <xref:System.Net.Sockets.Socket> subyacente de la instancia actual de la <xref:System.Net.Sockets.Socket> clase.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1955">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="d9a09-1956">Para obtener más información, consulte la documentación de WSAIoctl en MSDN library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1956">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1957">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1957">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1958">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1958">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1959">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1959">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1960">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1960">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1961">En el ejemplo de código siguiente se compara los resultados de FIONREAD y la propiedad disponible.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1961">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1962">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1962">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1963">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1963">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1964">Se intentó modificar el modo de bloqueo sin utilizar la propiedad <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1964">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-1965">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1965">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="d9a09-1966">Para ejecutar código no administrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1966">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="d9a09-1967">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1967">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <span data-ttu-id="d9a09-1968">Valor de <see cref="T:System.Net.Sockets.IOControlCode" /> que especifica el código de control de la operación que se ha de realizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1968">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span>
          </span>
        </param>
        <param name="optionInValue">
          <span data-ttu-id="d9a09-1969">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos de entrada requeridos por la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1969">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span>
          </span>
        </param>
        <param name="optionOutValue">
          <span data-ttu-id="d9a09-1970">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos de salida requeridos por la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1970">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-1971">Establece modos operativos de bajo nivel para el <see cref="T:System.Net.Sockets.Socket" /> que utiliza la enumeración <see cref="T:System.Net.Sockets.IOControlCode" /> para especificar códigos de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1971">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-1972">Número de bytes del parámetro <paramref name="optionOutValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1972">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1973">Este método proporciona acceso al sistema operativo de bajo nivel <xref:System.Net.Sockets.Socket> subyacente de la instancia actual de la <xref:System.Net.Sockets.Socket> clase.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1973">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="d9a09-1974">Para obtener más información, consulte la documentación de WSAIoctl en MSDN library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1974">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1975">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1975">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-1976">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1976">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-1977">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-1978">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-1978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1979">En el ejemplo de código siguiente se compara los resultados de llamar a <xref:System.Net.Sockets.Socket.IOControl%2A> con <xref:System.Net.Sockets.IOControlCode.DataToRead> y <xref:System.Net.Sockets.Socket.Available%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1979">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-1980">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1980">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-1981">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1981">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-1982">Se intentó modificar el modo de bloqueo sin utilizar la propiedad <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1982">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="d9a09-1983">Para ejecutar código no administrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1983">to execute unmanaged code.</span>
          </span>
          <span data-ttu-id="d9a09-1984">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1984">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1985">Obtiene un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> se enlaza a un puerto local concreto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1985">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1986">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> se enlaza a un puerto local; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1986">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1987">Un socket se considera que está enlazado a un puerto local si está enlazada explícitamente mediante una llamada a la <xref:System.Net.Sockets.Socket.Bind%2A> método, o implícitamente enlazado llamando a los miembros como <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, que usan un puerto local efímero (un puerto libre mayor que 1024, seleccionado por el sistema operativo.) Los servidores usan la <xref:System.Net.Sockets.Socket.Bind%2A> método para enlazar a un puerto conocido para que los clientes pueden conectarse a ellos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1987">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-1988">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.IsBound%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1988">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-1989">Obtiene o establece un valor que especifica si <see cref="T:System.Net.Sockets.Socket" /> retrasará el cierre de un socket en un intento de envío de todos los datos pendientes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1989">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-1990">
            <see cref="T:System.Net.Sockets.LingerOption" /> que especifica cómo aplicar un retraso mientras se cierra un socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-1990">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-1991">El <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad cambia la manera <xref:System.Net.Sockets.Socket.Close%2A> método se comporta.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1991">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="d9a09-1992">Esta propiedad cuando set modifica las condiciones en las que se puede restablecer la conexión mediante Winsock.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1992">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="d9a09-1993">Restablecimientos de conexión pueden seguir apareciendo según el comportamiento del protocolo IP.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1993">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="d9a09-1994">Esta propiedad controla el período de tiempo que una conexión orientado a la conexión permanecerá abierta después de llamar a <xref:System.Net.Sockets.Socket.Close%2A> cuando quedan enviarán datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1994">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="d9a09-1995">Al llamar a métodos para enviar datos a un elemento del mismo nivel, estos datos se colocan en el búfer de red saliente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1995">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="d9a09-1996">Esta propiedad se puede utilizar para asegurarse de que estos datos se envían al host remoto antes de la <xref:System.Net.Sockets.TcpClient.Close%2A> método interrumpe la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1996">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="d9a09-1997">Para habilitar la permanencia de la conexión, cree un <xref:System.Net.Sockets.LingerOption> de instancia que contiene los valores deseados y establezca el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad a esta instancia.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1997">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="d9a09-1998">En la tabla siguiente se describe el comportamiento de la <xref:System.Net.Sockets.Socket.Close%2A> método para los valores posibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propiedad y el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-1998">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="d9a09-1999">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="d9a09-1999">LingerState.Enabled</span></span>|<span data-ttu-id="d9a09-2000">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="d9a09-2000">LingerState.LingerTime</span></span>|<span data-ttu-id="d9a09-2001">Comportamiento</span><span class="sxs-lookup"><span data-stu-id="d9a09-2001">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="d9a09-2002">`false` (deshabilitado), el valor predeterminado</span><span class="sxs-lookup"><span data-stu-id="d9a09-2002">`false` (disabled), the default value</span></span>|<span data-ttu-id="d9a09-2003">No es aplicable, el tiempo de espera (valor predeterminado).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2003">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="d9a09-2004">Intenta enviar los datos pendientes hasta que expire el tiempo de espera de protocolo IP de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2004">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="d9a09-2005">`true` (habilitado)</span><span class="sxs-lookup"><span data-stu-id="d9a09-2005">`true` (enabled)</span></span>|<span data-ttu-id="d9a09-2006">Un tiempo de espera distinto de cero</span><span class="sxs-lookup"><span data-stu-id="d9a09-2006">A nonzero time-out</span></span>|<span data-ttu-id="d9a09-2007">Intenta enviar los datos pendientes hasta que expira el tiempo de espera especificado y, si se produce un error en el intento, Winsock restablece la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2007">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="d9a09-2008">`true` (habilitado)</span><span class="sxs-lookup"><span data-stu-id="d9a09-2008">`true` (enabled)</span></span>|<span data-ttu-id="d9a09-2009">Un cero tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2009">A zero timeout.</span></span>|<span data-ttu-id="d9a09-2010">Descarta cualquier dato pendiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2010">Discards any pending data.</span></span> <span data-ttu-id="d9a09-2011">Para el socket orientado a conexión (por ejemplo, TCP), Winsock restablece la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2011">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="d9a09-2012">La pila IP calcula el tiempo de espera de protocolo IP predeterminado a utilizar basándose en el tiempo de ida y vuelta de la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2012">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="d9a09-2013">En la mayoría de los casos, el tiempo de espera calculado por la pila es más relevante que definidos por una aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2013">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="d9a09-2014">Este es el comportamiento predeterminado para un socket cuando la <xref:System.Net.Sockets.Socket.LingerState%2A> no se establece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2014">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="d9a09-2015">Cuando el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad está establecida en mayor que el tiempo de espera de protocolo IP de forma predeterminada, el tiempo de espera de protocolo IP de forma predeterminada se todavía se aplican y reemplazan.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2015">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2016">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2016">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2017">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2017">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2018">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2018">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">
          <span data-ttu-id="d9a09-2019">Longitud máxima de la cola de conexiones pendientes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2019">The maximum length of the pending connections queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2020">Coloca un objeto <see cref="T:System.Net.Sockets.Socket" /> en un estado de escucha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2020">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2021"><xref:System.Net.Sockets.Socket.Listen%2A> hace que un orientado a conexión <xref:System.Net.Sockets.Socket> para realizar escuchas para los intentos de conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2021"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="d9a09-2022">El `backlog` parámetro especifica el número de conexiones entrantes que pueden poner en cola para que los acepte.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2022">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="d9a09-2023">Para determinar el número máximo de conexiones que puede especificar, recuperar el <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valor.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2023">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="d9a09-2024"><xref:System.Net.Sockets.Socket.Listen%2A> no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2024"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="d9a09-2025">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2025">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2026">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2026">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="d9a09-2027">Use <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> para aceptar una conexión de la cola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2027">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2028">Debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.Listen%2A>, o <xref:System.Net.Sockets.Socket.Listen%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2028">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2029">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2029">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2030">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2030">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2031">El parámetro de trabajo pendiente se limita a valores diferentes dependiendo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2031">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="d9a09-2032">Puede especificar un valor mayor, pero el trabajo pendiente estará limitado en función del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2032">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2033">El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket> para escuchar las conexiones entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2033">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2034">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2034">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2035">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2035">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2036">Obtiene el extremo local.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2036">Gets the local endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2037">
            <see cref="T:System.Net.EndPoint" /> que utiliza el <see cref="T:System.Net.Sockets.Socket" /> para las comunicaciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2037">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2038">El <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> procedimientos property get un <xref:System.Net.EndPoint> que contiene el número de puerto y dirección IP local a la que su <xref:System.Net.Sockets.Socket> está enlazado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2038">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="d9a09-2039">Debe convertir esta <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> antes de recuperar toda la información.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2039">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="d9a09-2040">A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar la variable local <xref:System.Net.IPAddress>y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar el número de puerto local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2040">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="d9a09-2041">El <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad normalmente se establece después de realizar una llamada a la <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2041">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-2042">Si permite que el sistema asignar la dirección IP local del socket y el número de puerto, el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> se establecerá la propiedad después de la primera operación de E/S.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2042">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="d9a09-2043">Para protocolos orientados a conexiones, la primera operación de E/S sería una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2043">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2044">Para los protocolos sin conexión, la primera operación de E/S podría ser cualquiera de envío o recibir llamadas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2044">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2045">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2045">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2046">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2046">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2047">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2047">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2048">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2048">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2049">En el ejemplo de código siguiente se recupera y muestra los puntos de conexión locales y remotas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2049">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2050">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2050">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2051">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2051">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2052">Obtiene o establece un valor que especifica si se entregan paquetes de multidifusión saliente a la aplicación emisora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2052">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2053">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> recibe paquetes de multidifusión saliente; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2053">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2054">Multidifusión es un método escalable para la comunicación de varios a varios en Internet.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2054">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="d9a09-2055">Un proceso se suscribe a una dirección de multidifusión; a continuación, todos los paquetes enviados por un proceso suscrito son recibidos por todos los procesos suscrito a la dirección de multidifusión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2055">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="d9a09-2056">Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2056">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2057">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2057">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2058">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2058">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2059">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2059">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2060">Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si la secuencia <see cref="T:System.Net.Sockets.Socket" /> está utilizando el algoritmo de Nagle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2060">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2061">
            <see langword="false" /> si <see cref="T:System.Net.Sockets.Socket" /> utiliza el algoritmo de Nagle; de lo contrario, <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2061">
              <see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span>
          </span>
          <span data-ttu-id="d9a09-2062">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2062">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2063">El algoritmo de Nagle está diseñado para reducir el tráfico de red haciendo que el socket almacenar en búfer paquetes pequeños y, a continuación, combinar y enviarlos en un paquete en determinadas circunstancias.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2063">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="d9a09-2064">Un paquete TCP se compone de 40 bytes de encabezado y los datos que se envían.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2064">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="d9a09-2065">Cuando se envían paquetes pequeños de datos con TCP, la sobrecarga resultante del encabezado TCP puede convertirse en una parte significativa del tráfico de red. En redes con mucha cargadas, la congestión resultantes de esta sobrecarga puede producir pérdida de datagramas y retransmisiones, así como tiempo excesivo de propagación causados por la congestión de la.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2065">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="d9a09-2066">El algoritmo de Nagle inhibe el envío de nuevos segmentswhen TCP nuevos datos de salida llegan al usuario si los datos previouslytransmitted en la conexión permanecen sin confirmación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2066">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="d9a09-2067">La mayoría de las aplicaciones de red debe usar el algoritmo de Nagle.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2067">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="d9a09-2068">Establecer esta propiedad en un socket de protocolo de datagramas de usuario (UDP) no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2068">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2069">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.NoDelay%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2069">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2070">Error al intentar obtener acceso a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2070">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2071">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2071">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2072">Indica si el sistema operativo subyacente y los adaptadores de red admiten la versión 4 del protocolo de Internet (IPv4).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2072">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2073">Es <see langword="true" /> si el sistema operativo y los adaptadores de red admiten el protocolo IPv4; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2073">
              <see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2074">El sistema operativo puede admitir los protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2074">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2075">Indica si el sistema operativo subyacente y los adaptadores de red admiten la versión 6 del protocolo Internet (IPv6).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2075">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2076">
            <see langword="true" /> si el sistema operativo y los adaptadores de red admiten el protocolo IPv6; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2076">
              <see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2077">El sistema operativo puede admitir los protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2077">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">
          <span data-ttu-id="d9a09-2078">Tiempo que se va a esperar una respuesta, en microsegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2078">The time to wait for a response, in microseconds.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="d9a09-2079">Uno de los valores de <see cref="T:System.Net.Sockets.SelectMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2079">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2080">Determina el estado de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2080">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2081">Estado del objeto <see cref="T:System.Net.Sockets.Socket" /> según el valor del modo de sondeo que se pase en el parámetro <paramref name="mode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2081">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span>
          </span>
          <list type="table">
            <listheader>
              <term>
                <span data-ttu-id="d9a09-2082">Modo</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2082">Mode</span>
                </span>
              </term>
              <description>
                <span data-ttu-id="d9a09-2083">Valor devuelto</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2083">Return Value</span>
                </span>
              </description>
            </listheader>
            <item>
              <term>
                <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />
              </term>
              <description>
                <span data-ttu-id="d9a09-2084">Es <see langword="true" /> si se ha llamado a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> y hay una conexión pendiente;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2084">
                    <see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span>
                </span>
                <span data-ttu-id="d9a09-2085">O bien</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2085">-or-</span>
                </span>
                <span data-ttu-id="d9a09-2086">Es <see langword="true" /> si hay datos disponibles para su lectura;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2086">
                    <see langword="true" /> if data is available for reading;</span>
                </span>
                <span data-ttu-id="d9a09-2087">O bien</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2087">-or-</span>
                </span>
                <span data-ttu-id="d9a09-2088">Es <see langword="true" /> si se cerró, restableció o terminó la conexión;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2088">
                    <see langword="true" /> if the connection has been closed, reset, or terminated;</span>
                </span>
                <span data-ttu-id="d9a09-2089">de lo contrario, devolverá <see langword="false" />.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2089">otherwise, returns <see langword="false" />.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />
              </term>
              <description>
                <span data-ttu-id="d9a09-2090">Es <see langword="true" /> si se procesa un método <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> y la conexión se ha realizado correctamente;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2090">
                    <see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span>
                </span>
                <span data-ttu-id="d9a09-2091">O bien</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2091">-or-</span>
                </span>
                <span data-ttu-id="d9a09-2092">Es <see langword="true" /> si se pueden enviar datos;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2092">
                    <see langword="true" /> if data can be sent;</span>
                </span>
                <span data-ttu-id="d9a09-2093">de lo contrario, devolverá <see langword="false" />.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2093">otherwise, returns <see langword="false" />.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see cref="F:System.Net.Sockets.SelectMode.SelectError" />
              </term>
              <description>
                <span data-ttu-id="d9a09-2094">Es <see langword="true" /> si se procesa un método <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> que no se bloquea y la conexión no se ha realizado correctamente;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2094">
                    <see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span>
                </span>
                <span data-ttu-id="d9a09-2095">O bien</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2095">-or-</span>
                </span>
                <span data-ttu-id="d9a09-2096">Es <see langword="true" /> si no se ha establecido <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> y hay datos fuera de banda disponibles;</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2096">
                    <see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span>
                </span>
                <span data-ttu-id="d9a09-2097">de lo contrario, devolverá <see langword="false" />.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="d9a09-2097">otherwise, returns <see langword="false" />.</span>
                </span>
              </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2098">El <xref:System.Net.Sockets.Socket.Poll%2A> método comprobará el estado de la <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2098">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-2099">Especificar <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> para el `selectMode` parámetro para determinar si la <xref:System.Net.Sockets.Socket> es legible.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2099">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="d9a09-2100">Especificar <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> para determinar si la <xref:System.Net.Sockets.Socket> es grabable.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2100">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="d9a09-2101">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> para detectar una condición de error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2101">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="d9a09-2102"><xref:System.Net.Sockets.Socket.Poll%2A> bloqueará la ejecución hasta que el período de tiempo especificado, expresada en `microseconds`, transcurre.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2102"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="d9a09-2103">Establecer el `microSeconds` parámetro en un entero negativo si desea esperar una respuesta de forma indefinida.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2103">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="d9a09-2104">Si desea comprobar el estado de varios sockets, es preferible usar el <xref:System.Net.Sockets.Socket.Select%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2104">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2105">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2105">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2106">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2106">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2107">Este método no puede detectar ciertos tipos de problemas de conexión, como un cable de red rota, o que el host remoto cierre brusco.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2107">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="d9a09-2108">Debe intentar enviar o recibir datos para detectar estos tipos de errores.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2108">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2109">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2109">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2110">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2110">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2111">En el ejemplo de código siguiente se crea un socket, se conecta a un servidor y utiliza <xref:System.Net.Sockets.Socket.Poll%2A> para comprobar el estado del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2111">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-2112">El parámetro <paramref name="mode" /> no es un valor de <see cref="T:System.Net.Sockets.SelectMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2112">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2113">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2113">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-2114">Vea los comentarios más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2114">See remarks below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2115">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2115">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2116">Obtiene el tipo de protocolo de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2116">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2117">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2117">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2118">El <xref:System.Net.Sockets.Socket.ProtocolType%2A> propiedad se establece cuando el <xref:System.Net.Sockets.Socket> se crea y especifica el protocolo utilizado por esa <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2118">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2119">El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2119">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2120">Recibe datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2120">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2121">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2121">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2122">Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2122">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2123">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2123">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2124">El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2124">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2125">Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2125">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2126">Esta sobrecarga sólo requiere proporcionar un búfer de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2126">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="d9a09-2127">El desplazamiento de búfer predeterminado es 0, el tamaño predeterminado es la longitud del parámetro de búfer y el <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2127">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d9a09-2128">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2128">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2129">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2129">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2130">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2130">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2131"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2131"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2132">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2132">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2133">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2133">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2134">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2134">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2135">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2135">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2136">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2136">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2137">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2137">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2138">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2138">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2139">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2139">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2140">Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2140">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2141">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2141">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2142">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2142">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2143">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2143">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2144">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2144">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2145">El ejemplo de código siguiente recibe los datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2145">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2146">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2146">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2147">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2147">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2148">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2148">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2149">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2149">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2150">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2150">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2151">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2151">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2152">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2152">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2153">Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2153">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2154">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2154">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2155">Este método lee los datos en el parámetro de búferes y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2155">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2156">Puede llamar en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2156">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2157">Esta sobrecarga requiere que proporcione uno o varios búferes de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2157">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="d9a09-2158">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2158">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2159">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2159">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2160">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2160">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2161"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2161"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2162">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2162">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2163">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2163">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2164">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2164">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2165">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2165">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2166">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2166">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2167">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2167">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2168">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2168">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2169">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2169">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2170">Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2170">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2171">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2171">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2172">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2172">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d9a09-2173">**Tenga en cuenta** este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2173">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2174">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2174">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2175">El parámetro <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2175">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2176">Se ha producido un error al intentar obtener acceso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2176">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2177">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2177">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2178">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2178">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2179">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2179">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2180">Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2180">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2181">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2181">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2182">El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2182">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2183">Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2183">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2184">Esta sobrecarga sólo requiere que proporcione un búfer de recepción y el necesario <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2184">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d9a09-2185">El desplazamiento de búfer predeterminado es 0 y el tamaño predeterminado es la longitud del parámetro de bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2185">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="d9a09-2186">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2186">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2187">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2187">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2188">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2188">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2189"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2189"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2190">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2190">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-2191">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2191">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2192">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2192">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2193">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2193">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2194">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá tantos datos como está disponible hasta el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2194">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2195">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2195">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2196">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2196">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2197">Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2197">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2198">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2198">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2199">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2199">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2200">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2200">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2201">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2201">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2202">En el ejemplo de código siguiente se especifica un búfer de datos, y <xref:System.Net.Sockets.SocketFlags> para recibir los datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2202">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2203">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2203">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2204">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2204">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2205">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2205">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2206">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2206">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2207">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2207">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2208">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2208">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2209">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2209">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2210">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2210">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2211">Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado, utilizando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2211">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2212">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2212">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2213">Este método lee los datos en el `buffers` parámetro y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2213">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2214">Puede llamar en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2214">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2215">Esta sobrecarga requiere que proporcione uno o varios búferes de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2215">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="d9a09-2216">El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2216">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d9a09-2217">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2217">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2218">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2218">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2219">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2219">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2220"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2220"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2221">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2221">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2222">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamar a produce un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2222">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2223">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2223">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2224">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2224">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2225">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2225">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2226">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2226">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2227">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2227">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2228">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2228">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2229">Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2229">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2230">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2230">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2231">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2231">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2232">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2232">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2233">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2233">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2234">En el ejemplo de código siguiente se muestra cómo recibir datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2234">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2235">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2235">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2236">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2236">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2237">
            <paramref name="buffers" />.Count es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2237">
              <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2238">Se ha producido un error al intentar obtener acceso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2238">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2239">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2239">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2240">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2240">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2241">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2241">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2242">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2242">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2243">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2243">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2244">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2244">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2245">Recibe el número especificado de bytes de datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2245">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2246">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2246">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2247">El <xref:System.Net.Sockets.Socket.Receive%2A> método lee datos en el `buffer` parámetro y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2247">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2248">Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2248">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2249">Esta sobrecarga sólo requiere que se proporcione un búfer de recepción, el número de bytes que desea recibir y el necesario <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2249">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="d9a09-2250">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2250">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2251">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2251">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2252">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2252">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2253"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2253"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2254">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2254">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2255">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2255">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2256">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2256">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2257">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2257">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2258">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2258">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2259">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el `size` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2259">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d9a09-2260">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2260">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2261">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2261">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2262">Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2262">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2263">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2263">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2264">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2264">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2265">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2265">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2266">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2266">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2267">La siguiente recibe los datos se encuentran en `buffer`y especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2267">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2268">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2268">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2269">
            <paramref name="size" /> sobrepasa el tamaño de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2269">
              <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2270">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2270">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2271">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2271">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2272">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2272">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2273">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2273">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2274">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2274">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2275">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2275">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2276">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2276">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-2277">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2277">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2278">Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado, utilizando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2278">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2279">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2279">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2280">Este método lee los datos en el `buffers` parámetro y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2280">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2281">Puede llamar en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2281">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2282">Esta sobrecarga requiere que proporcione uno o varios búferes de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2282">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="d9a09-2283">El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2283">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d9a09-2284">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2284">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2285">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2285">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2286">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2286">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2288">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2288">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2289">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamar a produce un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2289">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2290">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2290">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2291">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2291">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2292">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2292">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2293">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2293">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2294">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2294">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2295">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2295">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2296">Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2296">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2297">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2297">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2298">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2298">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2299">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2299">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2300">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2300">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2301">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2301">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2302">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2302">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2303">
            <paramref name="buffers" />.Count es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2303">
              <paramref name="buffers" />.Count is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2304">Se ha producido un error al intentar obtener acceso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2304">An error occurred while attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2305">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2305">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2306">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2306">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2307">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2307">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2308">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2308">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-2309">Ubicación de <paramref name="buffer" /> en la que se almacenarán los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2309">The location in <paramref name="buffer" /> to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2310">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2310">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2311">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2311">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2312">Recibe el número especificado de bytes de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado en la posición de desplazamiento especificada del búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2312">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2313">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2313">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2314">El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2314">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2315">Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2315">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2316">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2316">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2317">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2317">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2318">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2318">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2319"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2319"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2320">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2320">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2321">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2321">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2322">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2322">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2323">Error al intentar acceder al socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2323">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d9a09-2324">Consulte la sección Comentarios más adelante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2324">See Remarks below.</span></span> <span data-ttu-id="d9a09-2325">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2325">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2326">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2326">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2327">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el parámetro de tamaño.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2327">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="d9a09-2328">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2328">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2329">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2329">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2330">Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2330">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2331">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2331">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2332">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2332">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2333">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2333">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2334">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2334">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2335">En el ejemplo de código siguiente se especifica un búfer de datos, un desplazamiento, un tamaño y un indicador de socket antes de recibir datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2335">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2336">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2336">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2337">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2337">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2338">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2338">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2339">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2339">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-2340">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2340">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2341">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2341">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2342">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2342">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2343">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2343">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2344">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2344">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2345">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2345">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2346">La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2346">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="d9a09-2347">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2347">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2348">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2348">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2349">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2349">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2350">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2350">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2351">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2351">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2352">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2352">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2353">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2353">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-2354">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2354">The position in the <paramref name="buffer" /> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2355">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2355">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2356">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2356">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-2357">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2357">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2358">Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2358">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2359">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2359">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2360">El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2360">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d9a09-2361">Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2361">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d9a09-2362">Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2362">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d9a09-2363">El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2363">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2364">Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2364">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2365"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2365"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d9a09-2366">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2366">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2367">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2367">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2368">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2368">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2369">Error al intentar acceder al socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2369">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d9a09-2370">Consulte la sección Comentarios más adelante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2370">See Remarks below.</span></span> <span data-ttu-id="d9a09-2371">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2371">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2372">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2372">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2373">Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el parámetro de tamaño.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2373">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="d9a09-2374">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2374">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d9a09-2375">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2375">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d9a09-2376">Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2376">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2377">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2377">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2378">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2378">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2379">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2379">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2380">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2380">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2381">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2381">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2382">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2382">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2383">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2383">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2384">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2384">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-2385">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2385">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2386">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2386">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2387">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2387">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2388">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2388">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2389">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2389">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2390">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2390">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2391">La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se ha establecido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2391">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span>
          </span>
          <span data-ttu-id="d9a09-2392">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2392">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2393">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2393">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2394">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2394">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2395">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2395">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2396">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2396">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2397">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2397">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-2398">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2398">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2399">Comienza una solicitud asincrónica para recibir los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2399">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2400">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2400">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-2401">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2401">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-2402">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2402">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-2403">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2403">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2404">El <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método se usa en sockets conectados o sockets enlazados sin conexión y se usa para leer los datos entrantes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2404">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="d9a09-2405">Debe conocer la dirección local del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2405">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="d9a09-2406">Para los sockets enlazados sin conexión, esta función restringe las direcciones desde el que se aceptan los mensajes recibidos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2406">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="d9a09-2407">La función devuelve solo los mensajes de la dirección remota especificada en la conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2407">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="d9a09-2408">Los mensajes de otras direcciones se descartan.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2408">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="d9a09-2409">El <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la solicitud de lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2409">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="d9a09-2410">Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2410">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d9a09-2411">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-2411">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="d9a09-2412"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d9a09-2412"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="d9a09-2413"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido</span><span class="sxs-lookup"><span data-stu-id="d9a09-2413"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="d9a09-2414"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido</span><span class="sxs-lookup"><span data-stu-id="d9a09-2414"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-2415">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2415">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-2416">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2416">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-2417">Para los sockets de estilo de la secuencia de bytes, los datos entrantes se colocan en el búfer hasta que el búfer se llena, la conexión está cerrada o se agotan los datos almacenados en búfer internamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2417">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="d9a09-2418">Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer asociado con el `e` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2418">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="d9a09-2419">Si el mensaje es mayor que el búfer, el búfer se rellena con la primera parte del mensaje.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2419">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="d9a09-2420">Para los sockets orientados a conexiones, el <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método puede indicar la finalización correcta del circuito virtual en uno de dos maneras en que dependen de si el socket está orientado a mensajes o secuencia de bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2420">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="d9a09-2421">Para las secuencias de bytes, de cero bytes leídos indica el cierre correcto y que nunca se leerá ningún byte más.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2421">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="d9a09-2422">Para los sockets orientados a mensajes, donde un mensaje de cero bytes a menudo es permitido, un <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> establecido en el código de error nativo de Winsock WSAEDISCON (10101) se utiliza para indicar el cierre correcto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2422">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="d9a09-2423">En cualquier caso, un <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> se establece en el nativo Winsock WSAECONNRESET (10054) del código de error indica se ha producido un cierre firme.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2423">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-2424">Un argumento no era válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2424">An argument was invalid.</span>
          </span>
          <span data-ttu-id="d9a09-2425">Las propiedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> del parámetro <paramref name="e" /> deben hacer referencia a los búferes válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2425">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="d9a09-2426">Se puede establecer una de estas propiedades, pero no ambas al mismo tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2426">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-2427">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2427">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-2428">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2428">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2429">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2430">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2430">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2431">Obtiene o establece un valor que especifica el tamaño del búfer de recepción de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2431">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2432">
            <see cref="T:System.Int32" /> que contiene el tamaño, en bytes, del búfer de recepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2432">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span>
          </span>
          <span data-ttu-id="d9a09-2433">El valor predeterminado es 8192.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2433">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2434">Potencialmente, un tamaño de búfer mayor reduce el número de confirmaciones vacías (paquetes TCP sin parte de datos), pero también pueden producir retrasos en el reconocimiento de las dificultades de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2434">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="d9a09-2435">Considere la posibilidad de aumentar el tamaño del búfer si va a transferir archivos grandes o usa un ancho de banda alto, la conexión de latencia alta (por ejemplo, un proveedor por satélite banda ancha.)</span><span class="sxs-lookup"><span data-stu-id="d9a09-2435">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2436">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2436">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2437">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2437">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2438">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2438">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2439">El valor especificado para una operación de establecimiento es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2439">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2440">Recibe un datagrama y almacena el extremo de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2440">Receives a datagram and stores the source endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2441">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2441">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-2442">
            <see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2442">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2443">Recibe un datagrama en el búfer de datos y almacena el extremo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2443">Receives a datagram into the data buffer and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2444">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2444">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2445">El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2445">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d9a09-2446">Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2446">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d9a09-2447">Esta sobrecarga sólo requiere que proporcione una instrucción receive `buffer`y un <xref:System.Net.EndPoint> que representa el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2447">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d9a09-2448">El desplazamiento de búfer predeterminado es 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2448">The buffer offset defaults to 0.</span></span> <span data-ttu-id="d9a09-2449">El tamaño predeterminado es la longitud de la `buffer` parámetro y el `socketFlags` como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2449">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2450">Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2450">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-2451">Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2451">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-2452">Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2452">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d9a09-2453">Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2453">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2454">Si usa un protocolo no confiable, el exceso de datos se perderá.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2454">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d9a09-2455">Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2455">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d9a09-2456">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2456">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-2457">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2457">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2458">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2458">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2459">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2459">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2460">Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2460">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d9a09-2461">Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2461">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2462">Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2462">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2463">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2463">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2464">En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2464">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-2465">Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el tamaño de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2465">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="d9a09-2466">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2466">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2467">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2467">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2468">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2468">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2469">El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2469">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2470">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2470">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2471">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2471">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2472">El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2472">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2473">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2473">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2474">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2474">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2475">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2475">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2476">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2476">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2477">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2477">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2478">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2478">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2479">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2479">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2480">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2480">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2481">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2481">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2482">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2482">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-2483">
            <see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2483">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2484">Recibe un datagrama en el búfer de datos usando el objeto <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el extremo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2484">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2485">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2485">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2486">El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2486">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d9a09-2487">Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2487">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d9a09-2488">Esta sobrecarga sólo requiere que proporcione un búfer de recepción, el necesario <xref:System.Net.Sockets.SocketFlags>y un <xref:System.Net.EndPoint> que representa el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2488">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d9a09-2489">El desplazamiento predeterminado es 0 y el tamaño predeterminado es la longitud del parámetro de búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2489">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2490">Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2490">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-2491">Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2491">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-2492">Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2492">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d9a09-2493">Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2493">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2494">Si usa un protocolo no confiable, el exceso de datos se perderá.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2494">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d9a09-2495">Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2495">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d9a09-2496">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2496">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-2497">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2497">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2498">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2498">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2499">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2499">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2500">Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2500">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d9a09-2501">Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2501">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2502">Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2502">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2503">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2503">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2504">En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2504">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-2505">Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el tamaño de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2505">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="d9a09-2506">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2506">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2507">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2507">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2508">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2508">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2509">El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2509">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2510">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2510">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2511">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2511">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2512">El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2512">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d9a09-2513"><xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2513"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2514">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2514">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2515">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2515">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2516">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2516">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2517">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2517">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2518">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2518">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2519">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2519">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2520">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2520">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2521">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2521">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2522">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2522">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2523">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2523">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2524">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2524">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-2525">
            <see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2525">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2526">Recibe el número especificado de bytes en el búfer de datos mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el extremo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2526">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2527">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2527">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2528">El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2528">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d9a09-2529">Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2529">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d9a09-2530">Esta sobrecarga sólo requiere que proporcione un búfer de recepción, el número de bytes que desea que reciban el necesario <xref:System.Net.Sockets.SocketFlags>y un <xref:System.Net.EndPoint> que representa el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2530">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d9a09-2531">El desplazamiento de búfer predeterminado es 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2531">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="d9a09-2532">Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2532">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d9a09-2533">Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2533">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2534">Si usa un protocolo no confiable, el exceso de datos se perderá.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2534">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d9a09-2535">Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2535">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d9a09-2536">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2536">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-2537">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2537">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2538">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2538">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2539">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2539">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2540">Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2540">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d9a09-2541">Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2541">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2542">Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2542">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2543">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2543">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2544">En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2544">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-2545">Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2545">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d9a09-2546">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2546">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2547">Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2547">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-2548">Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2548">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2549">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2549">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2550">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2550">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2551">El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2551">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2552">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2553">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2554">El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2554">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d9a09-2555">El tamaño de búfer y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2555">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2556">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2556">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2557">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2557">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2558">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2558">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2559">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2559">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2560">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2560">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2561">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2561">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2562">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2562">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2563">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2563">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2564">La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2564">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="d9a09-2565">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2565">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2566">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2566">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2567">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2567">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-2568">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2568">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2569">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2569">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2570">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2570">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2571">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2571">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-2572">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2572">The position in the <paramref name="buffer" /> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2573">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2573">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2574">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2574">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-2575">
            <see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2575">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2576">Recibe el número especificado de bytes de datos en la ubicación especificada del búfer de datos, mediante el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el punto de conexión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2576">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2577">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2577">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2578">El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2578">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d9a09-2579">Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2579">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d9a09-2580">Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2580">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d9a09-2581">Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2581">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2582">Si usa un protocolo no confiable, el exceso de datos se perderá.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2582">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d9a09-2583">Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2583">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d9a09-2584">Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2584">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d9a09-2585">Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2585">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2586">Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2586">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d9a09-2587">Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2587">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d9a09-2588">Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2588">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d9a09-2589">Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2589">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-2590">Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2590">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2591">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2591">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d9a09-2592">En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2592">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-2593">Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta la cantidad de bytes especificado por el `size` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2593">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d9a09-2594">Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2594">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2595">Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2595">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-2596">Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2596">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2597">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2597">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2598">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2598">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2599">El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2599">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2600">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2600">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2601">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2601">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2602">El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2602">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d9a09-2603">El desplazamiento, el tamaño del búfer y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2603">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2604">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2604">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2605">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2605">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2606">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2606">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2607">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2607">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2608">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2608">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2609">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2609">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-2610">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2610">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2611">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2611">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2612">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2612">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2613">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro de desplazamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2613">
              <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2614">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2614">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2615">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2615">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2616">La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2616">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="d9a09-2617">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2617">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2618">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2618">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2619">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2619">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2620">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2620">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2621">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2621">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-2622">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2622">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2623">Comienza a recibir asincrónicamente los datos de un dispositivo de red especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2623">Begins to asynchronously receive data from a specified network device.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2624">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2624">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-2625">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2625">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-2626">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2626">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-2627">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2627">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2628">El <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método se utiliza principalmente para recibir datos en un socket sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2628">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="d9a09-2629">Debe conocer la dirección local del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2629">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="d9a09-2630">El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto desde el que los datos son para recibirse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2630">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="d9a09-2631">El <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la solicitud de lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2631">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="d9a09-2632">Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2632">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d9a09-2633">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-2633">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-2634">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2634">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-2635">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2635">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-2636">Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2636">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="d9a09-2637">El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2637">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="d9a09-2638">Para los sockets similar a la secuencia de bytes, los datos entrantes se colocan en el búfer hasta que el búfer se llena, la conexión está cerrada o se agotan los datos almacenados en búfer internamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2638">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="d9a09-2639">El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2639">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2640">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2640">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-2641">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2641">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-2642">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2642">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2643">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2643">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2644">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2644">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2645">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2645">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-2646">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2646">The position in the <paramref name="buffer" /> parameter to store the received data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2647">Número de bytes que se va a recibir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2647">The number of bytes to receive.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2648">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2648">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-2649">
            <see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2649">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span>
          </span>
        </param>
        <param name="ipPacketInformation">
          <span data-ttu-id="d9a09-2650">
            <see cref="T:System.Net.Sockets.IPPacketInformation" /> que contiene información de dirección e interfaz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2650">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2651">Recibe el número especificado de bytes de datos en la ubicación especificada del búfer de datos, mediante el elemento <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el punto de conexión y la información del paquete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2651">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2652">Número de bytes recibidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2652">The number of bytes received.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2653">El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos, así como información sobre el paquete recibido.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2653">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="d9a09-2654">El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método se utiliza principalmente para recibir datos del mensaje en un socket sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2654">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="d9a09-2655">Debe conocer la dirección local del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2655">The socket's local address must be known.</span></span> <span data-ttu-id="d9a09-2656">Este método solo se puede usar con datagrama y sockets básicos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2656">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="d9a09-2657">El socket debe inicializarse con el tipo de socket establecido en <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> antes de llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2657">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="d9a09-2658">Esto puede hacerse cuando el socket se construye utilizando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2658">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2659">Para los sockets orientados a mensajes, se coloca un mensaje entrante en el `buffer` parámetro hasta el tamaño total especificado en el `size` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2659">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="d9a09-2660">El `offset` parámetro determina dónde en la `buffer` se colocan los datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2660">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="d9a09-2661">La cantidad de datos real se coloca en el `buffer` devuelto por la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2661">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-2662">El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método automáticamente método establece el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` la primera vez que se llama para un determinado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2662">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-2663">Sin embargo, el valor devuelto <xref:System.Net.Sockets.IPPacketInformation> objeto solo será válido para los paquetes que llegan al equipo local una vez establecida la opción de socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2663">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="d9a09-2664">Si un socket se envía paquetes entre cuando se enlaza a un extremo local (explícitamente por el <xref:System.Net.Sockets.Socket.Bind%2A> método o implícitamente por uno de los <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) y su primera llamada a la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método, las llamadas a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método devolverá válido <xref:System.Net.Sockets.IPPacketInformation> objetos para estos paquetes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2664">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="d9a09-2665">Para asegurarse de que todos los <xref:System.Net.Sockets.IPPacketInformation> objetos son válidos, una aplicación debe establecer el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` antes de que está enlazado a un punto de conexión local con el <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2665">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="d9a09-2666">Una aplicación puede examinar la `ipPacketInformation` parámetro si es necesario saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2666">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2667">El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2667">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2668">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2668">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2669">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2669">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2670">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2670">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-2671">\- O bien,</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2671">\- or-</span>
          </span>
          <span data-ttu-id="d9a09-2672">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2672">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2673">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2673">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2674">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2674">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2675">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2675">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-2676">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2676">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2677">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2677">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-2678">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2678">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2679">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro de desplazamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2679">
              <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2680">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2680">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2681">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2681">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2682">La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2682">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span>
          </span>
          <span data-ttu-id="d9a09-2683">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2683">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2684">.NET Framework se está ejecutando en procesador AMD de 64 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2684">The .NET Framework is running on an AMD 64-bit processor.</span>
          </span>
          <span data-ttu-id="d9a09-2685">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2685">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2686">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2686">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2687">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-2688">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2688">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span>
          </span>
        </exception>
        <permission cref="T:System.Net.SocketPermission">
          <span data-ttu-id="d9a09-2689">para aceptar conexiones desde la red.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2689">for accepting connections from the network.</span>
          </span>
          <span data-ttu-id="d9a09-2690">Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2690">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-2691">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2691">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2692">Comienza a recibir de forma asincrónica el número especificado de bytes de datos en la ubicación indicada del búfer de datos, mediante la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> especificada, y almacena la información sobre el extremo y el paquete.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2692">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2693">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2693">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-2694">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2694">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-2695">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2695">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-2696">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2696">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2697">El <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método se utiliza principalmente para recibir datos del mensaje en un socket sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2697">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="d9a09-2698">Debe conocer la dirección local del socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2698">The socket's local address must be known.</span></span> <span data-ttu-id="d9a09-2699">Este método solo se puede usar con datagrama y sockets básicos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2699">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="d9a09-2700">El socket debe inicializarse con el tipo de socket establecido en <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> antes de llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2700">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="d9a09-2701">Esto puede hacerse cuando el socket se construye utilizando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2701">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2702">El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto desde el que los datos son para recibirse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2702">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="d9a09-2703">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-2703">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-2704">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2704">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-2705">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2705">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-2706">Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2706">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="d9a09-2707">El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2707">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="d9a09-2708">El <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método establece automáticamente la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` la primera vez que se llama para un determinado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2708">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-2709">Sin embargo, la <xref:System.Net.Sockets.IPPacketInformation> objeto solo será válido para los paquetes que llegan al equipo local una vez establecida la opción de socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2709">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="d9a09-2710">Si un socket se envía paquetes entre cuando se enlaza el socket a un punto de conexión local (explícitamente por el <xref:System.Net.Sockets.Socket.Bind%2A> método o implícitamente por uno de los <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) y la primera llamada a la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>método, las llamadas a <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método dará como resultado no es válido <xref:System.Net.Sockets.IPPacketInformation> objetos para estos paquetes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2710">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="d9a09-2711">Para asegurarse de que todos los <xref:System.Net.Sockets.IPPacketInformation> objetos son válidos, una aplicación debe establecer el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket`true` antes de que está enlazado a un punto de conexión local con el <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2711">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="d9a09-2712">Una aplicación puede examinar los resultados <xref:System.Net.Sockets.IPPacketInformation> objetos si es necesario saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2712">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2713">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2713">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-2714">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2714">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2715">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2715">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2716">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2716">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2717">Obtiene o establece un valor que especifica el tiempo tras el que una llamada <see cref="Overload:System.Net.Sockets.Socket.Receive" /> sincrónica pasará a tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2717">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2718">Valor del tiempo de espera en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2718">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="d9a09-2719">El valor predeterminado es 0, lo que indica un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2719">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="d9a09-2720">Especificar -1 también indica un tiempo infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2720">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2721">Esta opción se aplica a sincrónico <xref:System.Net.Sockets.Socket.Receive%2A> sólo llamadas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2721">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="d9a09-2722">Si se supera el tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> método producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2722">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2723">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2723">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2724">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2724">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2725">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2725">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2726">El valor especificado para una operación Set es menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2726">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2727">Obtiene el extremo remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2727">Gets the remote endpoint.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-2728">
            <see cref="T:System.Net.EndPoint" /> con el que está comunicando el <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2728">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2729">Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> procedimientos property get el <xref:System.Net.EndPoint> que contiene el número de puerto y dirección IP remoto a la que el <xref:System.Net.Sockets.Socket> está conectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2729">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="d9a09-2730">Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contiene la dirección IP remota de forma predeterminada y el número de puerto con el que el <xref:System.Net.Sockets.Socket> se comunicará.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="d9a09-2731">Debe convertir esta <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> antes de recuperar toda la información.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2731">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="d9a09-2732">A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar el servidor remoto <xref:System.Net.IPAddress>y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar el número de puerto remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2732">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="d9a09-2733">El <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> se establece después de una llamada a <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2733">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2734">Si intenta tener acceso a esta propiedad anteriormente, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2734">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2735">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2735">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2736">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2736">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2737">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2737">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2738">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2738">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2739">En el ejemplo de código siguiente se recupera y muestra los puntos de conexión locales y remotas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2739">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2740">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2740">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2741">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2741">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">
          <span data-ttu-id="d9a09-2742">
            <see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar la legibilidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2742">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span>
          </span>
        </param>
        <param name="checkWrite">
          <span data-ttu-id="d9a09-2743">
            <see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar la capacidad de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2743">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span>
          </span>
        </param>
        <param name="checkError">
          <span data-ttu-id="d9a09-2744">
            <see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar errores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2744">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span>
          </span>
        </param>
        <param name="microSeconds">
          <span data-ttu-id="d9a09-2745">Valor del tiempo de espera, en microsegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2745">The time-out value, in microseconds.</span>
          </span>
          <span data-ttu-id="d9a09-2746">Un valor de -1 indica un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2746">A -1 value indicates an infinite time-out.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2747">Determina el estado de uno o varios sockets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2747">Determines the status of one or more sockets.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2748"><xref:System.Net.Sockets.Socket.Select%2A> es un método estático que determina el estado de uno o varios <xref:System.Net.Sockets.Socket> instancias.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2748"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="d9a09-2749">Debe colocar uno o varios sockets en un <xref:System.Collections.IList> antes de poder usar el <xref:System.Net.Sockets.Socket.Select%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2749">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="d9a09-2750">Comprobar la legibilidad mediante una llamada a <xref:System.Net.Sockets.Socket.Select%2A> con el <xref:System.Collections.IList> como el `checkRead` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2750">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="d9a09-2751">Para comprobar los sockets de escritura, use el `checkWrite` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2751">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="d9a09-2752">Para detectar las condiciones de error, utilice `checkError`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2752">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="d9a09-2753">Después de llamar a <xref:System.Net.Sockets.Socket.Select%2A>, el <xref:System.Collections.IList> se rellenará con sólo aquellos sockets que satisfacen las condiciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2753">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="d9a09-2754">Si está en un estado de escucha, la legibilidad significa que una llamada a <xref:System.Net.Sockets.Socket.Accept%2A> se realizará correctamente sin bloquear.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2754">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="d9a09-2755">Si ya han aceptado la conexión, la legibilidad significa que los datos están disponibles para su lectura.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2755">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="d9a09-2756">En estos casos, todas las operaciones de recepción se realizará correctamente sin bloquear.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2756">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="d9a09-2757">La legibilidad también puede indicar si el servidor remoto <xref:System.Net.Sockets.Socket> se cerrado hacia la conexión; en ese caso una llamada a <xref:System.Net.Sockets.Socket.Receive%2A> se devolverá inmediatamente, con cero bytes devueltos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2757">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="d9a09-2758"><xref:System.Net.Sockets.Socket.Select%2A> devuelve cuando al menos uno de los sockets de interés (los sockets en el `checkRead`, `checkWrite`, y `checkError` enumera) cumpla con los criterios especificados, o el `microSeconds` parámetro se supera, lo que ocurra primero.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2758"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="d9a09-2759">Establecer `microSeconds` en -1 especifica un tiempo de espera infinito.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2759">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="d9a09-2760">Si realiza una llamada sin bloqueo a <xref:System.Net.Sockets.Socket.Connect%2A>, escritura significa que se ha conectado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2760">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="d9a09-2761">Si ya tiene una conexión establecida, escritura significa todos envíen las operaciones se realizará correctamente sin bloquear.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2761">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="d9a09-2762">Si ha realizado una llamada sin bloqueo a <xref:System.Net.Sockets.Socket.Connect%2A>, el `checkerror` parámetro identifica sockets que no se han conectado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2762">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2763">Use la <xref:System.Net.Sockets.Socket.Poll%2A> método si desea determinar el estado de una sola <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2763">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2764">Este método no puede detectar ciertos tipos de problemas de conexión, como un cable de red rota, o que el host remoto cierre brusco.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2764">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="d9a09-2765">Debe intentar enviar o recibir datos para detectar estos tipos de errores.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2765">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2766">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2766">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2767">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2767">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2768">El siguiente ejemplo de código utiliza <xref:System.Net.Sockets.Socket.Select%2A> para determinar qué sockets de escucha tienen una solicitud de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2768">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2769">El parámetro <paramref name="checkRead" /> es <see langword="null" /> o está vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2769">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span>
          </span>
          <span data-ttu-id="d9a09-2770">- y -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2770">-and-</span>
          </span>
          <span data-ttu-id="d9a09-2771">El parámetro <paramref name="checkWrite" /> es <see langword="null" /> o está vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2771">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span>
          </span>
          <span data-ttu-id="d9a09-2772">- y -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2772">-and-</span>
          </span>
          <span data-ttu-id="d9a09-2773">El parámetro <paramref name="checkError" /> es <see langword="null" /> o está vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2773">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2774">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2774">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-2775">Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2775">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2776">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2776">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2777">Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2777">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2778">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2778">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2779"><xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2779"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d9a09-2780"><xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2780"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-2781">Esta sobrecarga requiere un búfer que contiene los datos que desea enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2781">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="d9a09-2782">El <xref:System.Net.Sockets.SocketFlags> valor predeterminado es 0, el desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2782">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="d9a09-2783">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2783">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2784">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2784">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2785">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2785">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2786">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2786">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2787">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2787">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2788">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2788">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2789">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2789">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2790">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2790">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2791">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2791">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2792">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2792">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2793">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2793">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2794">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2794">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2795">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2795">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2796">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2796">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2797">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2797">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2798">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2798">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2799">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2799">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2800">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2800">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2801">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2801">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2802">En el ejemplo de código siguiente se muestra el envío de datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2802">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2803">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2803">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2804">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2804">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2805">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2805">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2806">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2806">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2807">Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2807">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2808">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2808">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2809"><xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2809"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-2810">Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2810">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="d9a09-2811">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2811">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2812">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2812">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2813">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2813">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2814">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2814">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2815">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2815">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2816">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2816">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2817">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2817">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2818">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2818">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2819">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2819">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2820">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2820">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2821">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2821">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2822">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2822">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2823">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2823">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2824">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2824">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2825">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2825">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2826">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2826">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2827">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2827">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2828">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2828">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2829">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2829">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2830">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2830">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-2831">
            <paramref name="buffers" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2831">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2832">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2832">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-2833">Vea la sección de comentarios que figura más abajo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2833">See remarks section below.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2834">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2834">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2835">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2835">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2836">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2836">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2837">Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2837">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2838">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2838">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2839"><xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2839"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d9a09-2840">El <xref:System.Net.Sockets.Socket.Send%2A> método puede utilizarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2840">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-2841">Esta sobrecarga requiere un búfer que contiene los datos que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2841">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d9a09-2842">El desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2842">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="d9a09-2843">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` valor del parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2843">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-2844">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2844">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2845">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2845">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2846">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2846">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2847">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2847">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2848">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2848">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2849">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2849">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2850">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2850">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2851">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2851">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2852">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2852">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2853">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2853">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-2854">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2854">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2855">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2855">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2856">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2856">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2857">Debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2857">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-2858">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2858">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2859">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2859">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2860">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2860">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2861">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2861">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2862">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2862">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2863">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2863">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2864">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2864">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2865">En el ejemplo de código siguiente se muestra el envío de datos en un conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2865">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2866">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2866">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2867">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2867">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2868">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2868">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2869">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2869">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2870">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2870">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2871">Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado, utilizando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2871">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2872">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2872">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2873">Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2873">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="d9a09-2874">El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2874">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="d9a09-2875">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketFlags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2875">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-2876">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2876">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2877">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2877">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2878">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2878">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2879">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2879">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2880">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2880">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2881">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2881">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2882">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2882">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2883">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2883">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2884">En el modo sin bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2884">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2885">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2885">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2886">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2886">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2887">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2887">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2888">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2888">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2889">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2889">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2890">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2890">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2891">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2891">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2892">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2892">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2893">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2893">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2894">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2894">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2895">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2895">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-2896">
            <paramref name="buffers" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2896">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2897">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2897">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2898">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2898">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2899">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2899">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2900">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2900">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2901">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2901">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2902">Envía el número especificado de bytes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado, usando el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2902">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2903">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2903">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2904"><xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2904"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d9a09-2905"><xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2905"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-2906">Esta sobrecarga requiere un búfer que contiene los datos que desea enviar, el número de bytes que desea enviar y una combinación bit a bit de los <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2906">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d9a09-2907">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2907">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-2908">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2908">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2909">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2909">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2910">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2910">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2911">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada llamada a la <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2911">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d9a09-2912">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2912">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2913">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2914">Con un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2914">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2915">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2915">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2916">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2916">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d9a09-2917">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2917">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-2918">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2918">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2919">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2919">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2920">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2920">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2921">Debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2921">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-2922">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2922">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2923">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2923">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2924">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2924">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2925">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2925">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2926">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2926">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2927">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2927">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2928">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2928">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2929">El ejemplo de código siguiente envía los datos que se encuentra en el búfer y especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2929">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2930">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2930">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2931">
            <paramref name="size" /> es menor que 0 o supera el tamaño del búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2931">
              <paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2932">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2932">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-2933">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2933">-or-</span>
          </span>
          <span data-ttu-id="d9a09-2934">Se produce un error del sistema operativo al tener acceso al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2934">An operating system error occurs while accessing the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2935">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2935">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <span data-ttu-id="d9a09-2936">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2936">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2937">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2937">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-2938">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2938">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2939">Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado, utilizando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2939">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2940">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2940">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2941">Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2941">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="d9a09-2942">El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2942">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="d9a09-2943">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketFlags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2943">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-2944">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2944">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2945">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2945">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2946">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2946">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-2947">Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2947">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2948">Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2948">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2949">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2949">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2950">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2950">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2951">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2951">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2952">En el modo sin bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2952">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2953">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2953">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d9a09-2954">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2954">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2955">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2955">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2956">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2956">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2957">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2957">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2958">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2958">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2959">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2959">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2960">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2960">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2961">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2961">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2962">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2962">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2963">El valor de <paramref name="buffers" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2963">
              <paramref name="buffers" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-2964">
            <paramref name="buffers" /> está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2964">
              <paramref name="buffers" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-2965">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2965">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-2966">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2966">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-2967">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2967">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-2968">Posición en el búfer de datos donde comienza el envío de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2968">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-2969">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2969">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-2970">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2970">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-2971">Envía el número especificado de bytes de datos a un <see cref="T:System.Net.Sockets.Socket" /> conectado, comenzando en el desplazamiento especificado y usando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2971">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-2972">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2972">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-2973"><xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2973"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d9a09-2974"><xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2974"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-2975">En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2975">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-2976">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2976">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2977">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2977">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-2978">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2978">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-2979">Si no usas <xref:System.Net.Sockets.Socket.SendTo%2A>, tendrá que llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2979">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-2980">No pasa nada por usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2980">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-2981">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2981">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-2982">También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2982">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-2983">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2983">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-2984">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2984">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-2985">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2985">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-2986">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2986">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d9a09-2987">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2987">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-2988">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2988">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-2989">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2989">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-2990">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2990">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2991">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2991">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-2992">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2992">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2993">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2993">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-2994">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2994">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-2995">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2995">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-2996">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-2996">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-2997">El ejemplo de código siguiente especifica el búfer de datos, un desplazamiento, un tamaño, y <xref:System.Net.Sockets.SocketFlags> para enviar datos a una conectada <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-2997">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-2998">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2998">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-2999">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-2999">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3000">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3000">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3001">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3001">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-3002">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3002">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3003">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3003">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3004">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3004">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3005">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3005">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3006">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3006">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-3007">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3007">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3008">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3008">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3009">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3009">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-3010">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3010">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-3011">Posición en el búfer de datos donde comienza el envío de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3011">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-3012">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3012">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-3013">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3013">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="errorCode">
          <span data-ttu-id="d9a09-3014">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3014">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3015">Envía el número especificado de bytes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado, a partir de la posición de desplazamiento especificada y usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3015">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3016">Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3016">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3017"><xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3017"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d9a09-3018"><xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3018"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-3019">En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3019">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-3020">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3020">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3021">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3021">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-3022">Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3022">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-3023">Si no usas <xref:System.Net.Sockets.Socket.SendTo%2A>, tendrá que llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3023">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d9a09-3024">No pasa nada por usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3024">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d9a09-3025">También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3025">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-3026">También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3026">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3027">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3027">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-3028">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3028">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-3029">Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3029">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3030">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3030">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d9a09-3031">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3031">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-3032">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3032">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3033">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3033">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-3034">La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3034">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3035">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3035">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3036">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3036">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3037">La finalización correcta de un envío no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3037">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d9a09-3038">Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3038">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3039">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3039">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3040">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3040">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3041">El ejemplo de código siguiente especifica el búfer de datos, un desplazamiento, un tamaño, y <xref:System.Net.Sockets.SocketFlags> para enviar datos a una conectada <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3041">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3042">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3042">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3043">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3043">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3044">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3044">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3045">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3045">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-3046">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3046">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3047">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3047">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3048">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3048">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3049">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3049">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3050">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3050">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-3051">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3051">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3052">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3052">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3053">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3053">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-3054">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3054">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3055">Envía datos de forma asincrónica a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3055">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3056">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3056">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-3057">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3057">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-3058">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3058">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-3059">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3059">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3060">El <xref:System.Net.Sockets.Socket.SendAsync%2A> método se utiliza para escribir los datos salientes de uno o varios búferes en un socket orientado a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3060">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="d9a09-3061">Este método puede utilizarse también, sin embargo, en sockets sin conexión que han especificado un host remoto en una operación de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3061">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="d9a09-3062">El <xref:System.Net.Sockets.Socket.SendAsync%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3062">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-3063">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-3063">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="d9a09-3064"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d9a09-3064"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="d9a09-3065"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido</span><span class="sxs-lookup"><span data-stu-id="d9a09-3065"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="d9a09-3066"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido</span><span class="sxs-lookup"><span data-stu-id="d9a09-3066"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-3067">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3067">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-3068">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3068">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-3069">El <xref:System.Net.Sockets.Socket.SendAsync%2A> método producirá una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3069">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="d9a09-3070">Una llamada a la <xref:System.Net.Sockets.Socket.SendAsync%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3070">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d9a09-3071">Para los sockets orientados a mensajes, no superar el tamaño máximo del mensaje del proveedor de servicios de Windows sockets subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3071">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="d9a09-3072">Si los datos están demasiado largos para pasar de forma atómica a través del proveedor de servicio subyacente, no hay datos se transmiten y el <xref:System.Net.Sockets.Socket.SendAsync%2A> método produce una <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> establecido en el código de error de Winsock WSAEMSGSIZE (10040) nativo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3072">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="d9a09-3073">Tenga en cuenta que la finalización correcta de la <xref:System.Net.Sockets.Socket.SendAsync%2A> método no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3073">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-3074">Las propiedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> del parámetro <paramref name="e" /> deben hacer referencia a los búferes válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3074">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span>
          </span>
          <span data-ttu-id="d9a09-3075">Se puede establecer una de estas propiedades, pero no ambas al mismo tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3075">One or the other of these properties may be set, but not both at the same time.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3076">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3076">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3077">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3077">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3078">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3078">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3079">El <see cref="T:System.Net.Sockets.Socket" /> no está conectado todavía o no se obtuvo a través de un método <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> o <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3079">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3080">Obtiene o establece un valor que especifica el tamaño del búfer de envío de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3080">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3081">
            <see cref="T:System.Int32" /> que contiene el tamaño, en bytes, del búfer de envío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3081">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span>
          </span>
          <span data-ttu-id="d9a09-3082">El valor predeterminado es 8192.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3082">The default is 8192.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3083">Un tamaño de búfer mayor puede retrasar el reconocimiento de las dificultades de conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3083">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="d9a09-3084">Considere la posibilidad de aumentar el tamaño del búfer si va a transferir archivos grandes o usa un ancho de banda alto, la conexión de latencia alta (por ejemplo, un proveedor por satélite banda ancha.)</span><span class="sxs-lookup"><span data-stu-id="d9a09-3084">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3085">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3085">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3086">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3086">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3087">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3087">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3088">El valor especificado para una operación de establecimiento es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3088">The value specified for a set operation is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3089">Envía, de forma sincrónica, un archivo y datos opcionales a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3089">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="d9a09-3090">
            <see cref="T:System.String" /> que contiene la ruta de acceso y el nombre del archivo que se va a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3090">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="d9a09-3091">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3091">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3092">Envía el archivo <paramref name="fileName" /> a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado con el marcador de transmisión <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3092">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3093">Esta sobrecarga envía el archivo `fileName` al socket conectado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3093">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="d9a09-3094">El `flags` parámetro el valor predeterminado es <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) y el `preBuffer` y `postBuffer` parámetros de forma predeterminada `null`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3094">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="d9a09-3095">Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3095">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d9a09-3096">Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3096">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d9a09-3097">Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3097">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d9a09-3098">Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3098">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d9a09-3099">Para obtener más información sobre la `TransmitFile` función y sus marcas, consulte la documentación de Windows Sockets en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3099">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="d9a09-3100"><xref:System.Net.Sockets.Socket.SendFile%2A> envía un archivo de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3100"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3101"><xref:System.Net.Sockets.Socket.SendFile%2A> puede usarse para ambos orientados a conexiones y protocolos sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3101"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-3102">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, de lo contrario <xref:System.Net.Sockets.Socket.SendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3102">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="d9a09-3103">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión al host remoto o usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3103">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-3104">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.SendFile%2A> bloquea hasta que se envía el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3104">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="d9a09-3105">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.SendFile%2A> puede completarse correctamente antes de que todo el archivo se ha enviado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3105">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="d9a09-3106">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3106">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3107">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3107">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-3108">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3108">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3109">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3109">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3110">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3110">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3111">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3111">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3112">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3112">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3113">En el ejemplo de código siguiente se crea y se conecta a un socket y, a continuación, envía un archivo con el host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3113">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="d9a09-3114">El archivo "test.txt" se encuentra en el directorio raíz de la máquina local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3114">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3115">El socket no está conectado a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3115">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3116">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3116">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3117">El objeto <see cref="T:System.Net.Sockets.Socket" /> no está en modo de bloqueo y no puede aceptar esta llamada sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3117">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d9a09-3118">No se encontró el archivo <paramref name="fileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3118">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3119">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3119">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">
          <span data-ttu-id="d9a09-3120">
            <see cref="T:System.String" /> que contiene la ruta de acceso y el nombre del archivo que se va a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3120">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span>
          </span>
          <span data-ttu-id="d9a09-3121">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3121">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="preBuffer">
          <span data-ttu-id="d9a09-3122">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar antes de enviar el archivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3122">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span>
          </span>
          <span data-ttu-id="d9a09-3123">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3123">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="postBuffer">
          <span data-ttu-id="d9a09-3124">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar después de enviar el archivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3124">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span>
          </span>
          <span data-ttu-id="d9a09-3125">Este parámetro puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3125">This parameter can be <see langword="null" />.</span>
          </span>
        </param>
        <param name="flags">
          <span data-ttu-id="d9a09-3126">Uno o varios de los valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3126">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3127">Envía el archivo <paramref name="fileName" /> y búferes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el valor <see cref="T:System.Net.Sockets.TransmitFileOptions" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3127">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3128">Esta sobrecarga requiere el nombre del archivo que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3128">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="d9a09-3129">El `preBuffer` parámetro contiene todos los datos debe preceder el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3129">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="d9a09-3130">`postBuffer` contiene los datos que desea que siga el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3130">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="d9a09-3131">Si `fileName` está en el directorio de trabajo actual, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3131">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d9a09-3132">Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3132">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="d9a09-3133">El `flags` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3133">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d9a09-3134">Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3134">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d9a09-3135">Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3135">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d9a09-3136">Para obtener más información sobre la `TransmitFile` función y sus marcas, consulte la documentación de Windows Sockets en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3136">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="d9a09-3137"><xref:System.Net.Sockets.Socket.SendFile%2A> envía un archivo de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3137"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3138"><xref:System.Net.Sockets.Socket.SendFile%2A> puede usarse para ambos orientados a conexiones y protocolos sin conexión.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3138"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="d9a09-3139">Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método; en caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> produce una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3139">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3140">Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3140">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d9a09-3141">Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.SendFile%2A> bloquea hasta que se envía el archivo completo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3141">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="d9a09-3142">En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.SendFile%2A> puede completarse correctamente antes de que todo el archivo se ha enviado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3142">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="d9a09-3143">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3143">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3144">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3144">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-3145">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3145">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3146">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3146">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3147">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3147">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3148">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3148">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3149">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3149">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3150">En el ejemplo de código siguiente se crea y se conecta a un socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3150">The following code example creates and connects a socket.</span></span> <span data-ttu-id="d9a09-3151">El archivo "test.txt" se encuentra en el directorio raíz de la máquina local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3151">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="d9a09-3152">En este ejemplo, crearemos un búfer y tamaño de postbuffer de datos y enviarlos al host remoto con el archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3152">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="d9a09-3153">El valor predeterminado <xref:System.Net.Sockets.TransmitFileOptions> se usan.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3153">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3154">El sistema operativo no es Windows NT o una versión posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3154">The operating system is not Windows NT or later.</span>
          </span>
          <span data-ttu-id="d9a09-3155">\- o -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3155">\- or -</span>
          </span>
          <span data-ttu-id="d9a09-3156">El socket no está conectado a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3156">The socket is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3157">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3157">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3158">El objeto <see cref="T:System.Net.Sockets.Socket" /> no está en modo de bloqueo y no puede aceptar esta llamada sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3158">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d9a09-3159">No se encontró el archivo <paramref name="fileName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3159">The file <paramref name="fileName" /> was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3160">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3160">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-3161">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3161">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3162">Envía de forma asincrónica una colección de archivos o búferes de datos en memoria a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3162">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3163">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3163">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-3164">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3164">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-3165">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3165">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-3166">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3166">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3167">El <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método se usa para enviar los búferes de datos de una colección de archivos o en la memoria al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3167">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="d9a09-3168">El <xref:System.Net.Sockets.Socket> ya debe estar conectado al host remoto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3168">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="d9a09-3169">Si un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> hace referencia a un archivo en el directorio de trabajo, que se puede identificar con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3169">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d9a09-3170">Se admiten caracteres comodín y nombres de recurso compartido UNC.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3170">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="d9a09-3171">Si no se encuentra el archivo, <xref:System.IO.FileNotFoundException> se produce.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3171">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d9a09-3172">Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3172">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d9a09-3173">El <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3173">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d9a09-3174">Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3174">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d9a09-3175">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-3175">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-3176">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3176">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-3177">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3177">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-3178">Este método usa la función TransmitPackets de la API de Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3178">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d9a09-3179">Para obtener más información acerca de la función TransmitPackets y sus marcas, consulte la documentación de Windows Sockets en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3179">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="d9a09-3180">Si bien pensado para protocolos orientados a conexiones, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método para establecer un host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3180">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d9a09-3181">Protocolos sin conexión, también debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3181">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3182">Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3182">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="d9a09-3183">El <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> se optimiza el método según el sistema operativo en el que se utiliza.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3183">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="d9a09-3184">En las ediciones de Windows server, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método está optimizado para alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3184">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="d9a09-3185">En las ediciones del cliente de Windows, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método está optimizado para la utilización de memoria y los recursos mínima.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3185">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="d9a09-3186">El uso de la <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> marca en el <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro puede ofrecer ventajas significativas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3186">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="d9a09-3187">Si el subproceso iniciando el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> llamada al método es que se usa para cálculos complejos, es posible, aunque improbable, que se podrían evitar APC inicio.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3187">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="d9a09-3188">Tenga en cuenta que hay una diferencia entre las APC del núcleo y modo de usuario.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3188">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="d9a09-3189">APC de kernel se inician cuando un subproceso está en un estado de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3189">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="d9a09-3190">APC de modo de usuario se inician cuando un subproceso está en un estado de espera de alerta</span><span class="sxs-lookup"><span data-stu-id="d9a09-3190">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="d9a09-3191">No se encontró el archivo especificado en la propiedad <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3191">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3192">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3192">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3193">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3193">Windows XP or later is required for this method.</span>
          </span>
          <span data-ttu-id="d9a09-3194">Esta excepción también se produce si <see cref="T:System.Net.Sockets.Socket" /> no está conectado a un host remoto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3194">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3195">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3195">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3196">Se está usando un <see cref="T:System.Net.Sockets.Socket" /> sin conexión y el archivo que se está enviando supera el tamaño de paquete máximo del transporte subyacente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3196">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3197">Obtiene o establece un valor que especifica el tiempo tras el que una llamada <see cref="Overload:System.Net.Sockets.Socket.Send" /> sincrónica pasará a tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3197">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3198">Valor del tiempo de espera en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3198">The time-out value, in milliseconds.</span>
          </span>
          <span data-ttu-id="d9a09-3199">Si establece la propiedad con un valor comprendido entre 1 y 499, el valor cambiará a 500.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3199">If you set the property with a value between 1 and 499, the value will be changed to 500.</span>
          </span>
          <span data-ttu-id="d9a09-3200">El valor predeterminado es 0, lo que indica un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3200">The default value is 0, which indicates an infinite time-out period.</span>
          </span>
          <span data-ttu-id="d9a09-3201">Especificar -1 también indica un tiempo infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3201">Specifying -1 also indicates an infinite time-out period.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3202">Esta opción se aplica a sincrónico <xref:System.Net.Sockets.Socket.Send%2A> sólo llamadas.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3202">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="d9a09-3203">Si se supera el tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> método producirá una <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3203">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3204">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.SendTimeout%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3204">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3205">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3205">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3206">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3206">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3207">El valor especificado para una operación Set es menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3207">The value specified for a set operation is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3208">Envía datos a un extremo específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3208">Sends data to a specific endpoint.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-3209">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3209">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-3210">
            <see cref="T:System.Net.EndPoint" /> que representa el destino de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3210">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3211">Envía los datos al extremo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3211">Sends data to the specified endpoint.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3212">Número de bytes enviados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3212">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3213">En esta sobrecarga, el desplazamiento de búfer predeterminado es 0, el número de bytes que se envían los valores predeterminados para el tamaño de la `buffer` parámetro y el <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3213">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="d9a09-3214">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3214">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-3215">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3215">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d9a09-3216">Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3216">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-3217">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3217">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-3218">Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3218">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d9a09-3219">Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3219">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d9a09-3220">Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3220">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3221">Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3221">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3222">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3222">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-3223">En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3223">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-3224">Los sockets de bloqueo se bloquearán hasta que se envían todos los bytes del búfer.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3224">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="d9a09-3225">Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes en el `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3225">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d9a09-3226">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía todos los bytes en el `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3226">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d9a09-3227">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3227">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3228">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3228">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d9a09-3229">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3229">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d9a09-3230">Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3230">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-3231">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3231">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-3232">También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3232">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3233">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3233">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3234">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3234">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3235">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3235">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3236">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3236">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3237">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3237">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3238">En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3238">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3239">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3239">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-3240">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3240">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3241">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3241">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3242">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3242">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3243">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3243">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-3244">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3244">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-3245">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3245">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-3246">
            <see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3246">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3247">Envía datos a un extremo específico mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3247">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3248">Número de bytes enviados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3248">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3249">En esta sobrecarga, el desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño de la `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3249">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="d9a09-3250">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3250">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-3251">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3251">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-3252">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3252">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d9a09-3253">Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3253">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-3254">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3254">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-3255">Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3255">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d9a09-3256">Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3256">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d9a09-3257">Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3257">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3258">Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3258">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3259">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3259">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-3260">En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3260">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-3261">Los sockets de bloqueo se bloquearán hasta que el solicitado todos los bytes en el `buffer` se envían.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3261">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="d9a09-3262">Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes en el `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3262">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d9a09-3263">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía todos los bytes en el `buffer`.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3263">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d9a09-3264">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3264">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3265">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3265">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d9a09-3266">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3266">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d9a09-3267">Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3267">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-3268">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3268">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-3269">También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3269">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3270">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3270">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3271">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3271">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3272">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3272">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3273">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3273">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3274">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3274">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3275">En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3275">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d9a09-3276"><xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3276"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3277">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3277">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-3278">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3278">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3279">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3279">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3280">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3280">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3281">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3281">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-3282">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3282">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-3283">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3283">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-3284">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3284">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-3285">
            <see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3285">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3286">Envía el número especificado de bytes de datos al extremo especificado usando los <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3286">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3287">Número de bytes enviados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3287">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3288">En esta sobrecarga, el desplazamiento de búfer predeterminado es 0.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3288">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="d9a09-3289">Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3289">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-3290">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3290">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-3291">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3291">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d9a09-3292">Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3292">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-3293">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3293">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-3294">Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3294">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d9a09-3295">Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3295">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d9a09-3296">Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3296">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3297">Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3297">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3298">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3298">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-3299">En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3299">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-3300">Los sockets de bloqueo se bloquearán hasta que se envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3300">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d9a09-3301">Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes solicitados en una sola operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3301">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="d9a09-3302">Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3302">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-3303">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3303">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3304">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3304">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d9a09-3305">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3305">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d9a09-3306">Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3306">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-3307">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3307">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-3308">También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3308">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3309">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3309">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3310">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3310">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3311">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3311">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3312">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3312">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3313">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3313">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3314">En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3314">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d9a09-3315">El tamaño y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3315">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3316">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3316">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-3317">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3317">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3318">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3318">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3319">El parámetro <paramref name="size" /> especificado sobrepasa el tamaño de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3319">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3320">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3320">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3321">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3321">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="d9a09-3322">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3322">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="d9a09-3323">Posición en el búfer de datos donde comienza el envío de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3323">The position in the data buffer at which to begin sending data.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="d9a09-3324">Número de bytes para enviar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3324">The number of bytes to send.</span>
          </span>
        </param>
        <param name="socketFlags">
          <span data-ttu-id="d9a09-3325">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3325">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span>
          </span>
        </param>
        <param name="remoteEP">
          <span data-ttu-id="d9a09-3326">
            <see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3326">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3327">Envía el número especificado de bytes de datos al extremo especificado, comenzando en la ubicación especificada del búfer y usando los <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3327">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3328">Número de bytes enviados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3328">The number of bytes sent.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3329">En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3329">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-3330">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3330">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d9a09-3331">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3331">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d9a09-3332">Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3332">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-3333">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3333">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d9a09-3334">Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3334">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d9a09-3335">Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3335">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d9a09-3336">Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3336">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d9a09-3337">Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3337">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3338">También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3338">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d9a09-3339">En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3339">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d9a09-3340">Los sockets de bloqueo se bloquearán hasta que se envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3340">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d9a09-3341">Desde sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes solicitados en una sola operación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3341">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="d9a09-3342">Es su responsabilidad de las aplicaciones para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3342">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d9a09-3343">No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3343">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d9a09-3344">Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3344">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d9a09-3345">La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3345">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d9a09-3346">Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3346">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d9a09-3347">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3347">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d9a09-3348">También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3348">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3349">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3349">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3350">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3350">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3351">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3351">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3352">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3352">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3353">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3353">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3354">En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3354">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d9a09-3355">El desplazamiento, el tamaño y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3355">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3356">El valor de <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3356">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d9a09-3357">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3357">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3358">El valor de <paramref name="remoteEP" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3358">
              <paramref name="remoteEP" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3359">
            <paramref name="offset" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3359">
              <paramref name="offset" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3360">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3360">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3361">
            <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3361">
              <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span>
          </span>
          <span data-ttu-id="d9a09-3362">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3362">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3363">
            <paramref name="size" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3363">
              <paramref name="size" /> is less than 0.</span>
          </span>
          <span data-ttu-id="d9a09-3364">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3364">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3365">
            <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3365">
              <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3366">
            <paramref name="socketFlags" /> no es una combinación válida de valores.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3366">
              <paramref name="socketFlags" /> is not a valid combination of values.</span>
          </span>
          <span data-ttu-id="d9a09-3367">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3367">-or-</span>
          </span>
          <span data-ttu-id="d9a09-3368">Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3368">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3369">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3369">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="d9a09-3370">Un llamador de la pila de llamadas no tiene los permisos necesarios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3370">A caller in the call stack does not have the required permissions.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="d9a09-3371">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3371">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3372">Envía datos de forma asincrónica a un host remoto concreto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3372">Sends data asynchronously to a specific remote host.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d9a09-3373">Devuelve <see langword="true" /> si la operación de E/S está pendiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3373">Returns <see langword="true" /> if the I/O operation is pending.</span>
          </span>
          <span data-ttu-id="d9a09-3374">Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3374">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span>
          </span>
          <span data-ttu-id="d9a09-3375">Devuelve <see langword="false" /> si la operación de E/S se completó de forma sincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3375">Returns <see langword="false" /> if the I/O operation completed synchronously.</span>
          </span>
          <span data-ttu-id="d9a09-3376">En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3376">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3377">El <xref:System.Net.Sockets.Socket.SendToAsync%2A> método inicia una operación de envío asincrónico al host remoto especificado en el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad de la `e` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3377">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="d9a09-3378">Una llamada a la <xref:System.Net.Sockets.Socket.SendToAsync%2A> método le permite enviar datos en un subproceso de ejecución independiente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3378">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="d9a09-3379">Aunque este método está pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funciona con los protocolos sin conexión y orientados a conexiones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3379">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d9a09-3380">Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3380">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d9a09-3381">Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:</span><span class="sxs-lookup"><span data-stu-id="d9a09-3381">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d9a09-3382">El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendToAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3382">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d9a09-3383">Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3383">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d9a09-3384">Si utiliza un protocolo orientado a conexiones, primero debe llamar a la <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3384">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="d9a09-3385">En caso contrario <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3385">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3386">Cuando se usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.SendToAsync%2A> método pasará por alto el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad y envía los datos a la <xref:System.Net.EndPoint?displayProperty=nameWithType> establecidos en el <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3386">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-3387">Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3387">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="d9a09-3388">Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.SendAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3388">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="d9a09-3389">Si se llama a la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendToAsync%2A>, el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad invalidará el host remoto predeterminado especificado para que sólo la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3389">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d9a09-3390">También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3390">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d9a09-3391">En este caso, el proveedor de servicios subyacente asignará al más adecuado número de puerto y dirección de la IP red local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3391">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="d9a09-3392">Use un número de puerto de cero si desea que el proveedor de servicios subyacente para seleccionar un puerto libre.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3392">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="d9a09-3393">Si tiene que identificar el número de puerto y dirección IP de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> señala el evento y se llaman a los delegados asociados.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3393">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="d9a09-3394">Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método y establezca el socket opción <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> en true.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3394">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="d9a09-3395">También debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3395">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d9a09-3396">Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3396">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d9a09-3397">Si especifica el marcador DontRoute en el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad, los datos que se envía no se enrutarán.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3397">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d9a09-3398">Para los sockets orientados a mensajes, debe tener cuidado para no superar el tamaño máximo del mensaje del transporte subyacente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3398">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="d9a09-3399">Si el tamaño del búfer supera el tamaño máximo de paquetes del proveedor de servicios subyacente, no se envía el datagrama y <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3399">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d9a09-3400">La finalización correcta de un <xref:System.Net.Sockets.Socket.SendToAsync%2A> método no indica que los datos se ha entregado correctamente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3400">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3401">
            <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3401">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3402">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3402">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3403">Se requiere Windows XP o posteriores para este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3403">Windows XP or later is required for this method.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3404">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3404">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3405">El protocolo especificado está orientado a la conexión, pero el <see cref="T:System.Net.Sockets.Socket" /> no está conectado todavía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3405">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">
          <span data-ttu-id="d9a09-3406">Nivel de protección IP que se va a establecer en este socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3406">The IP protection level to set on this socket.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3407">Establece el nivel de protección IP en un socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3407">Set the IP protection level on a socket.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3408">El <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método permite restringir un un socket IPv6 o la dirección IP para que escuche en un ámbito especificado, como direcciones con el mismo vínculo o sitio prefijo local.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3408">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="d9a09-3409">Esta opción de socket permite a las aplicaciones colocar restricciones de acceso en sockets IPv6 o la dirección IP.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3409">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="d9a09-3410">Estas restricciones permiten que una aplicación que se ejecuta en una LAN privada se fortalezca de forma sencilla frente a ataques externos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3410">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="d9a09-3411">También se puede usar esta opción de socket para quitar las restricciones de acceso si el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3411">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="d9a09-3412">Esta opción de socket amplía o reduce el ámbito de un socket de escucha, lo que permite el acceso no restringido de usuarios públicos y privados cuando sea adecuado o restringe el acceso únicamente al mismo sitio, según necesidad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3412">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="d9a09-3413">Esta opción de socket definió niveles de protección especificados en la enumeración <xref:System.Net.Sockets.IPProtectionLevel>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3413">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="d9a09-3414">El <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método se utiliza para habilitar o deshabilitar la exploración transversal de direcciones de red (NAT) para un <xref:System.Net.Sockets.Socket> instancia.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3414">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="d9a09-3415">Cruce seguro de NAT puede proporcionarse mediante un túnel ISATAP, 6to4 o Teredo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3415">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="d9a09-3416">Cuando el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, o <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, se deshabilita explícitamente la exploración transversal de NAT para una <xref:System.Net.Sockets.Socket> instancia.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3416">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="d9a09-3417">Cuando el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, esto puede permitir NAT transversal para un <xref:System.Net.Sockets.Socket> según las reglas de firewall en su lugar en el sistema.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3417">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d9a09-3418">El parámetro <paramref name="level" /> no puede ser <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3418">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span>
          </span>
          <span data-ttu-id="d9a09-3419">El nivel de protección IP no puede estar establecido en no especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3419">The IP protection level cannot be set to unspecified.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3420">
            <see cref="T:System.Net.Sockets.AddressFamily" /> del socket debe ser <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3420">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3421">Establece una opción de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3421">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-3422">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3422">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-3423">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3423">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="d9a09-3424">Valor de la opción, representado como <see cref="T:System.Boolean" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3424">The value of the option, represented as a <see cref="T:System.Boolean" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3425">Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en el valor de <see cref="T:System.Boolean" /> indicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3425">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3426"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3426"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3427">Establecer `optionValue` a `true` para habilitar la opción, o a `false` para deshabilitar la opción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3427">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="d9a09-3428"><xref:System.Net.Sockets.Socket> las opciones se agrupan por nivel de compatibilidad de protocolo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3428"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="d9a09-3429">A continuación aparecen los diversos <xref:System.Net.Sockets.Socket> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3429">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="d9a09-3430">Estas opciones se agrupan por adecuado <xref:System.Net.Sockets.SocketOptionLevel> valor.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3430">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="d9a09-3431">Si pretende establecer cualquiera de estas opciones, asegúrese de usar adecuado <xref:System.Net.Sockets.SocketOptionLevel> valor para el `optionLevel` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3431">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="d9a09-3432">Debe especificarse la opción que elija para establecer en el `optionName` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3432">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="d9a09-3433">Si desea obtener el valor actual de cualquiera de las opciones enumeradas, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3433">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-3434"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3434"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="d9a09-3435"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3435"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="d9a09-3436"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3436"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="d9a09-3437"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3437"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="d9a09-3438">Para obtener más información sobre estas opciones, consulte el <xref:System.Net.Sockets.SocketOptionName> enumeración.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3438">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3439">Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3439">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3440">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3440">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3441">En el ejemplo de código siguiente se abre un socket y permite la `DontLinger` y `OutOfBandInline` opciones de socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3441">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3442">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3442">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3443">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3443">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-3444">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3444">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-3445">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3445">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="d9a09-3446">Matriz de tipo <see cref="T:System.Byte" /> que representa el valor de la opción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3446">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3447">Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> indicada en el valor especificado, representado como una matriz de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3447">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3448"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3448"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3449">Utilice esta sobrecarga para establecerlas <xref:System.Net.Sockets.Socket> opciones que requieren una matriz de bytes como un valor de opción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3449">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3450">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3450">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3451">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3451">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3452">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3452">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3453">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3453">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3454">El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3454">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3455">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3455">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3456">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3456">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-3457">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3457">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-3458">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3458">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="d9a09-3459">Valor de la opción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3459">A value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3460">Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en el valor entero indicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3460">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3461"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3461"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3462">Para una opción con un <xref:System.Boolean> tipo de datos, especifique un valor distinto de cero para habilitar la opción y un valor de cero para deshabilitar la opción.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3462">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="d9a09-3463">Para una opción con un tipo de datos entero, especifique el valor adecuado.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3463">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="d9a09-3464"><xref:System.Net.Sockets.Socket> las opciones se agrupan por nivel de compatibilidad de protocolo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3464"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="d9a09-3465">A continuación aparecen los diversos <xref:System.Net.Sockets.Socket> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3465">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="d9a09-3466">Estas opciones se agrupan por adecuado <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3466">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="d9a09-3467">Si pretende establecer cualquiera de estas opciones, asegúrese de usar adecuado <xref:System.Net.Sockets.SocketOptionLevel> para el `optionLevel` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3467">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d9a09-3468">Debe especificarse la opción que elija para establecer en el `optionName` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3468">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="d9a09-3469">Si desea obtener el valor actual de cualquiera de las opciones enumeradas, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3469">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="d9a09-3470"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3470"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="d9a09-3471"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3471"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="d9a09-3472"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3472"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="d9a09-3473"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3473"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="d9a09-3474"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3474"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="d9a09-3475">Para obtener más información acerca de estas opciones, consulte el <xref:System.Net.Sockets.SocketOptionName> enumeración.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3475">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3476">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3476">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3477">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3477">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3478">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3478">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3479">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3479">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3480">El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3480">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3481">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3481">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3482">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3482">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <span data-ttu-id="d9a09-3483">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3483">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span>
          </span>
        </param>
        <param name="optionName">
          <span data-ttu-id="d9a09-3484">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3484">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span>
          </span>
        </param>
        <param name="optionValue">
          <span data-ttu-id="d9a09-3485">
            <see cref="T:System.Net.Sockets.LingerOption" /> o <see cref="T:System.Net.Sockets.MulticastOption" /> que contiene el valor de la opción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3485">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3486">Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> indicada en el valor especificado, representado como un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3486">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3487"><xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3487"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3488">Utilice esta sobrecarga para establecer el <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, y <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opciones.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3488">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="d9a09-3489">Para el <xref:System.Net.Sockets.SocketOptionName.Linger> opción, utilice <xref:System.Net.Sockets.Socket> para el `optionLevel` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3489">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d9a09-3490">Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> y <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilice <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3490">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="d9a09-3491">Si desea obtener el valor actual de cualquiera de las opciones enumeradas anteriormente, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3491">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3492">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3492">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3493">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3493">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3494">El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3494">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d9a09-3495">El valor de <paramref name="optionValue" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3495">
              <paramref name="optionValue" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3496">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3496">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3497">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3497">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">
          <span data-ttu-id="d9a09-3498">Uno de los valores de <see cref="T:System.Net.Sockets.SocketShutdown" /> que especifica la operación que ya no estará permitida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3498">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d9a09-3499">Deshabilita los envíos y recepciones en un objeto <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3499">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3500">Cuando se usa un orientado a conexión <xref:System.Net.Sockets.Socket>, llame siempre a la <xref:System.Net.Sockets.Socket.Shutdown%2A> método antes de cerrar el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3500">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3501">Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3501">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d9a09-3502">Llame a la <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3502">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d9a09-3503">No intente reutilizar el <xref:System.Net.Sockets.Socket> después del cierre.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3503">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="d9a09-3504">La tabla siguiente muestra la <xref:System.Net.Sockets.SocketShutdown> valores de enumeración que son válidos para el `how` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3504">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="d9a09-3505">Valor</span><span class="sxs-lookup"><span data-stu-id="d9a09-3505">Value</span></span>|<span data-ttu-id="d9a09-3506">Descripción</span><span class="sxs-lookup"><span data-stu-id="d9a09-3506">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="d9a09-3507">Enviar</span><span class="sxs-lookup"><span data-stu-id="d9a09-3507">Send</span></span>|<span data-ttu-id="d9a09-3508">Deshabilite los envíos en <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3508">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="d9a09-3509">Recibir</span><span class="sxs-lookup"><span data-stu-id="d9a09-3509">Receive</span></span>|<span data-ttu-id="d9a09-3510">Deshabilite las recepciones en esto <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3510">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="d9a09-3511">Ambos</span><span class="sxs-lookup"><span data-stu-id="d9a09-3511">Both</span></span>|<span data-ttu-id="d9a09-3512">Deshabilitar el envío y recepción en esto <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3512">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="d9a09-3513">Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Send> especifica que las siguientes llamadas a <xref:System.Net.Sockets.Socket.Send%2A> no se permiten.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3513">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="d9a09-3514">Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, especificando <xref:System.Net.Sockets.SocketShutdown.Send> no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3514">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="d9a09-3515">Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Receive> especifica que las siguientes llamadas a <xref:System.Net.Sockets.Socket.Receive%2A> no se permiten.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3515">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="d9a09-3516">Esto no tiene ningún efecto en las capas inferiores de protocolo.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3516">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="d9a09-3517">Si utiliza un protocolo orientado a conexiones, la conexión finaliza si cualquiera de las siguientes condiciones existe después de llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="d9a09-3517">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="d9a09-3518">Datos están en el búfer de red entrante a la espera de recibirse.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3518">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="d9a09-3519">Ha llegado más datos.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3519">More data has arrived.</span></span>  
  
 <span data-ttu-id="d9a09-3520">Si usa un protocolo sin conexión, los datagramas se aceptan y en cola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3520">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="d9a09-3521">Sin embargo, si no hay espacio de búfer disponible para los datagramas entrantes adicionales, se descartarán y no se devolverá ningún error al remitente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3521">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="d9a09-3522">Uso de <xref:System.Net.Sockets.Socket.Shutdown%2A> en un protocolo sin conexión <xref:System.Net.Sockets.Socket> no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3522">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="d9a09-3523">Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Both> deshabilita tanto los envíos y recepciones como se describió anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3523">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3524">Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a la <xref:System.Net.Sockets.Socket.Shutdown%2A> método, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3524">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3525">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3525">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9a09-3526">Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3526">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d9a09-3527">Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="d9a09-3527">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3528">El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.Shutdown%2A> para deshabilitar el <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3528">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3529">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3529">An error occurred when attempting to access the socket.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3530">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3530">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3531">Obtiene el tipo de <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3531">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3532">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3532">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3533"><xref:System.Net.Sockets.Socket.SocketType%2A> es de solo lectura y se establece cuando el <xref:System.Net.Sockets.Socket> se crea.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3533"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3534">El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3534">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3535">Obtiene un valor que indica si la compatibilidad con IPv4 está disponible y habilitada en el host actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3535">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3536">
            <see langword="true" /> si el host actual admite el protocolo IPv4; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3536">
              <see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3537">El sistema operativo puede admitir los protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3537">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3538">Obtiene un valor que indica si el marco de trabajo admite IPv6 para ciertos miembros <see cref="T:System.Net.Dns" /> obsoletos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3538">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3539">Es <see langword="true" /> si el marco de trabajo admite IPv6 para determinados métodos obsoletos de <see cref="T:System.Net.Dns" />; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3539">
              <see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3540">El sistema operativo puede admitir los protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3540">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3541">Obtiene o establece un valor que especifica el valor de período de vida (TTL) de los paquetes de protocolo Internet (IP) enviados por <see cref="T:System.Net.Sockets.Socket" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3541">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3542">Valor TTL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3542">The TTL value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3543">El valor de TTL indica el número máximo de enrutadores que puede atravesar un paquete antes de que el enrutador descarta el paquete y un protocolo de mensajes de Internet Control "TTL excedido" (ICMP) mensaje de error se devuelve al remitente.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3543">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="d9a09-3544">El valor de TTL puede establecerse en un valor de 0 a 255.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3544">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="d9a09-3545">Cuando no se establece esta propiedad, el valor TTL predeterminado para un socket es 32.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3545">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="d9a09-3546">Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) se omite la pila TCP/IP si se ha establecido una conexión correcta utilizando el socket.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3546">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="d9a09-3547">Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3547">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d9a09-3548">Después de haber obtenido este código, consulte la versión de Windows Sockets 2 documentación de códigos de error de API en MSDN library para obtener una descripción detallada del error.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3548">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d9a09-3549">En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.Ttl%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3549">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d9a09-3550">El valor TTL no se puede establecer en un número negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3550">The TTL value can't be set to a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d9a09-3551">Esta propiedad sólo se puede establecer para sockets de las familias de <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3551">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span>
          </span>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="d9a09-3552">Error al intentar acceder al socket.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3552">An error occurred when attempting to access the socket.</span>
          </span>
          <span data-ttu-id="d9a09-3553">También se devuelve este error cuando se ha intentado para establecer TTL en un valor superior a 255.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3553">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="d9a09-3554">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3554">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d9a09-3555">Especifica si el socket debe utilizar únicamente el modo de E/S superpuesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3555">Specifies whether the socket should only use Overlapped I/O mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d9a09-3556">
            <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> utiliza únicamente el modo de E/S superpuesta; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3556">
              <see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d9a09-3557">El valor predeterminado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3557">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d9a09-3558">Establezca esta propiedad en `true` para un <xref:System.Net.Sockets.Socket> que piensa llamar <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3558">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="d9a09-3559">En caso contrario, el marco de trabajo puede asignar un puerto de terminación para el socket, lo que impediría el uso de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="d9a09-3559">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d9a09-3560">El socket se ha enlazado a un puerto de terminación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d9a09-3560">The socket has been bound to a completion port.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>