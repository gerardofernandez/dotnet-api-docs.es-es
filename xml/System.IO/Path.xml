<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7d6e92442757fd51d003d6e8352e0318077814f8" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58736112" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="52119-101">Ejecuta operaciones en instancias de <see cref="T:System.String" /> que contienen información de rutas de acceso de archivos o directorios.</span><span class="sxs-lookup"><span data-stu-id="52119-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="52119-102">Estas operaciones se ejecutan de forma adecuada para múltiples plataformas.</span><span class="sxs-lookup"><span data-stu-id="52119-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="52119-103">Una ruta de acceso es una cadena que proporciona la ubicación de un archivo o directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="52119-104">Una ruta de acceso no necesariamente hace referencia a una ubicación en el disco; Por ejemplo, podría asignar una ruta de acceso a una ubicación en la memoria o en un dispositivo.</span><span class="sxs-lookup"><span data-stu-id="52119-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="52119-105">El formato exacto de una ruta de acceso viene determinada por la plataforma actual.</span><span class="sxs-lookup"><span data-stu-id="52119-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="52119-106">Por ejemplo, en algunos sistemas, una ruta de acceso puede iniciar con una letra de unidad o volumen, mientras que este elemento no está presente en otros sistemas.</span><span class="sxs-lookup"><span data-stu-id="52119-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="52119-107">En algunos sistemas, las rutas de acceso de archivo pueden contener las extensiones, que indican el tipo de información almacenada en el archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="52119-108">El formato de una extensión de nombre de archivo es dependiente de la plataforma; Por ejemplo, algunos sistemas limitan las extensiones a tres caracteres, y otros no.</span><span class="sxs-lookup"><span data-stu-id="52119-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="52119-109">La plataforma actual también determina el juego de caracteres utilizado para separar los elementos de una ruta de acceso y el juego de caracteres que no se puede usar al especificar las rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="52119-110">Debido a estas diferencias, los campos de la `Path` clase, así como el comportamiento exacto de algunos miembros de la `Path` clase dependen de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="52119-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="52119-111">Una ruta de acceso puede contener información de ubicación absoluta o relativa.</span><span class="sxs-lookup"><span data-stu-id="52119-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="52119-112">Rutas de acceso absolutas totalmente especifican una ubicación: el archivo o directorio se puede identificar independientemente de la ubicación actual.</span><span class="sxs-lookup"><span data-stu-id="52119-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="52119-113">Rutas de acceso relativas especifican una ubicación parcial: la ubicación actual se usa como punto de partida al buscar un archivo especificado con una ruta de acceso relativa.</span><span class="sxs-lookup"><span data-stu-id="52119-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="52119-114">Para determinar el directorio actual, llame a <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="52119-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="52119-115">.NET core 1.1 y versiones posteriores y .NET Framework 4.6.2 y versiones posteriores también admiten el acceso a objetos de sistema de archivos que forman los nombres de dispositivo, como "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="52119-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="52119-116">Para obtener más información sobre formatos de ruta de acceso de archivo en Windows, consulte [formatos de ruta de acceso de archivo en los sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="52119-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="52119-117">La mayoría de los miembros de la `Path` clase no interactúan con el sistema de archivos y no comprueban la existencia del archivo especificado por una cadena de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="52119-118">`Path` los miembros que se modifican, como una cadena de ruta de acceso de clase <xref:System.IO.Path.ChangeExtension%2A>, no tienen ningún efecto en los nombres de archivos del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="52119-119">`Path` los miembros, sin embargo, validan el contenido de una cadena de ruta de acceso especificada y produce una <xref:System.ArgumentException> excepción si la cadena contiene caracteres que no son válidos en las cadenas de ruta de acceso, tal como se define en los caracteres devueltos por la <xref:System.IO.Path.GetInvalidPathChars%2A> método.</span><span class="sxs-lookup"><span data-stu-id="52119-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="52119-120">Por ejemplo, en plataformas de escritorio basadas en Windows, en caracteres de ruta no válida pueden incluir comillas dobles ("), menor que (\<), mayor que (>), barra vertical (&#124;), retroceso (\b), null (\0) y caracteres Unicode 16 a 18 y 20 a 25.</span><span class="sxs-lookup"><span data-stu-id="52119-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="52119-121">Los miembros de la `Path` clase permiten rápida y fácilmente realizar operaciones comunes, como determinar si una extensión de nombre de archivo forma parte de una ruta de acceso y combinar dos cadenas en un nombre de ruta.</span><span class="sxs-lookup"><span data-stu-id="52119-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="52119-122">Todos los miembros de la `Path` clase son estático y, por tanto, se puede llamar sin tener una instancia de una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="52119-123">En los miembros que aceptan una ruta de acceso como una cadena de entrada, esa ruta de acceso debe tener un formato correcto o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="52119-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="52119-124">Por ejemplo, si una ruta de acceso es un nombre completo, pero comienza con un espacio, la ruta de acceso no se recorta en los métodos de la clase.</span><span class="sxs-lookup"><span data-stu-id="52119-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="52119-125">Por lo tanto, la ruta de acceso es incorrecto y se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="52119-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="52119-126">De forma similar, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces.</span><span class="sxs-lookup"><span data-stu-id="52119-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="52119-127">Por ejemplo, "c:\temp c:\windows" también genera una excepción en la mayoría de los casos.</span><span class="sxs-lookup"><span data-stu-id="52119-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="52119-128">Asegúrese de que las rutas de acceso correctos al usar métodos que aceptan una cadena de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="52119-129">En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o simplemente un directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="52119-130">La ruta de acceso especificada también puede hacer referencia a una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura Universal (UNC) para un nombre de servidor y recurso compartido.</span><span class="sxs-lookup"><span data-stu-id="52119-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="52119-131">Por ejemplo, todo lo siguiente es las rutas de acceso aceptables:</span><span class="sxs-lookup"><span data-stu-id="52119-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="52119-132">"c:\\\MyDir\\\MyFile.txt" en C#, o "c:\MyDir\MyFile.txt" en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="52119-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="52119-133">"c:\\\MyDir" en C#, o "c:\MyDir" en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="52119-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="52119-134">"MyDir\\\MySubdir" en C#, o "Midir\misubdir" en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="52119-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="52119-135">"\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="52119-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="52119-136">Dado que todas estas operaciones se realizan en las cadenas, es imposible de comprobar que los resultados son válidos en todos los escenarios.</span><span class="sxs-lookup"><span data-stu-id="52119-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="52119-137">Por ejemplo, el <xref:System.IO.Path.GetExtension%2A> método analiza una cadena que se pasa a él y devuelve la extensión de la cadena.</span><span class="sxs-lookup"><span data-stu-id="52119-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="52119-138">Sin embargo, esto no significa que existe un archivo con dicha extensión en el disco.</span><span class="sxs-lookup"><span data-stu-id="52119-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="52119-139">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="52119-140">El ejemplo siguiente muestra algunos de los miembros principales de la `Path` clase.</span><span class="sxs-lookup"><span data-stu-id="52119-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-141">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-142">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-143">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="52119-144">Cómo: Leer y escribir en un archivo de datos recién creado</span><span class="sxs-lookup"><span data-stu-id="52119-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-145">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="52119-146">Proporciona un carácter alternativo específico de la plataforma, que se utiliza para separar niveles de directorios en una cadena de ruta de acceso que refleja una organización jerárquica del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="52119-147">Este campo puede tener el mismo valor que <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="52119-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="52119-148">`AltDirectorySeparatorChar` y <xref:System.IO.Path.DirectorySeparatorChar> son ambas válidas para separar niveles de directorios en una cadena de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="52119-149">El valor de este campo es una barra diagonal ('/') en Windows y sistemas operativos basados en Unix.</span><span class="sxs-lookup"><span data-stu-id="52119-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="52119-150">El ejemplo siguiente se muestra <xref:System.IO.Path> en Windows y en sistemas basados en Unix de valores de campo.</span><span class="sxs-lookup"><span data-stu-id="52119-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="52119-151">Tenga en cuenta que Windows admite la barra de diagonal hacia delante (que es devuelta por la <xref:System.IO.Path.AltDirectorySeparatorChar> campo) o la barra diagonal inversa (que es devuelta por la <xref:System.IO.Path.DirectorySeparatorChar> campo) como caracteres separadores de ruta de acceso, mientras que los sistemas basados en Unix admiten solo la barra diagonal.</span><span class="sxs-lookup"><span data-stu-id="52119-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-152">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-153">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-154">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-155">La información de ruta de acceso que se va a modificar.</span><span class="sxs-lookup"><span data-stu-id="52119-155">The path information to modify.</span></span> <span data-ttu-id="52119-156">La ruta de acceso no puede contener ninguno de los caracteres definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="52119-157">Nueva extensión (con o sin un punto inicial).</span><span class="sxs-lookup"><span data-stu-id="52119-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="52119-158">Especifique <see langword="null" /> para quitar una extensión existente de <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="52119-159">Cambia la extensión de una cadena de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="52119-160">Información de la ruta de acceso modificada.</span><span class="sxs-lookup"><span data-stu-id="52119-160">The modified path information.</span></span>  
  
<span data-ttu-id="52119-161">En plataformas de escritorio basadas en Windows, si <paramref name="path" /> es <see langword="null" /> o una cadena vacía (""), la información de ruta de acceso se devuelve sin modificar.</span><span class="sxs-lookup"><span data-stu-id="52119-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="52119-162">Si <paramref name="extension" /> es <see langword="null" />, la cadena devuelta contiene la ruta de acceso especificada, de la que se elimina la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="52119-163">Si <paramref name="path" /> no tiene extensión y <paramref name="extension" /> no es <see langword="null" />, la cadena de ruta de acceso devuelta contiene <paramref name="extension" /> anexado al final de <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-164">Si no `path` ni `extension` contiene un punto (.), `ChangeExtension` agrega el punto.</span><span class="sxs-lookup"><span data-stu-id="52119-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="52119-165">El `extension` parámetro puede contener varios puntos y caracteres de ruta de acceso válida y puede tener cualquier longitud.</span><span class="sxs-lookup"><span data-stu-id="52119-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="52119-166">Si `extension` es `null`, la cadena devuelta contiene el contenido de `path` con el último período y todos los caracteres siguientes eliminado.</span><span class="sxs-lookup"><span data-stu-id="52119-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="52119-167">Si `extension` es una cadena vacía, la cadena de ruta de acceso devuelta contiene el contenido de `path` los caracteres siguientes en el último período quitado.</span><span class="sxs-lookup"><span data-stu-id="52119-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="52119-168">Si `path` no tiene una extensión y `extension` no `null`, la cadena devuelta contiene `path` seguido `extension`.</span><span class="sxs-lookup"><span data-stu-id="52119-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="52119-169">Si `extension` no `null` y no tiene un punto inicial, se agrega el punto.</span><span class="sxs-lookup"><span data-stu-id="52119-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="52119-170">Si `path` contiene una extensión de varios separada por varios puntos, la cadena devuelta contiene el contenido de `path` con el último período y todos los caracteres siguientes reemplazan por `extension`.</span><span class="sxs-lookup"><span data-stu-id="52119-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="52119-171">Por ejemplo, si `path` es "\Dir1\examples\pathtests.csx.txt" y `extension` es "cs", la ruta de acceso modificada es "\Dir1\examples\pathtests.csx.cs".</span><span class="sxs-lookup"><span data-stu-id="52119-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="52119-172">No es posible comprobar que los resultados devueltos son válidos en todos los escenarios.</span><span class="sxs-lookup"><span data-stu-id="52119-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="52119-173">Por ejemplo, si `path` está vacío, `extension` se anexa.</span><span class="sxs-lookup"><span data-stu-id="52119-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="52119-174">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-175">En el ejemplo siguiente se muestra un uso de la `ChangeExtension` método.</span><span class="sxs-lookup"><span data-stu-id="52119-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-176"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-177">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-178">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-179">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-180">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="52119-181">Combina cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="52119-182">Este método está pensado para concatenar cadenas individuales en una sola cadena que representa una ruta de acceso de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="52119-183">Sin embargo, si un argumento que no sea el primero contiene una ruta de acceso raíz, se omiten los componentes de ruta de acceso anterior, y la cadena devuelta comienza con ese componente de ruta de acceso raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="52119-184">Como alternativa a la `Combine` método, considere el uso de la <xref:System.IO.Path.Join%2A> o <xref:System.IO.Path.TryJoin%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="52119-185">Este método supone que el primer argumento es una ruta de acceso absoluta y que el argumento o argumentos siguientes son rutas de acceso relativas.</span><span class="sxs-lookup"><span data-stu-id="52119-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="52119-186">Si esto no es el caso, y especialmente si los argumentos subsiguientes son cadenas escritas por el usuario, llame a la <xref:System.IO.Path.Join%2A> o <xref:System.IO.Path.TryJoin%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="52119-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="52119-187">Matriz de elementos de la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="52119-188">Combina una matriz de cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="52119-189">Rutas de acceso combinadas.</span><span class="sxs-lookup"><span data-stu-id="52119-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="52119-190">`paths` debe ser una matriz de las partes de la ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="52119-191">Si una de las siguientes rutas de acceso es una ruta de acceso absoluta, la operación de combinación restablece a partir de esa ruta de acceso absoluta, descartando todas las rutas de acceso combinadas anteriores.</span><span class="sxs-lookup"><span data-stu-id="52119-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="52119-192">Si cualquier elemento de `paths` pero no es una unidad de la última de ellas y no termina con cualquiera el <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar> carácter, el `Combine` método agrega un <xref:System.IO.Path.DirectorySeparatorChar> carácter entre ese elemento y la siguiente.</span><span class="sxs-lookup"><span data-stu-id="52119-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="52119-193">Tenga en cuenta que, si el elemento termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Combine` método conserva el carácter separador de ruta de acceso original y anexa uno compatible.</span><span class="sxs-lookup"><span data-stu-id="52119-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="52119-194">El ejemplo siguiente compara el resultado en Windows y sistemas basados en Unix cuando se utiliza la barra diagonal inversa como un carácter separador de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="52119-195">Cadenas de longitud cero se omiten de la ruta de acceso combinada.</span><span class="sxs-lookup"><span data-stu-id="52119-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="52119-196">Los parámetros no se analizan si tienen espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="52119-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="52119-197">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Combine` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-198">Por ejemplo, mientras `Path.Combine("c:\\", "*.txt")` podría no ser válido si fuera a crear un archivo a partir de él, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="52119-199">Por lo tanto, se interpreta correctamente por el `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="52119-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="52119-200">El ejemplo siguiente combina una matriz de cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-201">Una de las cadenas de la matriz contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-202">Una de las cadenas de la matriz es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-203">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-204">Primera ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-205">Segunda ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="52119-206">Combina dos cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="52119-207">Rutas de acceso combinadas.</span><span class="sxs-lookup"><span data-stu-id="52119-207">The combined paths.</span></span> <span data-ttu-id="52119-208">Si una de las rutas de acceso especificadas es una cadena de longitud cero, este método devuelve la otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="52119-209">Si <paramref name="path2" /> contiene una ruta de acceso absoluta, este método devuelve <paramref name="path2" />.</span><span class="sxs-lookup"><span data-stu-id="52119-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-210">Si `path1` no es una referencia de la unidad (es decir, "C:" o "D:") y no termina con un carácter separador válido tal como se define en <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> se anexa a `path1` antes de la concatenación.</span><span class="sxs-lookup"><span data-stu-id="52119-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="52119-211">Observe que si `path1` termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Combine` método conserva el carácter separador de ruta de acceso original y anexa uno compatible.</span><span class="sxs-lookup"><span data-stu-id="52119-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="52119-212">El ejemplo siguiente compara el resultado en Windows y sistemas basados en Unix cuando se utiliza la barra diagonal inversa como un carácter separador de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="52119-213">Si `path2` no incluye una raíz (por ejemplo, si `path2` no empieza por un carácter separador o una especificación de unidad), el resultado es una concatenación de las dos rutas de acceso, con un carácter separador intermedio.</span><span class="sxs-lookup"><span data-stu-id="52119-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="52119-214">Si `path2` incluye una raíz, `path2` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="52119-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="52119-215">Los parámetros no se analizan si tienen espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="52119-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="52119-216">Por lo tanto, si `path2` incluye espacios en blanco (por ejemplo, "\file.txt"), el <xref:System.IO.Path.Combine%2A> método anexa `path2` a `path1` en lugar de devolver sólo `path2`.</span><span class="sxs-lookup"><span data-stu-id="52119-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="52119-217">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Combine` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-218">Por ejemplo, mientras `Path.Combine("c:\\", "*.txt")` podría no ser válido si fuera a crear un archivo a partir de él, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="52119-219">Por lo tanto, se interpreta correctamente por el `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="52119-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="52119-220">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-221">El ejemplo siguiente se muestra cómo utilizar el `Combine` método en una plataforma de escritorio basada en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-222"><paramref name="path1" /> o <paramref name="path2" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-223"><paramref name="path1" /> o <paramref name="path2" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-224">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-225">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-226">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-227">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-228">Primera ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-229">Segunda ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="52119-230">Tercera ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="52119-231">Combina tres cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="52119-232">Rutas de acceso combinadas.</span><span class="sxs-lookup"><span data-stu-id="52119-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-233">`path1` debe ser una ruta de acceso absoluta (por ejemplo, "d:\archives" o "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="52119-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="52119-234">Si `path2` o `path3` también es una ruta de acceso absoluta, el combinar operación descartes combinados todos los trazados y restablece a esa ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="52119-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="52119-235">Cadenas de longitud cero se omiten de la ruta de acceso combinada.</span><span class="sxs-lookup"><span data-stu-id="52119-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="52119-236">Si `path1` o `path2` no es una referencia de la unidad (es decir, "C:" o "D:") y no termina con un carácter separador válido tal como se define en <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> se anexa a `path1` o `path2` antes de la concatenación.</span><span class="sxs-lookup"><span data-stu-id="52119-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="52119-237">Observe que si `path1` o `path2` termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Combine` método conserva el carácter separador de ruta de acceso original y anexa uno compatible.</span><span class="sxs-lookup"><span data-stu-id="52119-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="52119-238">El ejemplo siguiente compara el resultado en Windows y sistemas basados en Unix cuando se utiliza la barra diagonal inversa como un carácter separador de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="52119-239">Si `path2` no incluye una raíz (por ejemplo, si `path2` no empieza por un carácter separador o una especificación de unidad), el resultado es una concatenación de las dos rutas de acceso, con un carácter separador intermedio.</span><span class="sxs-lookup"><span data-stu-id="52119-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="52119-240">Si `path2` incluye una raíz, `path2` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="52119-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="52119-241">Los parámetros no se analizan si tienen espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="52119-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="52119-242">Por lo tanto, si `path2` incluye espacios en blanco (por ejemplo, "\file.txt"), el <xref:System.IO.Path.Combine%2A> método anexa `path2` a `path1`.</span><span class="sxs-lookup"><span data-stu-id="52119-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="52119-243">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Combine` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-244">Por ejemplo, mientras `Path.Combine("c:\\", "*.txt")` podría no ser válido si fuera a crear un archivo a partir de él, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="52119-245">Por lo tanto, se interpreta correctamente por el `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="52119-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-246">El ejemplo siguiente combina tres rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-247"><paramref name="path1" />, <paramref name="path2" /> o <paramref name="path3" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-248"><paramref name="path1" />, <paramref name="path2" /> o <paramref name="path3" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-249">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-250">Primera ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-251">Segunda ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="52119-252">Tercera ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="52119-253">Cuarta ruta de acceso que se va a combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="52119-254">Combina cuatro cadenas en una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="52119-255">Rutas de acceso combinadas.</span><span class="sxs-lookup"><span data-stu-id="52119-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-256">`path1` debe ser una ruta de acceso absoluta (por ejemplo, "d:\archives" o "\\\archives\public"). Si una de las siguientes rutas de acceso también es una ruta de acceso absoluta, la operación de combinación descarta todas las rutas de acceso combinadas previamente y se restablece a esa ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="52119-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="52119-257">Cadenas de longitud cero se omiten de la ruta de acceso combinada.</span><span class="sxs-lookup"><span data-stu-id="52119-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="52119-258">Si `path1`, `path2`, o `path3` no es una referencia de la unidad (es decir, "C:" o "D:") y no termina con un carácter separador válido tal como se define en <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> se anexa a él antes de la concatenación.</span><span class="sxs-lookup"><span data-stu-id="52119-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="52119-259">Observe que si `path1`, `path2`, o `path3` termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Combine` método conserva el carácter separador de ruta de acceso original y anexa uno compatible.</span><span class="sxs-lookup"><span data-stu-id="52119-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="52119-260">El ejemplo siguiente compara el resultado en Windows y sistemas basados en Unix cuando se utiliza la barra diagonal inversa como un carácter separador de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="52119-261">Si `path2` no incluye una raíz (por ejemplo, si `path2` no empieza por un carácter separador o una especificación de unidad), el resultado es una concatenación de las dos rutas de acceso, con un carácter separador intermedio.</span><span class="sxs-lookup"><span data-stu-id="52119-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="52119-262">Si `path2` incluye una raíz, `path2` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="52119-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="52119-263">Los parámetros no se analizan si tienen espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="52119-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="52119-264">Por lo tanto, si `path2` incluye espacios en blanco (por ejemplo, "\file.txt"), el <xref:System.IO.Path.Combine%2A> método anexa `path2` a `path1`.</span><span class="sxs-lookup"><span data-stu-id="52119-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="52119-265">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Combine` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-266">Por ejemplo, mientras `Path.Combine("c:\\", "*.txt")` podría no ser válido si fuera a crear un archivo a partir de él, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="52119-267">Por lo tanto, se interpreta correctamente por el `Combine` método.</span><span class="sxs-lookup"><span data-stu-id="52119-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-268">El ejemplo siguiente combina cuatro rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> o <paramref name="path4" /> contiene uno o varios de los caracteres no válidos que se definen en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> o <paramref name="path4" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-271">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="52119-272">Proporciona un carácter específico de la plataforma, que se utiliza para separar niveles de directorios en una cadena de ruta de acceso que refleja una organización jerárquica del sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="52119-273"><xref:System.IO.Path.AltDirectorySeparatorChar> y `DirectorySeparatorChar` son ambas válidas para separar niveles de directorios en una cadena de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="52119-274">Cuando se usa .NET Core para desarrollar aplicaciones que se ejecutan en varias plataformas:</span><span class="sxs-lookup"><span data-stu-id="52119-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="52119-275">Si prefiere codificar el carácter separador de directorio, debe usar la barra diagonal (`/`) caracteres.</span><span class="sxs-lookup"><span data-stu-id="52119-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="52119-276">Es el carácter de separador de directorio reconocido sólo en sistemas Unix, como el ejemplo se muestra la salida y es el <xref:System.IO.Path.AltDirectorySeparatorChar> en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="52119-277">Utilice la concatenación de cadenas para dinámicamente, recupere el carácter de separador de ruta de acceso en tiempo de ejecución e incorporarlo a rutas de acceso de archivo del sistema.</span><span class="sxs-lookup"><span data-stu-id="52119-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="52119-278">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="52119-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="52119-279">También puede recuperar el valor de la <xref:System.IO.Path.AltDirectorySeparatorChar> propiedad, ya que es el mismo en Windows y sistemas basados en Unx.</span><span class="sxs-lookup"><span data-stu-id="52119-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="52119-280">Recuperar el <xref:System.IO.Path.AltDirectorySeparatorChar> propiedad</span><span class="sxs-lookup"><span data-stu-id="52119-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="52119-281">Si la aplicación no es multiplataforma, puede utilizar el separador adecuado para su sistema.</span><span class="sxs-lookup"><span data-stu-id="52119-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="52119-282">El ejemplo siguiente se muestra <xref:System.IO.Path> en Windows y en sistemas basados en Unix de valores de campo.</span><span class="sxs-lookup"><span data-stu-id="52119-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="52119-283">Tenga en cuenta que Windows admite la barra de diagonal hacia delante (que es devuelta por la <xref:System.IO.Path.AltDirectorySeparatorChar> campo) o la barra diagonal inversa (que es devuelta por la <xref:System.IO.Path.DirectorySeparatorChar> campo) como caracteres separadores de ruta de acceso, mientras que los sistemas basados en Unix admiten solo la barra diagonal.</span><span class="sxs-lookup"><span data-stu-id="52119-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-284">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-285">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-286">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-287">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="52119-288">Devuelve la información de directorio para la ruta de acceso especificada representada por un intervalo de caracteres.</span><span class="sxs-lookup"><span data-stu-id="52119-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="52119-289">La información de directorio para <paramref name="path" />, o un intervalo vacío si <paramref name="path" /> es <see langword="null" />, un intervalo vacío o una raíz (como \, C:, o \\servidor\recurso compartido).</span><span class="sxs-lookup"><span data-stu-id="52119-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-290">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-291">Ruta de acceso de un archivo o directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="52119-292">Devuelve la información de directorio para la cadena de ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="52119-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="52119-293">Información de directorio para <paramref name="path" />, o <see langword="null" /> si <paramref name="path" /> denota un directorio raíz o es null.</span><span class="sxs-lookup"><span data-stu-id="52119-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="52119-294">Devuelve <see cref="F:System.String.Empty" /> si <paramref name="path" /> no contiene información sobre directorios.</span><span class="sxs-lookup"><span data-stu-id="52119-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-295">En la mayoría de los casos, la cadena devuelta por este método consta de todos los caracteres de la ruta de acceso hasta, pero sin incluir el último <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="52119-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="52119-296">Si la ruta de acceso consta de un directorio raíz, como "c:\\", se devuelve null.</span><span class="sxs-lookup"><span data-stu-id="52119-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="52119-297">Tenga en cuenta que este método no admite rutas de acceso con "archivo:".</span><span class="sxs-lookup"><span data-stu-id="52119-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="52119-298">Dado que la ruta de acceso devuelta no incluye el <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, pasando la ruta de acceso devuelta de nuevo en el <xref:System.IO.Path.GetDirectoryName%2A> método producirá el truncamiento de nivel de una carpeta por cada llamada posterior en la cadena de resultado.</span><span class="sxs-lookup"><span data-stu-id="52119-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="52119-299">Por ejemplo, al pasar la ruta de acceso "C:\Directory\SubDirectory\test.txt" en el <xref:System.IO.Path.GetDirectoryName%2A> método devolverá "C:\Directory\SubDirectory".</span><span class="sxs-lookup"><span data-stu-id="52119-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="52119-300">Pasar esa cadena, "C:\Directory\SubDirectory", <xref:System.IO.Path.GetDirectoryName%2A> dará como resultado "C:\Directory".</span><span class="sxs-lookup"><span data-stu-id="52119-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="52119-301">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-302">El ejemplo siguiente se muestra cómo utilizar el `GetDirectoryName` método en una plataforma de escritorio basada en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-303">El parámetro <paramref name="path" /> contiene caracteres no válidos, está vacío o solo contiene espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="52119-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="52119-304">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="52119-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="52119-305">El parámetro <paramref name="path" /> es superior a la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="52119-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-306">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-307">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-308">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-309">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-310">La ruta de acceso del archivo de la cual se obtiene la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="52119-311">Devuelve la extensión de una ruta de acceso de archivo que se representa mediante un intervalo de caracteres de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="52119-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="52119-312">La extensión de la ruta de acceso especificada (incluido el punto "."), o <see cref="P:System.ReadOnlySpan`1.Empty" /> si <paramref name="path" /> no tiene información de la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="52119-313">Este método obtiene la extensión de `path` buscando `path` durante un período ("."), empezando en el último carácter del intervalo de solo lectura y continuando hacia su primer carácter.</span><span class="sxs-lookup"><span data-stu-id="52119-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="52119-314">Si se encuentra un punto antes de un <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar> carácter, el intervalo de solo lectura devuelto contiene el período y los caracteres siguientes; en caso contrario, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> se devuelve.</span><span class="sxs-lookup"><span data-stu-id="52119-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-315">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-316">Cadena de ruta de acceso de la cual se obtiene la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="52119-317">Devuelve la extensión de la cadena de ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="52119-317">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="52119-318">Extensión de la ruta de acceso especificada (incluido el punto "."), <see langword="null" /> o <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="52119-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="52119-319">Si <paramref name="path" /> es <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="52119-320">Si <paramref name="path" /> no tiene información de extensión, <see cref="M:System.IO.Path.GetExtension(System.String)" /> devuelve <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="52119-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="52119-321">Este método obtiene la extensión de `path` buscando `path` para un punto (.), empezando por el último carácter de `path` y continuando hacia el primer carácter.</span><span class="sxs-lookup"><span data-stu-id="52119-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="52119-322">Si se encuentra un punto antes de un <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar> caracteres, la cadena devuelta contiene el período y los caracteres después de él; de lo contrario, <xref:System.String.Empty?displayProperty=nameWithType> se devuelve.</span><span class="sxs-lookup"><span data-stu-id="52119-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="52119-323">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="52119-324">El ejemplo siguiente se muestra cómo utilizar el `GetExtension` método en una plataforma de escritorio basada en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-325"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-326">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-327">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-328">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-329">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-330">Un intervalo de solo lectura que contiene la ruta de acceso de la cual se obtiene el nombre de archivo y la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="52119-331">Devuelve el nombre de archivo y la extensión de una ruta de acceso de archivo que se representa mediante un intervalo de caracteres de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="52119-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="52119-332">Caracteres que siguen al último carácter separador de directorio en <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="52119-333">El intervalo de solo lectura devuelto contiene los caracteres de la ruta de acceso que siguen al último separador en `path`.</span><span class="sxs-lookup"><span data-stu-id="52119-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="52119-334">Si el último carácter de `path` es un carácter separador de volumen o de directorio, el método devuelve <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="52119-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="52119-335">Si `path` no contiene ningún carácter separador, devuelve el método `path`.</span><span class="sxs-lookup"><span data-stu-id="52119-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-336">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-337">Cadena de ruta de acceso de la cual se obtiene el nombre de archivo y la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="52119-338">Devuelve el nombre de archivo y la extensión de la cadena de ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="52119-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="52119-339">Caracteres que siguen al último carácter separador de directorio en <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="52119-340">Si el último carácter de <paramref name="path" /> es un carácter separador de directorios o volúmenes, este método devuelve <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="52119-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="52119-341">Si <paramref name="path" /> es <see langword="null" /> este método devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="52119-342">El valor devuelto es `null` si es la ruta de acceso del archivo `null`.</span><span class="sxs-lookup"><span data-stu-id="52119-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="52119-343">Los caracteres separadores usados para determinar el inicio del nombre de archivo son <xref:System.IO.Path.DirectorySeparatorChar> y <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="52119-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="52119-344">Dado que *\\* es un nombre de archivo válido en Unix, `GetFileName` que se ejecuta en plataformas basadas en Unix correctamente no puede devolver el nombre de archivo de un Windows = basada en ruta de acceso como *C:\\mydir\\myfile.ext*, pero `GetFileName` que se ejecuta en plataformas basadas en Windows, puede devolver correctamente el nombre de archivo desde una ruta de acceso basado en Unix como */tmp/myfile.ext*, por lo que el comportamiento de la `GetFileName` método no es estrictamente el mismo en plataformas Unix y Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows=based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="52119-345">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-346">En el ejemplo siguiente se muestra el comportamiento de la `GetFileName` método en una plataforma de escritorio basada en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-347"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-348">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-349">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-350">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-351">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-352">Un intervalo de solo lectura que contiene la ruta de acceso de la cual se obtiene el nombre de archivo sin la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="52119-353">Devuelve el nombre de archivo sin la extensión de una ruta de acceso de archivo que se representa mediante un intervalo de caracteres de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="52119-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="52119-354">Los caracteres del intervalo de solo lectura devueltos por <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, menos el último punto (.) y todos los caracteres siguientes.</span><span class="sxs-lookup"><span data-stu-id="52119-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-355">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-356">Ruta de acceso del archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="52119-357">Devuelve el nombre de archivo y la cadena de ruta de acceso especificada sin la extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="52119-358">La cadena devuelta por <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, menos el último punto (.) y todos los caracteres siguientes.</span><span class="sxs-lookup"><span data-stu-id="52119-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-359">Este método no comprueba que existe el nombre de archivo o ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="52119-360">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-361">En el ejemplo siguiente se muestra un uso de la `GetFileNameWithoutExtension` método.</span><span class="sxs-lookup"><span data-stu-id="52119-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-362"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-363">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-364">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-365">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-366">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-367">El archivo o directorio para el que se va a obtener información de la ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="52119-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="52119-368">Devuelve la ruta de acceso absoluta para la cadena de ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="52119-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="52119-369">Ubicación completa de <paramref name="path" />, como "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="52119-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="52119-370">La ruta de acceso absoluta incluye toda la información necesaria para buscar un archivo o directorio en un sistema.</span><span class="sxs-lookup"><span data-stu-id="52119-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="52119-371">El archivo o directorio especificado por `path` no es necesario que exista.</span><span class="sxs-lookup"><span data-stu-id="52119-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="52119-372">Por ejemplo, si *c:\temp\newdir* es el directorio actual, una llamada a `GetFullPath` en un nombre de archivo, como *test.txt* devuelve *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="52119-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="52119-373">No es necesario que exista el archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="52119-374">Si `path` es una ruta de acceso relativa, esta sobrecarga devuelve una ruta de acceso completa que puede basarse en la unidad actual y el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="52119-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="52119-375">Pueden cambiar la unidad actual y el directorio actual en cualquier momento mientras se ejecuta una aplicación.</span><span class="sxs-lookup"><span data-stu-id="52119-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="52119-376">Como resultado, la ruta de acceso devuelta por esta sobrecarga no se puede determinar de antemano.</span><span class="sxs-lookup"><span data-stu-id="52119-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="52119-377">Para devolver una ruta de acceso determinista, llame a la <xref:System.IO.Path.GetFullPath(System.String,System.String)> de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="52119-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="52119-378">También puede llamar a la <xref:System.IO.Path.IsPathFullyQualified%2A> método para determinar si una ruta de acceso es completa o relativa y, por tanto, si una llamada a `GetFullPath` es necesario.</span><span class="sxs-lookup"><span data-stu-id="52119-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="52119-379">Sin embargo, si `path` existe, el llamador debe tener permiso para obtener información de ruta de acceso para `path`.</span><span class="sxs-lookup"><span data-stu-id="52119-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="52119-380">Tenga en cuenta que a diferencia de la mayoría de los miembros de la <xref:System.IO.Path> (clase), este método tiene acceso al sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="52119-381">Este método usa el directorio actual y la información de volumen actual para calificar totalmente `path`.</span><span class="sxs-lookup"><span data-stu-id="52119-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="52119-382">Si especifica un archivo únicamente en el nombre `path`, `GetFullPath` devuelve la ruta de acceso completa del directorio actual.</span><span class="sxs-lookup"><span data-stu-id="52119-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="52119-383">Si se pasa en un nombre de archivo corto, se expande a un nombre de archivo largo.</span><span class="sxs-lookup"><span data-stu-id="52119-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="52119-384">Si una ruta de acceso no contiene caracteres significativos, no es válido a menos que contenga uno o más "." caracteres seguidos de cualquier número de espacios; a continuación, se analizará como "."o"..".</span><span class="sxs-lookup"><span data-stu-id="52119-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="52119-385">.NET core 1.1 y versiones posteriores y .NET Framework 4.6.2 y versiones posteriores también admiten las rutas de acceso que incluyen los nombres de dispositivo, como "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="52119-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="52119-386">Para obtener más información sobre formatos de ruta de acceso de archivo en Windows, consulte [formatos de ruta de acceso de archivo en los sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="52119-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="52119-387">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="52119-388">En el ejemplo siguiente se muestra el `GetFullPath` método en una plataforma de escritorio basada en Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-389"><paramref name="path" /> es una cadena de longitud cero, contiene solo espacios en blanco o contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="52119-390">O bien</span><span class="sxs-lookup"><span data-stu-id="52119-390">-or-</span></span> 
<span data-ttu-id="52119-391">El sistema no pudo recuperar la ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="52119-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="52119-392">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="52119-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-393"><paramref name="path" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="52119-394"><paramref name="path" /> contiene un carácter de dos puntos (":") que no forma parte de un identificador de volumen (por ejemplo, "c:\\").</span><span class="sxs-lookup"><span data-stu-id="52119-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="52119-395">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="52119-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="52119-396">Para obtener acceso a la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-397">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-398">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-399">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-400">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-401">Una ruta de acceso relativa para concatenar en <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="52119-401">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="52119-402">El principio de una ruta de acceso completa.</span><span class="sxs-lookup"><span data-stu-id="52119-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="52119-403">Devuelve una ruta de acceso absoluta a partir de una ruta de acceso base completa y una ruta de acceso relativa.</span><span class="sxs-lookup"><span data-stu-id="52119-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="52119-404">La ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="52119-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="52119-405">Si `path` es una ruta de acceso vacía, el método devuelve `basePath`.</span><span class="sxs-lookup"><span data-stu-id="52119-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="52119-406">Si `path` es una ruta de acceso completa, el método pasa `path` a la <xref:System.IO.Path.GetFullPath(System.String)> método y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="52119-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="52119-407">Utilice este método para devolver una ruta de acceso determinista en función de un volumen especificado y con raíz directorio cuando se usa rutas de acceso relativas.</span><span class="sxs-lookup"><span data-stu-id="52119-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="52119-408">Mediante una plantilla predeterminada `basePath` en lugar de uno basado en las restricciones de directorio unidad actual frente a las rutas de acceso de archivo no deseados debidos a cambios inesperados en la unidad actual y el directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="52119-409">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="52119-409">Example</span></span>

<span data-ttu-id="52119-410">En el ejemplo siguiente se define una variable, `basePath`, para representar el directorio actual de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="52119-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="52119-411">A continuación, pasa a la `GetFullPath` método para obtener una ruta de acceso completa al directorio de datos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="52119-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-412"><paramref name="path" /> o <paramref name="basePath" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-413"><paramref name="basePath" /> no es una ruta de acceso completa.</span><span class="sxs-lookup"><span data-stu-id="52119-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="52119-414">O bien</span><span class="sxs-lookup"><span data-stu-id="52119-414">-or-</span></span>

<span data-ttu-id="52119-415"><paramref name="path" /> o <paramref name="basePath" /> contiene caracteres de ruta no válidos, como U+0000.</span><span class="sxs-lookup"><span data-stu-id="52119-415"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="52119-416">Obtiene una matriz que contiene los caracteres no permitidos en los nombres de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-416">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="52119-417">Matriz que contiene los caracteres no permitidos en los nombres de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-417">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-418">La matriz que devuelve este método no se garantiza que contenga el conjunto completo de caracteres que no son válidos en nombres de archivo y directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-418">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="52119-419">El conjunto completo de caracteres no válidos puede variar según el sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-419">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="52119-420">Por ejemplo, en plataformas de escritorio basadas en Windows, en caracteres de ruta no válida pueden incluir caracteres ASCII/Unicode del 1 al 31, así como comillas ("), menor que (\<), mayor que (>), barra vertical (&#124;), retroceso (\b), null (\0) y tabulación (\t).</span><span class="sxs-lookup"><span data-stu-id="52119-420">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-421">En el ejemplo siguiente se muestra el <xref:System.IO.Path.GetInvalidFileNameChars%2A> método y el <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar los caracteres no válidos.</span><span class="sxs-lookup"><span data-stu-id="52119-421">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="52119-422">Obtiene una matriz que contiene los caracteres no permitidos en los nombres de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-422">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="52119-423">Matriz que contiene los caracteres no permitidos en los nombres de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-423">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-424">La matriz que devuelve este método no se garantiza que contenga el conjunto completo de caracteres que no son válidos en nombres de archivo y directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-424">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="52119-425">El conjunto completo de caracteres no válidos puede variar según el sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-425">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="52119-426">Por ejemplo, en plataformas de escritorio basadas en Windows, en caracteres de ruta no válida pueden incluir caracteres ASCII/Unicode del 1 al 31, así como comillas ("), menor que (\<), mayor que (>), barra vertical (&#124;), retroceso (\b), null (\0) y tabulación (\t).</span><span class="sxs-lookup"><span data-stu-id="52119-426">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-427">En el ejemplo siguiente se muestra el <xref:System.IO.Path.GetInvalidFileNameChars%2A> método y el <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar los caracteres no válidos.</span><span class="sxs-lookup"><span data-stu-id="52119-427">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-428">Ruta de acceso de la que se obtiene información de directorio raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-428">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="52119-429">Obtiene la información del directorio raíz de la ruta de acceso contenida en el intervalo de caracteres especificado.</span><span class="sxs-lookup"><span data-stu-id="52119-429">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="52119-430">Un intervalo de caracteres que contiene el directorio raíz de `path`.</span><span class="sxs-lookup"><span data-stu-id="52119-430">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-431">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-431">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-432">Ruta de acceso de la que se obtiene información de directorio raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-432">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="52119-433">Obtiene información del directorio raíz de la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="52119-433">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="52119-434">El directorio raíz de <paramref name="path" />, o <see langword="null" /> si <paramref name="path" /> es <see langword="null" />, o una cadena vacía si <paramref name="path" /> no contiene información del directorio raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-434">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-435">Este método no comprueba que existe el nombre de archivo o ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-435">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="52119-436">Patrones posibles para la cadena devuelta por este método son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="52119-436">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="52119-437">Una cadena vacía (`path` especifica una ruta de acceso relativa en la unidad o volumen actual).</span><span class="sxs-lookup"><span data-stu-id="52119-437">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="52119-438">"\" (`path` especificó una ruta de acceso absoluta en la unidad actual).</span><span class="sxs-lookup"><span data-stu-id="52119-438">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="52119-439">"X:" (`path` especificó una ruta de acceso relativa en una unidad, donde X representa una letra de unidad o volumen).</span><span class="sxs-lookup"><span data-stu-id="52119-439">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="52119-440">"X:\" (`path` especifica una ruta de acceso absoluta en una unidad determinada).</span><span class="sxs-lookup"><span data-stu-id="52119-440">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="52119-441">"\\\ComputerName\SharedFolder" (una ruta de acceso UNC).</span><span class="sxs-lookup"><span data-stu-id="52119-441">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="52119-442">"\\? \C:" (una dispositivo ruta de DOS, compatibles con .NET Core 1.1 y versiones posteriores y .NET Framework 4.6.2 y versiones posteriores)</span><span class="sxs-lookup"><span data-stu-id="52119-442">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="52119-443">Para obtener más información sobre las rutas de acceso de archivo en Windows, consulte [formatos de ruta de acceso de archivo en los sistemas Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="52119-443">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="52119-444">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-444">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="52119-445">En el ejemplo siguiente se muestra un uso de la `GetPathRoot` método.</span><span class="sxs-lookup"><span data-stu-id="52119-445">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-446"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-446"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="52119-447">O bien</span><span class="sxs-lookup"><span data-stu-id="52119-447">-or-</span></span> 
 <span data-ttu-id="52119-448">se pasó <see cref="F:System.String.Empty" /> a <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-448"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-449">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-449">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-450">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-450">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-451">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-451">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-452">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-452">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="52119-453">Devuelve un nombre de carpeta o de archivo aleatorio.</span><span class="sxs-lookup"><span data-stu-id="52119-453">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="52119-454">Nombre de carpeta o de archivo aleatorio.</span><span class="sxs-lookup"><span data-stu-id="52119-454">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-455">El <xref:System.IO.Path.GetRandomFileName%2A> método devuelve una cadena aleatoria criptográficamente segura que puede usarse como un nombre de carpeta o un nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-455">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="52119-456">A diferencia de <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> no crea un archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-456">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="52119-457">Cuando la seguridad del sistema de archivos es primordial, este método debería usarse en lugar de <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="52119-457">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-458">El ejemplo siguiente se muestra la salida desde el <xref:System.IO.Path.GetRandomFileName%2A> método.</span><span class="sxs-lookup"><span data-stu-id="52119-458">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="52119-459">La ruta de acceso de origen a la que el resultado debe ser relativo.</span><span class="sxs-lookup"><span data-stu-id="52119-459">The source path the result should be relative to.</span></span> <span data-ttu-id="52119-460">Esta ruta de acceso siempre se considera un directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-460">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="52119-461">La ruta de acceso de destino.</span><span class="sxs-lookup"><span data-stu-id="52119-461">The destination path.</span></span></param>
        <summary><span data-ttu-id="52119-462">Devuelve una ruta de acceso relativa a partir de una ruta de acceso a otra.</span><span class="sxs-lookup"><span data-stu-id="52119-462">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="52119-463">La ruta de acceso relativa, o <paramref name="path" /> si las rutas de acceso no comparten la misma raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-463">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="52119-464">Las rutas de acceso se resuelven mediante una llamada a la <xref:System.IO.Path.GetFullPath%2A> método antes de calcular la diferencia.</span><span class="sxs-lookup"><span data-stu-id="52119-464">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="52119-465">El método usa la comparación de ruta de acceso de archivo predeterminada para la plataforma actual (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> para Windows y MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> para Linux.</span><span class="sxs-lookup"><span data-stu-id="52119-465">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-466"><paramref name="relativeTo" /> o <paramref name="path" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-466"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-467">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-467">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="52119-468">Crea un archivo temporal de cero bytes y nombre único en el disco y devuelve la ruta de acceso completa a ese archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-468">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="52119-469">Ruta de acceso completa del archivo temporal.</span><span class="sxs-lookup"><span data-stu-id="52119-469">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-470">Este método crea un archivo temporal con una. Extensión de archivo TMP.</span><span class="sxs-lookup"><span data-stu-id="52119-470">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="52119-471">El archivo temporal se crea dentro de la carpeta temporal del usuario, que es la ruta de acceso devuelta por la <xref:System.IO.Path.GetTempPath%2A> método.</span><span class="sxs-lookup"><span data-stu-id="52119-471">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="52119-472">El <xref:System.IO.Path.GetTempFileName%2A> método producirá una <xref:System.IO.IOException> si se usa para crear más de 65535 archivos sin eliminar los archivos temporales anteriores.</span><span class="sxs-lookup"><span data-stu-id="52119-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="52119-473">El <xref:System.IO.Path.GetTempFileName%2A> método producirá una <xref:System.IO.IOException> si está disponible ningún nombre de archivo temporal único.</span><span class="sxs-lookup"><span data-stu-id="52119-473">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="52119-474">Para resolver este error, elimine todos los archivos temporales.</span><span class="sxs-lookup"><span data-stu-id="52119-474">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="52119-475">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-475">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="52119-476">Se produce un error de E/S, por ejemplo, no está disponible ningún nombre de archivo temporal único.</span><span class="sxs-lookup"><span data-stu-id="52119-476">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="52119-477">O bien</span><span class="sxs-lookup"><span data-stu-id="52119-477">-or-</span></span> 
<span data-ttu-id="52119-478">Este método no ha podido crear un archivo temporal.</span><span class="sxs-lookup"><span data-stu-id="52119-478">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="52119-479">para escribir en el directorio temporal.</span><span class="sxs-lookup"><span data-stu-id="52119-479">for writing to the temporary directory.</span></span> <span data-ttu-id="52119-480">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="52119-480">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-481">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-481">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-482">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-482">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-483">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-483">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="52119-484">Devuelve la ruta de acceso de la carpeta temporal del usuario actual.</span><span class="sxs-lookup"><span data-stu-id="52119-484">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="52119-485">Ruta de acceso a la carpeta temporal, que termina con una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="52119-485">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-486">Este método comprueba la existencia de variables de entorno en el orden siguiente y usa la primera ruta de acceso que se encuentra:</span><span class="sxs-lookup"><span data-stu-id="52119-486">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="52119-487">La ruta de acceso especificada por la variable de entorno TMP.</span><span class="sxs-lookup"><span data-stu-id="52119-487">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="52119-488">La ruta de acceso especificada por la variable de entorno TEMP.</span><span class="sxs-lookup"><span data-stu-id="52119-488">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="52119-489">La ruta de acceso especificada por la variable de entorno USERPROFILE.</span><span class="sxs-lookup"><span data-stu-id="52119-489">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="52119-490">El directorio de Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-490">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-491">El siguiente código muestra cómo llamar al método <xref:System.IO.Path.GetTempPath%2A>.</span><span class="sxs-lookup"><span data-stu-id="52119-491">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="52119-492">En este ejemplo genera una salida similar al siguiente.</span><span class="sxs-lookup"><span data-stu-id="52119-492">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="52119-493">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="52119-493">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="52119-494">Para obtener acceso sin restricciones a las variables de entorno.</span><span class="sxs-lookup"><span data-stu-id="52119-494">for unrestricted access to environment variables.</span></span> <span data-ttu-id="52119-495">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="52119-495">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-496">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-496">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-497">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-497">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-498">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-498">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-499">Ruta de acceso donde se busca una extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-499">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="52119-500">Determina si la ruta de acceso representada por el intervalo de caracteres especificado incluye una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-500">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="52119-501"><see langword="true" /> si los caracteres que siguen al último carácter separador de directorio o separador de volumen en la ruta de acceso incluyen un punto (".") seguido de uno o más caracteres; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-501"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="52119-502">Un punto final en `path` no se considera una extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-502">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-503">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-503">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-504">Ruta de acceso donde se busca una extensión.</span><span class="sxs-lookup"><span data-stu-id="52119-504">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="52119-505">Determina si una ruta de acceso incluye una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-505">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="52119-506">Es <see langword="true" /> si los caracteres que siguen al último separador de directorio (\\\ o /) o separador de volumen (:) en la ruta de acceso incluyen un punto (.) seguido de uno o más caracteres; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-506"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-507">A partir del final de `path`, este método busca un punto (.) seguido de al menos un carácter.</span><span class="sxs-lookup"><span data-stu-id="52119-507">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="52119-508">Si este patrón se encuentra antes un <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, o <xref:System.IO.Path.VolumeSeparatorChar> carácter se encuentra, este método devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="52119-508">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="52119-509">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-509">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-510">En el siguiente ejemplo se muestra el uso del método `HasExtension`.</span><span class="sxs-lookup"><span data-stu-id="52119-510">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-511"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-511"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-512">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-512">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-513">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-514">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-515">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="52119-516">Proporciona una matriz de caracteres, específica de la plataforma, que no pueden especificarse en argumentos de cadena de ruta de acceso que se pasen a miembros de la clase <see cref="T:System.IO.Path" />.</span><span class="sxs-lookup"><span data-stu-id="52119-516">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-517">La matriz que devuelve este método no se garantiza que contenga el conjunto completo de caracteres que no son válidos en nombres de archivo y directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-517">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="52119-518">El conjunto completo de caracteres no válidos puede variar según el sistema de archivos.</span><span class="sxs-lookup"><span data-stu-id="52119-518">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="52119-519">Por ejemplo, en plataformas de escritorio basadas en Windows, en caracteres de ruta no válida pueden incluir caracteres ASCII/Unicode del 1 al 31, así como comillas ("), menor que (\<), mayor que (>), barra vertical (&#124;), retroceso (\b), null (\0) y tabulación (\t).</span><span class="sxs-lookup"><span data-stu-id="52119-519">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="52119-520">No use <xref:System.IO.Path.InvalidPathChars> si cree que el código podría ejecutarse en el mismo dominio de aplicación como código no seguro.</span><span class="sxs-lookup"><span data-stu-id="52119-520">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="52119-521"><xref:System.IO.Path.InvalidPathChars> es una matriz, por lo que sus elementos se pueden sobrescribir.</span><span class="sxs-lookup"><span data-stu-id="52119-521"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="52119-522">Si el código no seguro sobrescribe los elementos de <xref:System.IO.Path.InvalidPathChars>, podría provocar que el código no funcione correctamente en formas que podrían ser aprovechados.</span><span class="sxs-lookup"><span data-stu-id="52119-522">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-523">En el ejemplo siguiente se muestra el uso de la `InvalidPathChars` propiedad.</span><span class="sxs-lookup"><span data-stu-id="52119-523">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-524">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-524">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-525">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-525">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-526">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-526">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="52119-527">Devuelve un valor que indica si una ruta de acceso de archivo es un nombre completo.</span><span class="sxs-lookup"><span data-stu-id="52119-527">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="52119-528">Las sobrecargas de los `IsPathFullyQualified` las rutas de acceso de identificador de método que se usan el <xref:System.IO.Path.DirectorySeparatorChar> y <xref:System.IO.Path.AltDirectorySeparatorChar> caracteres.</span><span class="sxs-lookup"><span data-stu-id="52119-528">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="52119-529">No realiza ninguna validación en la ruta de acceso que se pasa como argumento.</span><span class="sxs-lookup"><span data-stu-id="52119-529">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="52119-530">Como resultado, los URI se interpretan como rutas de acceso relativas y devolver `false`.</span><span class="sxs-lookup"><span data-stu-id="52119-530">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="52119-531">Hay una diferencia entre una ruta de acceso completa (tal y como indica la `IsPathFullyQualified` método) y una ruta de acceso raíz (tal y como indica la <xref:System.IO.Path.IsPathRooted%2A> método).</span><span class="sxs-lookup"><span data-stu-id="52119-531">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="52119-532">Un *ruta de acceso completa* o *ruta de acceso absoluta* siempre define una ruta de acceso exacta de una determinada unidad o dispositivo a un archivo de destino o directorio y no depende de la unidad actual o el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="52119-532">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="52119-533">Por ejemplo, en los sistemas de Windows, *C:/users/user1/documents/reports/2019/january/highlights.pdf* define una ruta de acceso absoluta de la raíz de la unidad C: en el archivo de destino, *highlights.pdf*.</span><span class="sxs-lookup"><span data-stu-id="52119-533">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="52119-534">Un *ruta de acceso raíz* especifica una unidad de inicio o el directorio raíz, pero depende del directorio actual (si lo tiene su raíz en una unidad especificada) o la unidad actual (si lo tiene su raíz en el directorio raíz).</span><span class="sxs-lookup"><span data-stu-id="52119-534">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="52119-535">El ejemplo siguiente ilustra la diferencia entre las rutas de acceso completos y las rutas de acceso raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-535">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-536">Una ruta de acceso de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-536">A file path.</span></span></param>
        <summary><span data-ttu-id="52119-537">Devuelve un valor que indica si la ruta de acceso de archivo representada por el intervalo de caracteres especificado está fija en una unidad específica o una ruta de acceso UNC.</span><span class="sxs-lookup"><span data-stu-id="52119-537">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="52119-538"><see langword="true" /> si la ruta de acceso se ha fijado a una unidad específica o ruta de acceso UNC; <see langword="false" /> si la ruta de acceso es relativa a la unidad actual o el directorio de trabajo.</span><span class="sxs-lookup"><span data-stu-id="52119-538"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-539">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-539">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-540">Una ruta de acceso de archivo.</span><span class="sxs-lookup"><span data-stu-id="52119-540">A file path.</span></span></param>
        <summary><span data-ttu-id="52119-541">Devuelve un valor que indica si la ruta de acceso de archivo especificada está fija en una unidad específica o una ruta de acceso UNC.</span><span class="sxs-lookup"><span data-stu-id="52119-541">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="52119-542"><see langword="true" /> si la ruta de acceso se ha fijado a una unidad específica o ruta de acceso UNC; <see langword="false" /> si la ruta de acceso es relativa a la unidad actual o el directorio de trabajo.</span><span class="sxs-lookup"><span data-stu-id="52119-542"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="52119-543"><paramref name="path" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="52119-543"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-544">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-544">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="52119-545">Devuelve un valor que indica si una ruta de acceso de archivo contiene una raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-545">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="52119-546">Un **ruta de acceso raíz** es la ruta de acceso del archivo que se ha corregido en una unidad específica o una ruta UNIC; contrasta con una ruta de acceso es relativa a la unidad actual o el directorio de trabajo.</span><span class="sxs-lookup"><span data-stu-id="52119-546">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="52119-547">Por ejemplo, en los sistemas de Windows, una ruta de acceso raíz comienza con una barra diagonal inversa (por ejemplo, "\Documents") o una letra de unidad y dos puntos (por ejemplo, "C:Documents").</span><span class="sxs-lookup"><span data-stu-id="52119-547">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="52119-548">Tenga en cuenta que las rutas de acceso raíz pueden ser absoluto (que es, un nombre completo) o relativa.</span><span class="sxs-lookup"><span data-stu-id="52119-548">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="52119-549">Una ruta de acceso raíz absoluto es una ruta de acceso completa de la raíz de una unidad a un directorio específico.</span><span class="sxs-lookup"><span data-stu-id="52119-549">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="52119-550">Una ruta de acceso raíz relativa especifica una unidad, pero su ruta de acceso completa se resuelve en el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="52119-550">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="52119-551">En el siguiente ejemplo se ilustra la diferencia.</span><span class="sxs-lookup"><span data-stu-id="52119-551">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-552">Ruta de acceso que se va a probar.</span><span class="sxs-lookup"><span data-stu-id="52119-552">The path to test.</span></span></param>
        <summary><span data-ttu-id="52119-553">Devuelve un valor que indica si el intervalo de caracteres especificado que representa una ruta de acceso de archivo contiene una raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-553">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="52119-554"><see langword="true" /> si <paramref name="path" /> contiene una raíz; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-554"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-555">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-555">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="52119-556">Ruta de acceso que se va a probar.</span><span class="sxs-lookup"><span data-stu-id="52119-556">The path to test.</span></span></param>
        <summary><span data-ttu-id="52119-557">Devuelve un valor que indica si la cadena de ruta de acceso especificada contiene una raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-557">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="52119-558"><see langword="true" /> si <paramref name="path" /> contiene una raíz; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-558"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-559">El <xref:System.IO.Path.IsPathRooted%2A> devuelve del método `true` si el primer carácter es un carácter separador de directorio, como "\\", o si la ruta de acceso comienza con una letra de unidad y dos puntos (:).</span><span class="sxs-lookup"><span data-stu-id="52119-559">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="52119-560">Por ejemplo, devuelve `true` para `path` cadenas como "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", o "C: Midir".</span><span class="sxs-lookup"><span data-stu-id="52119-560">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="52119-561">Devuelve `false` para `path` cadenas como "MyDir".</span><span class="sxs-lookup"><span data-stu-id="52119-561">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="52119-562">Este método no comprueba que existe el nombre de archivo o ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-562">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="52119-563">Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="52119-563">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="52119-564">En el ejemplo siguiente se muestra cómo el `IsPathRooted` método puede utilizarse para probar las tres cadenas.</span><span class="sxs-lookup"><span data-stu-id="52119-564">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="52119-565"><paramref name="path" /> contiene uno o varios de los caracteres no válidos definidos en <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="52119-565"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-566">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-566">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-567">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-567">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-568">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-568">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-569">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-569">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-570">Intervalo de caracteres que contiene la primera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-570">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-571">Intervalo de caracteres que contiene la segunda ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-571">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="52119-572">Concatena dos componentes de ruta de acceso en una única ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-572">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="52119-573">Rutas de acceso combinadas.</span><span class="sxs-lookup"><span data-stu-id="52119-573">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="52119-574">Este método simplemente concatena `path` y `path2` y agrega un carácter separador de directorio entre los componentes de ruta de dos acceso si uno no está presente al final de `path1` o al principio de `path2`.</span><span class="sxs-lookup"><span data-stu-id="52119-574">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="52119-575">Si el <xref:System.ReadOnlySpan%601.Length> del `path1` o `path2` es cero, el método devuelve la ruta de acceso de otro.</span><span class="sxs-lookup"><span data-stu-id="52119-575">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="52119-576">Si el <xref:System.ReadOnlySpan%601.Length> de ambos `path1` y `path2` es cero, el método devuelve <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="52119-576">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="52119-577">Si `path1` termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Join` método conserva el carácter separador de ruta de acceso original y anexa los admite.</span><span class="sxs-lookup"><span data-stu-id="52119-577">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="52119-578">Este problema se produce en rutas de acceso codificadas de forma rígida que use la barra diagonal inversa de Windows ("\") carácter, que no se reconoce como un separador de ruta de acceso en los sistemas basados en Unix.</span><span class="sxs-lookup"><span data-stu-id="52119-578">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="52119-579">Para solucionar este problema, puede:</span><span class="sxs-lookup"><span data-stu-id="52119-579">To work around this issue, you can:</span></span>

- <span data-ttu-id="52119-580">Recuperar el valor de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propiedad en lugar de codificar un carácter separador de directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-580">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="52119-581">Use una barra diagonal ("/") como separador de directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-581">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="52119-582">Este carácter devuelto por el <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propiedad en los sistemas basados en Unix y por la <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propiedad en los sistemas de Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-582">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="52119-583">A diferencia de la <xref:System.IO.Path.Combine%2A> método, el <xref:System.IO.Path.Join%2A> método no intenta raíz la ruta de acceso devuelta.</span><span class="sxs-lookup"><span data-stu-id="52119-583">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="52119-584">(Es decir, si `path2` es una ruta absoluta, el `Join` no descarta la método `path1` y devolver `path2` como el <xref:System.IO.Path.Combine%2A> método.) El ejemplo siguiente muestra la diferencia en las rutas de acceso devuelta por los dos métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-584">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="52119-585">Si el origen de `path2` es la entrada del usuario, el <xref:System.IO.Path.Combine%2A> método permite que un usuario tener acceso a un recurso de sistema de archivos (como *C:/usuarios/User1/documentos/financiero/* en el caso del ejemplo) que hizo la aplicación no se va a hacer accesible.</span><span class="sxs-lookup"><span data-stu-id="52119-585">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="52119-586">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Join` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-586">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-587">Por ejemplo, mientras `Path.Join("c:\\", "*.txt")` podría ser no válido cuando crea un archivo, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-587">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="52119-588">El `Join` método, por tanto, correctamente lo interpreta.</span><span class="sxs-lookup"><span data-stu-id="52119-588">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="52119-589">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="52119-589">Example</span></span>

<span data-ttu-id="52119-590">El ejemplo siguiente ilustra la diferencia entre las rutas de acceso devuelta por la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> y <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-590">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="52119-591">Cuando la primera cadena es una ruta de acceso completa que incluye un unidad y el directorio raíz y el segundo es una ruta de acceso relativa desde la primera ruta de acceso, los dos métodos producen resultados idénticos.</span><span class="sxs-lookup"><span data-stu-id="52119-591">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="52119-592">En la segunda y terceros llamadas a la `ShowPathInformation` divergen de método, las cadenas devueltas por los dos métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-592">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="52119-593">En la segunda llamada de método, la cadena del primer argumento es una unidad, mientras que el segundo es un directorio raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-593">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="52119-594">El `Join` método concatena las dos cadenas y conserva duplicar los separadores de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-594">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="52119-595">El `Combine` método abandona la unidad y devuelve un directorio raíz en la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="52119-595">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="52119-596">Si la aplicación actual de la unidad es C:\ y esta cadena se usa para tener acceso a uno o varios archivos en el directorio, tendría acceso C: en lugar de D:.</span><span class="sxs-lookup"><span data-stu-id="52119-596">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="52119-597">Por último, porque ambos argumentos en la tercera llamada a `ShowPathInformation` se ha modificado, la `Join` método anexa simplemente para crear una ruta de acceso de archivo sin sentido, mientras que el `Combine` descarta la primera cadena de método y devuelve el segundo.</span><span class="sxs-lookup"><span data-stu-id="52119-597">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="52119-598">Con esta cadena de acceso de archivo podría dar a la aplicación no intencionada el acceso a archivos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="52119-598">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-599">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-599">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-600">Intervalo de caracteres que contiene la primera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-600">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-601">Intervalo de caracteres que contiene la segunda ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-601">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="52119-602">Intervalo de caracteres que contiene la tercera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-602">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="52119-603">Concatena tres componentes de ruta de acceso en una única ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-603">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="52119-604">Este método simplemente concatena `path`, `path2`, y `path3` y agrega un carácter separador de directorio entre cualquiera de los componentes de ruta de acceso si todavía no está presente.</span><span class="sxs-lookup"><span data-stu-id="52119-604">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="52119-605">Si el <xref:System.ReadOnlySpan%601.Length> de cualquiera de `path1`, `path2`, o `path3` argumento es cero, el método concatena los argumentos restantes.</span><span class="sxs-lookup"><span data-stu-id="52119-605">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="52119-606">Si el <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> de todos los componentes es cero, el método devuelve <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="52119-606">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="52119-607">Si `path1` o `path2` termina en un carácter separador de ruta de acceso que no sea adecuado para la plataforma de destino, el `Join` método conserva el carácter separador de ruta de acceso original y anexa los admite.</span><span class="sxs-lookup"><span data-stu-id="52119-607">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="52119-608">Este problema se produce en rutas de acceso codificadas de forma rígida que use la barra diagonal inversa de Windows ("\") carácter, que no se reconoce como un separador de ruta de acceso en los sistemas basados en Unix.</span><span class="sxs-lookup"><span data-stu-id="52119-608">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="52119-609">Para solucionar este problema, puede:</span><span class="sxs-lookup"><span data-stu-id="52119-609">To work around this issue, you can:</span></span>

- <span data-ttu-id="52119-610">Recuperar el valor de la <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propiedad en lugar de codificar un carácter separador de directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-610">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="52119-611">Use una barra diagonal ("/") como separador de directorio.</span><span class="sxs-lookup"><span data-stu-id="52119-611">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="52119-612">Este carácter devuelto por el <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> propiedad en los sistemas basados en Unix y por la <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> propiedad en los sistemas de Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-612">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="52119-613">A diferencia de la <xref:System.IO.Path.Combine%2A> método, el <xref:System.IO.Path.Join%2A> método no intenta raíz la ruta de acceso devuelta.</span><span class="sxs-lookup"><span data-stu-id="52119-613">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="52119-614">(Es decir, si `path2` o `path2` es una ruta absoluta, el `Join` método descartar las rutas de acceso anteriores como el <xref:System.IO.Path.Combine%2A> método.</span><span class="sxs-lookup"><span data-stu-id="52119-614">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="52119-615">No todos los caracteres no válidos para los nombres de archivos y directorios se interpretan como inaceptables por la `Join` método, porque puede utilizar estos caracteres para buscar caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="52119-615">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="52119-616">Por ejemplo, mientras `Path.Join("c:\\", "temp", "*.txt")` podría ser no válido cuando crea un archivo, es válido como una cadena de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="52119-616">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="52119-617">El `Join` método, por tanto, correctamente lo interpreta.</span><span class="sxs-lookup"><span data-stu-id="52119-617">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="52119-618">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="52119-618">Example</span></span>

<span data-ttu-id="52119-619">El ejemplo siguiente ilustra la diferencia entre las rutas de acceso devuelta por la <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> y <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-619">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="52119-620">Cuando la primera cadena es una ruta de acceso completa que incluye un unidad y el directorio raíz y el segundo es una ruta de acceso relativa desde la primera ruta de acceso, los dos métodos producen resultados idénticos.</span><span class="sxs-lookup"><span data-stu-id="52119-620">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="52119-621">En la segunda y terceros llamadas a la `ShowPathInformation` divergen de método, las cadenas devueltas por los dos métodos.</span><span class="sxs-lookup"><span data-stu-id="52119-621">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="52119-622">En la segunda llamada de método, la cadena del primer argumento es una unidad, mientras que el segundo es un directorio raíz.</span><span class="sxs-lookup"><span data-stu-id="52119-622">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="52119-623">El `Join` método concatena las dos cadenas y conserva duplicar los separadores de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="52119-623">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="52119-624">Una llamada a la <xref:System.IO.Path.GetFullPath%2A> método eliminaría la duplicación.</span><span class="sxs-lookup"><span data-stu-id="52119-624">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="52119-625">El `Combine` método abandona la unidad y devuelve un directorio raíz en la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="52119-625">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="52119-626">Si la aplicación actual de la unidad es C:\ y esta cadena se usa para tener acceso a uno o varios archivos en el directorio, tendría acceso C: en lugar de D:.</span><span class="sxs-lookup"><span data-stu-id="52119-626">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="52119-627">Por último, dado que el argumento final de la tercera llamada a `ShowPathInformation` se ha modificado, la `Join` método simplemente lo anexa a los dos primeros argumentos para crear una ruta de acceso de archivo sin sentido, mientras el `Combine` método descarta las dos primeras cadenas y devuelve la tercera.</span><span class="sxs-lookup"><span data-stu-id="52119-627">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="52119-628">Con esta cadena de acceso de archivo podría dar a la aplicación no intencionada el acceso a archivos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="52119-628">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-629">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-629">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="52119-630">Carácter separador específico de la plataforma que se utiliza para separar cadenas de ruta de acceso en variables de entorno.</span><span class="sxs-lookup"><span data-stu-id="52119-630">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-631">En plataformas de escritorio basadas en Windows, el valor de este campo es el punto y coma (;) de forma predeterminada, pero puede variar en otras plataformas.</span><span class="sxs-lookup"><span data-stu-id="52119-631">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-632">En el ejemplo siguiente se muestra el uso de la `PathSeparator` campo.</span><span class="sxs-lookup"><span data-stu-id="52119-632">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-633">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-633">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-634">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-634">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-635">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-635">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="52119-636">Intenta concatenar los componentes individuales de la ruta de acceso a un intervalo de caracteres asignados previamente, y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="52119-636">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="52119-637">El intervalo de caracteres de destino debe ser lo suficientemente grande como para contener la ruta de acceso concatenado.</span><span class="sxs-lookup"><span data-stu-id="52119-637">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="52119-638">A continuación, puede recuperar la ruta de acceso concatenado mediante una llamada a la <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como en el ejemplo siguiente se muestra.</span><span class="sxs-lookup"><span data-stu-id="52119-638">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-639">Intervalo de caracteres que contiene la primera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-639">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-640">Intervalo de caracteres que contiene la segunda ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-640">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="52119-641">Intervalo de caracteres para contener la ruta de acceso concatenada.</span><span class="sxs-lookup"><span data-stu-id="52119-641">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="52119-642">Cuando el método finaliza, un valor que indica el número de caracteres escritos en <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="52119-642">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="52119-643">Intenta concatenar dos componentes de la ruta de acceso a un único intervalo de caracteres asignados previamente, y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="52119-643">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="52119-644"><see langword="true" /> si la operación de concatenación es correcta; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-644"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="52119-645">`destination` debe ser lo suficientemente grande como para contener la ruta de acceso concatenado.</span><span class="sxs-lookup"><span data-stu-id="52119-645">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="52119-646">A continuación, puede recuperar la ruta de acceso concatenado mediante una llamada a la <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como en el ejemplo se muestra.</span><span class="sxs-lookup"><span data-stu-id="52119-646">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-647">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-647">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="52119-648">Intervalo de caracteres que contiene la primera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-648">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="52119-649">Intervalo de caracteres que contiene la segunda ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-649">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="52119-650">Intervalo de caracteres que contiene la tercera ruta de acceso para combinar.</span><span class="sxs-lookup"><span data-stu-id="52119-650">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="52119-651">Intervalo de caracteres para contener la ruta de acceso concatenada.</span><span class="sxs-lookup"><span data-stu-id="52119-651">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="52119-652">Cuando el método finaliza, un valor que indica el número de caracteres escritos en <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="52119-652">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="52119-653">Intenta concatenar dos componentes de la ruta de acceso a un único intervalo de caracteres asignados previamente, y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="52119-653">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="52119-654"><see langword="true" /> si la operación de concatenación es correcta; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="52119-654"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="52119-655">`destination` debe ser lo suficientemente grande como para contener la ruta de acceso concatenado.</span><span class="sxs-lookup"><span data-stu-id="52119-655">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="52119-656">A continuación, puede recuperar la ruta de acceso concatenado mediante una llamada a la <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> método, como en el ejemplo se muestra.</span><span class="sxs-lookup"><span data-stu-id="52119-656">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="52119-657">Formatos de ruta de acceso de archivo en los sistemas Windows</span><span class="sxs-lookup"><span data-stu-id="52119-657">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="52119-658">Proporciona un carácter separador de volúmenes específico de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="52119-658">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="52119-659">El valor de este campo es un signo de dos puntos (:) en una barra diagonal (/) en los sistemas operativos UNIX y Macintosh y Windows.</span><span class="sxs-lookup"><span data-stu-id="52119-659">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="52119-660">Esto es más útil para analizar rutas de acceso como "c:\windows" o "MacVolume: System Folder".</span><span class="sxs-lookup"><span data-stu-id="52119-660">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="52119-661">En el ejemplo siguiente se muestra el uso de la `VolumeSeparatorChar` campo.</span><span class="sxs-lookup"><span data-stu-id="52119-661">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="52119-662">E/S de archivos y secuencias</span><span class="sxs-lookup"><span data-stu-id="52119-662">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="52119-663">Cómo: Leer texto de un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-663">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="52119-664">Cómo: Escribir texto en un archivo</span><span class="sxs-lookup"><span data-stu-id="52119-664">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
