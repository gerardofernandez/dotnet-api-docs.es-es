<Type Name="ConcurrentDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Concurrent.ConcurrentDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ebb3dbde5d313dce751972ffc5da378c0e6aa33c" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65002813" /></Metadata><TypeSignature Language="C#" Value="public class ConcurrentDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ConcurrentDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.ConcurrentDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class ConcurrentDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class ConcurrentDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type ConcurrentDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="9609c-101">Tipo de las claves del diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-101">The type of the keys in the dictionary.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="9609c-102">Tipo de los valores del diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-102">The type of the values in the dictionary.</span></span></typeparam>
    <summary><span data-ttu-id="9609c-103">Representa una colección segura para subprocesos de los pares clave-valor a los que pueden obtener acceso varios subprocesos a la vez.</span><span class="sxs-lookup"><span data-stu-id="9609c-103">Represents a thread-safe collection of key/value pairs that can be accessed by multiple threads concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-104">Para gran <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objetos, puede aumentar el tamaño máximo de la matriz de 2 gigabytes (GB) en un sistema de 64 bits estableciendo el [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuración a `true` en el entorno de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="9609c-104">For very large <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objects, you can increase the maximum array size to 2 gigabytes (GB) on a 64-bit system by setting the [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9609c-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implementa el <xref:System.Collections.Generic.IReadOnlyCollection%601> y <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces a partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; en versiones anteriores de .NET Framework, el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase no implementa estas interfaces.</span><span class="sxs-lookup"><span data-stu-id="9609c-105"><xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> and <xref:System.Collections.Generic.IReadOnlyDictionary%602> interfaces starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class did not implement these interfaces.</span></span>  
  
 <span data-ttu-id="9609c-106">Al igual que el <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> (clase), <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implementa el <xref:System.Collections.Generic.IDictionary%602> interfaz.</span><span class="sxs-lookup"><span data-stu-id="9609c-106">Like the <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> class, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> implements the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span> <span data-ttu-id="9609c-107">Además, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> proporciona varios métodos para agregar o actualizar los pares clave/valor en el diccionario, tal como se describe en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="9609c-107">In addition, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> provides several methods for adding or updating key/value pairs in the dictionary, as described in the following table.</span></span>  
  
|<span data-ttu-id="9609c-108">Para</span><span class="sxs-lookup"><span data-stu-id="9609c-108">To do this</span></span>|<span data-ttu-id="9609c-109">Utilice este método</span><span class="sxs-lookup"><span data-stu-id="9609c-109">Use this method</span></span>|<span data-ttu-id="9609c-110">Notas de uso</span><span class="sxs-lookup"><span data-stu-id="9609c-110">Usage notes</span></span>|  
|----------------|---------------------|-----------------|  
|<span data-ttu-id="9609c-111">Agregue una nueva clave al diccionario, si ya no existe en el diccionario</span><span class="sxs-lookup"><span data-stu-id="9609c-111">Add a new key to the dictionary, if it doesn't already exist in the dictionary</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A>|<span data-ttu-id="9609c-112">Este método agrega el par clave-valor especificado, si la clave no existe actualmente en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-112">This method adds the specified key/value pair, if the key doesn't currently exist in the dictionary.</span></span> <span data-ttu-id="9609c-113">El método devuelve `true` o `false` dependiendo de si se ha agregado el nuevo par.</span><span class="sxs-lookup"><span data-stu-id="9609c-113">The method returns `true` or `false` depending on whether the new pair was added.</span></span>|  
|<span data-ttu-id="9609c-114">Actualice el valor de una clave existente en el diccionario, si esa clave tiene un valor específico</span><span class="sxs-lookup"><span data-stu-id="9609c-114">Update the value for an existing key in the dictionary, if that key has a specific value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A>|<span data-ttu-id="9609c-115">Este método comprueba si la clave tiene un valor especificado y si, actualiza la clave con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-115">This method checks whether the key has a specified value, and if it does, updates the key with a new value.</span></span> <span data-ttu-id="9609c-116">Es similar a la <xref:System.Threading.Interlocked.CompareExchange%2A> método, salvo que la utiliza para los elementos del diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-116">It's similar to the <xref:System.Threading.Interlocked.CompareExchange%2A> method, except that it's used for dictionary elements.</span></span>|  
|<span data-ttu-id="9609c-117">Store incondicionalmente un par clave/valor en el diccionario y sobrescribir el valor de una clave que ya existe</span><span class="sxs-lookup"><span data-stu-id="9609c-117">Store a key/value pair in the dictionary unconditionally, and overwrite the value of a key that already exists</span></span>|<span data-ttu-id="9609c-118">Establecedor del indizador: `dictionary[key] = newValue`</span><span class="sxs-lookup"><span data-stu-id="9609c-118">The indexer's setter: `dictionary[key] = newValue`</span></span>||  
|<span data-ttu-id="9609c-119">Agregar un par clave/valor al diccionario, o si la clave ya existe, actualice el valor de la clave según el valor de clave existente</span><span class="sxs-lookup"><span data-stu-id="9609c-119">Add a key/value pair to the dictionary, or if the key already exists, update the value for the key based on the key's existing value</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29><br /><br /> <span data-ttu-id="9609c-120">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-120">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29>|<span data-ttu-id="9609c-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> acepta dos delegados y la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-121"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2CSystem.Func%7B%600%2C%601%7D%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key and two delegates.</span></span> <span data-ttu-id="9609c-122">Usa al primer delegado si la clave no existe en el diccionario; acepta la tecla y devuelve el valor que se debe agregar para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-122">It uses the first delegate if the key doesn't exist in the dictionary; it accepts the key and returns the value that should be added for the key.</span></span> <span data-ttu-id="9609c-123">Usa al segundo delegado si existe la clave; acepta la clave y su valor actual y devuelve el nuevo valor que se debe establecer para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-123">It uses the second delegate if the key does exist; it accepts the key and its current value, and it returns the new value that should be set for the key.</span></span><br /><br /> <span data-ttu-id="9609c-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> acepta la clave, un valor para agregar y el delegado de actualización.</span><span class="sxs-lookup"><span data-stu-id="9609c-124"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%28%600%2C%601%2CSystem.Func%7B%600%2C%601%2C%601%7D%29> accepts the key, a value to add, and the update delegate.</span></span> <span data-ttu-id="9609c-125">Esto es igual que la anterior sobrecarga, salvo que no usa a un delegado para agregar una clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-125">This is the same as the previous overload, except that it doesn't use a delegate to add a key.</span></span>|  
|<span data-ttu-id="9609c-126">Obtener el valor de una clave en el diccionario, agrega el valor al diccionario y devolverla a la clave existe</span><span class="sxs-lookup"><span data-stu-id="9609c-126">Get the value for a key in the dictionary, adding the value to the dictionary and returning it if the key doesn't exist</span></span>|<xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29><br /><br /> <span data-ttu-id="9609c-127">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-127">-or-</span></span><br /><br /> <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29>|<span data-ttu-id="9609c-128">Estas sobrecargas proporcionan la inicialización diferida para un par clave/valor en el diccionario, agrega el valor solo si no está allí.</span><span class="sxs-lookup"><span data-stu-id="9609c-128">These overloads provide lazy initialization for a key/value pair in the dictionary, adding the value only if it's not there.</span></span><br /><br /> <span data-ttu-id="9609c-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> toma el valor que se va a agregar si la clave no existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-129"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2C%601%29> takes the value to be added if the key doesn't exist.</span></span><br /><br /> <span data-ttu-id="9609c-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> toma a un delegado que generará el valor de la clave existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-130"><xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%28%600%2CSystem.Func%7B%600%2C%601%7D%29> takes a delegate that will generate the value if the key doesn't exist.</span></span>|  
  
 <span data-ttu-id="9609c-131">Todas estas operaciones son atómicas y son seguros para subprocesos con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-131">All these operations are atomic and are thread-safe with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span> <span data-ttu-id="9609c-132">Las únicas excepciones son los métodos que aceptan un delegado, es decir, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> y <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span><span class="sxs-lookup"><span data-stu-id="9609c-132">The only exceptions are the methods that accept a delegate, that is, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> and <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A>.</span></span> <span data-ttu-id="9609c-133">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-133">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-134">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, los delegados para estos métodos se denominan fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-134">(Read operations on the dictionary are performed in a lock-free manner.) However, delegates for these methods are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-135">Por lo tanto, el código ejecutado por estos delegados no está sujeto a la atomicidad de la operación.</span><span class="sxs-lookup"><span data-stu-id="9609c-135">Therefore, the code executed by these delegates is not subject to the atomicity of the operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9609c-136">El ejemplo siguiente muestra cómo construir un <xref:System.Collections.Concurrent.ConcurrentDictionary%602> objeto.</span><span class="sxs-lookup"><span data-stu-id="9609c-136">The following example shows how to construct a <xref:System.Collections.Concurrent.ConcurrentDictionary%602> object.</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#1)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="9609c-137">Todos los miembros públicos y protegidos de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-137">All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> are thread-safe and may be used concurrently from multiple threads.</span></span> <span data-ttu-id="9609c-138">Sin embargo, tener acceso miembros a través de una de las interfaces del <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implementa, incluidos los métodos de extensión, no se garantiza que sea seguro para subprocesos y es posible que deba sincronizarlos el llamador.</span><span class="sxs-lookup"><span data-stu-id="9609c-138">However, members accessed through one of the interfaces the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> implements, including extension methods, are not guaranteed to be thread safe and may need to be synchronized by the caller.</span></span></threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-139">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-139">Thread-Safe Collections</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-140">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-140">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9609c-141">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-141">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class.</span></span></summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-142">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-142">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-143">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-143">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-144">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el comparador predeterminado para el tipo de clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-144">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-145">El nivel de simultaneidad predeterminado es igual al número de CPU.</span><span class="sxs-lookup"><span data-stu-id="9609c-145">The default concurrency level is equal to the number of CPUs.</span></span> <span data-ttu-id="9609c-146">Cuanto mayor sea el nivel de simultaneidad es, las operaciones de escritura simultáneas de más pueden tener lugar sin interferencias y bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-146">The higher the concurrency level is, the more concurrent write operations can take place without interference and blocking.</span></span> <span data-ttu-id="9609c-147">Los valores más altos de nivel de simultaneidad también hacer que las operaciones que requieren todos los bloqueos (por ejemplo, cambiar el tamaño, la tabla `ToArray` y `Count`) sea más costoso.</span><span class="sxs-lookup"><span data-stu-id="9609c-147">Higher concurrency level values also cause operations that require all locks (for example, table resizing, `ToArray` and `Count`) to become more expensive.</span></span> <span data-ttu-id="9609c-148">La capacidad predeterminada (DEFAULT_CAPACITY), que representa el número de depósitos inicial, es un equilibrio entre el tamaño de un diccionario muy pequeño y el número de cambios de tamaño cuando se construye un diccionario de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="9609c-148">The default capacity (DEFAULT_CAPACITY), which represents the initial number of buckets, is a trade-off between the size of a very small dictionary and the number of resizes when constructing a large dictionary.</span></span> <span data-ttu-id="9609c-149">Además, la capacidad no debe ser divisible por un pequeño número de números primos.</span><span class="sxs-lookup"><span data-stu-id="9609c-149">Also, the capacity should not be divisible by a small prime number.</span></span> <span data-ttu-id="9609c-150">La capacidad predeterminada es 31.</span><span class="sxs-lookup"><span data-stu-id="9609c-150">The default capacity is 31.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-151">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-151">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-152">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-152">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="9609c-153"><see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-153">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="9609c-154">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene elementos copiados del <see cref="T:System.Collections.Generic.IEnumerable`1" /> especificado, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el comparador predeterminado para el tipo de clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-154">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IEnumerable`1" />, has the default concurrency level, has the default initial capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-155"><paramref name="collection" /> o cualquiera de sus claves es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-155"><paramref name="collection" /> or any of its keys is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-156"><paramref name="collection" /> contiene una o varias claves duplicadas.</span><span class="sxs-lookup"><span data-stu-id="9609c-156"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-157">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-157">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-158">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-158">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="9609c-159">Implementación de comparación de igualdad que se debe utilizar al comparar claves.</span><span class="sxs-lookup"><span data-stu-id="9609c-159">The equality comparison implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="9609c-160">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad predeterminados y utiliza el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-160">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the default concurrency level and capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-161">El valor de <paramref name="comparer" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-161"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-162">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-162">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-163">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-163">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="9609c-164"><see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-164">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="9609c-165">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</span><span class="sxs-lookup"><span data-stu-id="9609c-165">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="9609c-166">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene elementos copiados del <see cref="T:System.Collections.IEnumerable" /> especificado, tiene el nivel de simultaneidad predeterminado, tiene la capacidad inicial predeterminada y usa el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-166">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" /> has the default concurrency level, has the default initial capacity, and uses the specified  <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-167"><paramref name="collection" /> o <paramref name="comparer" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-167"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-168">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-168">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-169">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-169">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="9609c-170">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="9609c-170">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="9609c-171">Número inicial de elementos que puede contener la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-171">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <summary><span data-ttu-id="9609c-172">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad especificados, y usa el comparador predeterminado para el tipo de clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-172">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level and capacity, and uses the default comparer for the key type.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9609c-173"><paramref name="concurrencyLevel" /> es menor que 1.</span><span class="sxs-lookup"><span data-stu-id="9609c-173"><paramref name="concurrencyLevel" /> is less than 1.</span></span>  
  
<span data-ttu-id="9609c-174">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-174">-or-</span></span> 
 <span data-ttu-id="9609c-175"><paramref name="capacity" /> es menor que 0.</span><span class="sxs-lookup"><span data-stu-id="9609c-175"><paramref name="capacity" /> is less than 0.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-176">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-176">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-177">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-177">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="9609c-178">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="9609c-178">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="collection"><span data-ttu-id="9609c-179"><see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se copian en el nuevo <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-179">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="9609c-180">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</span><span class="sxs-lookup"><span data-stu-id="9609c-180">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="9609c-181">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que contiene los elementos copiados del <see cref="T:System.Collections.IEnumerable" /> especificado y utiliza el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-181">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable" />, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-182"><paramref name="collection" /> o <paramref name="comparer" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-182"><paramref name="collection" /> or <paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9609c-183"><paramref name="concurrencyLevel" /> es menor que 1.</span><span class="sxs-lookup"><span data-stu-id="9609c-183"><paramref name="concurrencyLevel" /> is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-184"><paramref name="collection" /> contiene una o varias claves duplicadas.</span><span class="sxs-lookup"><span data-stu-id="9609c-184"><paramref name="collection" /> contains one or more duplicate keys.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-185">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-185">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-186">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-186">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentDictionary (int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 concurrencyLevel, int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (concurrencyLevel As Integer, capacity As Integer, comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConcurrentDictionary(int concurrencyLevel, int capacity, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; : int * int * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt; (concurrencyLevel, capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="concurrencyLevel" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="concurrencyLevel"><span data-ttu-id="9609c-187">Número previsto de subprocesos que actualizarán <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="9609c-187">The estimated number of threads that will update the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> concurrently.</span></span></param>
        <param name="capacity"><span data-ttu-id="9609c-188">Número inicial de elementos que puede contener la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-188">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> can contain.</span></span></param>
        <param name="comparer"><span data-ttu-id="9609c-189">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves.</span><span class="sxs-lookup"><span data-stu-id="9609c-189">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys.</span></span></param>
        <summary><span data-ttu-id="9609c-190">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> que está vacía, tiene el nivel de simultaneidad y la capacidad inicial especificados, y usa el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-190">Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> class that is empty, has the specified concurrency level, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-191">El valor de <paramref name="comparer" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-191"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9609c-192"><paramref name="concurrencyLevel" /> o <paramref name="capacity" /> es menor que 1.</span><span class="sxs-lookup"><span data-stu-id="9609c-192"><paramref name="concurrencyLevel" /> or <paramref name="capacity" /> is less than 1.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-193">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-193">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-194">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-194">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9609c-195">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o actualiza un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-195">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9609c-196">El ejemplo siguiente muestra cómo llamar a la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> método:</span><span class="sxs-lookup"><span data-stu-id="9609c-196">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-197">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-197">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-198">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-198">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, Func&lt;TKey,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; addValueFactory, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValueFactory As Func(Of TKey, TValue), updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Value&gt; * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-199">Clave que se va a agregar o cuyo valor se va a actualizar.</span><span class="sxs-lookup"><span data-stu-id="9609c-199">The key to be added or whose value should be updated</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="9609c-200">Función que se usa para generar un valor para una clave ausente.</span><span class="sxs-lookup"><span data-stu-id="9609c-200">The function used to generate a value for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="9609c-201">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-201">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="9609c-202">Utiliza las funciones especificadas para agregar un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o para actualizar un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-202">Uses the specified functions to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-203">Nuevo valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-203">The new value for the key.</span></span> <span data-ttu-id="9609c-204">Este será el resultado de <paramref name="addValueFactory" /> (si la clave no se encontró) o el de <paramref name="updateValueFactory" /> (si la clave se encontró).</span><span class="sxs-lookup"><span data-stu-id="9609c-204">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-205">Si se llama a <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultáneamente en subprocesos diferentes, `addValueFactory` puede llamarse varias veces, pero su par clave/valor no puede agregar al diccionario para cada llamada.</span><span class="sxs-lookup"><span data-stu-id="9609c-205">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="9609c-206">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-206">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-207">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, el `addValueFactory` y `updateValueFactory` delegados se denominan fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-207">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-208">Por lo tanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> no es atómico con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-208">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-209"><paramref name="key" />, <paramref name="addValueFactory" /> o <paramref name="updateValueFactory" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-209"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-210">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-210">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-211">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-211">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-212">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-212">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate (TKey key, TValue addValue, Func&lt;TKey,TValue,TValue&gt; updateValueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate(!TKey key, !TValue addValue, class System.Func`3&lt;!TKey, !TValue, !TValue&gt; updateValueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate (key As TKey, addValue As TValue, updateValueFactory As Func(Of TKey, TValue, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue AddOrUpdate(TKey key, TValue addValue, Func&lt;TKey, TValue, TValue&gt; ^ updateValueFactory);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value * Func&lt;'Key, 'Value, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValue, updateValueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="addValue" Type="TValue" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-213">Clave que se va a agregar o cuyo valor se va a actualizar.</span><span class="sxs-lookup"><span data-stu-id="9609c-213">The key to be added or whose value should be updated</span></span></param>
        <param name="addValue"><span data-ttu-id="9609c-214">Valor que se va a agregar para una clave ausente.</span><span class="sxs-lookup"><span data-stu-id="9609c-214">The value to be added for an absent key</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="9609c-215">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-215">The function used to generate a new value for an existing key based on the key's existing value</span></span></param>
        <summary><span data-ttu-id="9609c-216">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o actualiza un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> utilizando la función especificada, si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-216">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-217">Nuevo valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-217">The new value for the key.</span></span> <span data-ttu-id="9609c-218">Este será <paramref name="addValue" /> (si la clave no se encontró) o el resultado de <paramref name="updateValueFactory" /> (si la clave se encontró).</span><span class="sxs-lookup"><span data-stu-id="9609c-218">This will be either be <paramref name="addValue" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9609c-219">El ejemplo de código siguiente muestra cómo inicializar un <xref:System.Collections.Concurrent.ConcurrentDictionary%602> y cómo usar el método AddOrUpdate para agregar un elemento adicional a la colección y actualizar los elementos existentes.</span><span class="sxs-lookup"><span data-stu-id="9609c-219">The following code example shows how to initialize an <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and how to use the AddOrUpdate method to add an additional item to the collection, and update the existing items.</span></span>  
  
 [!code-csharp[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/cs/program.cs#1)]
 [!code-vb[System.Collections.ConcurrentColAddUpdate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrentcoladdupdate/vb/module1.vb#1)]  

## Remarks  
 <span data-ttu-id="9609c-220">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-220">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-221">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, el `updateValueFactory` se llama al delegado fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-221">(Read operations on the dictionary are performed in a lock-free manner.) However, the `updateValueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-222">Por lo tanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> no es atómico con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-222">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-223"><paramref name="key" /> o <paramref name="updateValueFactory" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-223"><paramref name="key" /> or <paramref name="updateValueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-224">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-224">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-225">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-225">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-226">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-226">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue AddOrUpdate&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; addValueFactory, Func&lt;TKey,TValue,TArg,TValue&gt; updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue AddOrUpdate&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; addValueFactory, class System.Func`4&lt;!TKey, !TValue, !!TArg, !TValue&gt; updateValueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOrUpdate(Of TArg) (key As TKey, addValueFactory As Func(Of TKey, TArg, TValue), updateValueFactory As Func(Of TKey, TValue, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue AddOrUpdate(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ addValueFactory, Func&lt;TKey, TValue, TArg, TValue&gt; ^ updateValueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * Func&lt;'Key, 'Value, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.AddOrUpdate (key, addValueFactory, updateValueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="addValueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="updateValueFactory" Type="System.Func&lt;TKey,TValue,TArg,TValue&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="factoryArgument" Type="TArg" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="9609c-227">El tipo de argumento que se pasará a <paramref name="addValueFactory" /> y <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-227">The type of an argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="9609c-228">Clave que se va a agregar o cuyo valor se va a actualizar.</span><span class="sxs-lookup"><span data-stu-id="9609c-228">The key to be added or whose value should be updated.</span></span></param>
        <param name="addValueFactory"><span data-ttu-id="9609c-229">Función que se usa para generar un valor para una clave ausente.</span><span class="sxs-lookup"><span data-stu-id="9609c-229">The function used to generate a value for an absent key.</span></span></param>
        <param name="updateValueFactory"><span data-ttu-id="9609c-230">Función que se usa para generar un nuevo valor para una clave existente basándose en el valor existente de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-230">The function used to generate a new value for an existing key based on the key's existing value.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="9609c-231">Argumento que se pasará a <paramref name="addValueFactory" /> y <paramref name="updateValueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-231">An argument to pass into <paramref name="addValueFactory" /> and <paramref name="updateValueFactory" />.</span></span></param>
        <summary><span data-ttu-id="9609c-232">Utiliza las funciones especificadas y un argumento para agregar un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe o para actualizar un par clave-valor de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-232">Uses the specified functions and argument to add a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist, or to update a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key already exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-233">Nuevo valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-233">The new value for the key.</span></span> <span data-ttu-id="9609c-234">Este será el resultado de <paramref name="addValueFactory" /> (si la clave no se encontró) o el de <paramref name="updateValueFactory" /> (si la clave se encontró).</span><span class="sxs-lookup"><span data-stu-id="9609c-234">This will be either be the result of <paramref name="addValueFactory" /> (if the key was absent) or the result of <paramref name="updateValueFactory" /> (if the key was present).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-235">Si se llama a <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultáneamente en subprocesos diferentes, `addValueFactory` puede llamarse varias veces, pero su par clave/valor no puede agregar al diccionario para cada llamada.</span><span class="sxs-lookup"><span data-stu-id="9609c-235">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> simultaneously on different threads, `addValueFactory` may be called multiple times, but its key/value pair might not be added to the dictionary for every call.</span></span>  

 <span data-ttu-id="9609c-236">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-236">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-237">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, el `addValueFactory` y `updateValueFactory` delegados se denominan fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-237">(Read operations on the dictionary are performed in a lock-free manner.) However, the `addValueFactory` and `updateValueFactory` delegates are called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-238">Por lo tanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> no es atómico con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-238">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-239"><paramref name="key" />, <paramref name="addValueFactory" /> o <paramref name="updateValueFactory" /> es una referencia nula (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9609c-239"><paramref name="key" />, <paramref name="addValueFactory" />, or <paramref name="updateValueFactory" /> is a null reference (Nothing in Visual Basic).</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-240">El diccionario contiene demasiados elementos.</span><span class="sxs-lookup"><span data-stu-id="9609c-240">The dictionary contains too many elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="concurrentDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-241">Quita todas las claves y valores de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-241">Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-242">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-242">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-243">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-243">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="concurrentDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-244">Clave que se buscará en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-244">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="9609c-245">Determina si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiene la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="9609c-245">Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains the specified key.</span></span></summary>
        <returns><span data-ttu-id="9609c-246"><see langword="true" /> si la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-246"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-247">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-247"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-248">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-248">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-249">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-249">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-250">Obtiene el número de pares clave-valor incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-250">Gets the number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-251">Número de pares clave-valor incluidos en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-251">The number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-252">Esta propiedad tiene semántica de instantánea y representa el número de elementos de la <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> en el momento cuando se tiene acceso a la propiedad.</span><span class="sxs-lookup"><span data-stu-id="9609c-252">This property has snapshot semantics and represents the number of items in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> at the moment when the property was accessed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-253">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-253">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-254">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-254">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-255">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-255">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="concurrentDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__35))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.ConcurrentDictionary`2/&lt;GetEnumerator&gt;d__34))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-256">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-256">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-257">Enumerador para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-257">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-258">El enumerador devuelto por el diccionario es seguro usar simultáneamente con lecturas y escrituras en el diccionario, pero no representa una instantánea en el momento del tiempo del diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-258">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="9609c-259">El contenido expuesto a través del enumerador puede contener las modificaciones realizadas en el diccionario después <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> llamó.</span><span class="sxs-lookup"><span data-stu-id="9609c-259">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-260">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-260">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-261">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-261">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetOrAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9609c-262">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-262">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="9609c-263">Devuelve el nuevo valor, o el valor existente si ya existe la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-263">Returns the new value, or the existing value if the key already exists.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9609c-264">El ejemplo siguiente muestra cómo llamar a la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> método:</span><span class="sxs-lookup"><span data-stu-id="9609c-264">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#3)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-265">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-265">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-266">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-266">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, Func&lt;TKey,TValue&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, class System.Func`2&lt;!TKey, !TValue&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, valueFactory As Func(Of TKey, TValue)) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TValue&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Value&gt; -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-267">Clave del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-267">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="9609c-268">Función que se usa para generar un valor para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-268">The function used to generate a value for the key.</span></span></param>
        <summary><span data-ttu-id="9609c-269">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> utilizando la función especificada, si la clave no existe todavía.</span><span class="sxs-lookup"><span data-stu-id="9609c-269">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function if the key does not already exist.</span></span> <span data-ttu-id="9609c-270">Devuelve el nuevo valor, o el valor existente si existe la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-270">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-271">Valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-271">The value for the key.</span></span> <span data-ttu-id="9609c-272">Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-272">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="9609c-273">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-273">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-274">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, el `valueFactory` se llama al delegado fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-274">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-275">Por lo tanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> no es atómico con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-275">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="9609c-276">Puesto que se pueden insertar un clave y valor por otro subproceso mientras `valueFactory` es generar un valor, no puede confiar en que simplemente porque `valueFactory` ejecuta, su valor generado se inserta en el diccionario y se devolverá.</span><span class="sxs-lookup"><span data-stu-id="9609c-276">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="9609c-277">Si se llama a <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultáneamente en subprocesos diferentes, `valueFactory` puede llamarse varias veces, pero solo un par clave-valor se agregarán al diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-277">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="9609c-278">El valor devuelto depende de la presencia de la clave en el diccionario y si se inserta un valor de clave por otro subproceso después <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> se denomina pero antes `valueFactory` genera un valor:</span><span class="sxs-lookup"><span data-stu-id="9609c-278">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="9609c-279">Escenario</span><span class="sxs-lookup"><span data-stu-id="9609c-279">Scenario</span></span> | <span data-ttu-id="9609c-280">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="9609c-280">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="9609c-281">La clave ya está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-281">The key is already in the dictionary.</span></span> | <span data-ttu-id="9609c-282">Se devuelve el valor existente.</span><span class="sxs-lookup"><span data-stu-id="9609c-282">The existing value is returned.</span></span> |
 | <span data-ttu-id="9609c-283">La clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-283">The key is not in the dictionary.</span></span> <span data-ttu-id="9609c-284">`valueFactory` genera un valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-284">`valueFactory` generates a value.</span></span> <span data-ttu-id="9609c-285">En la nueva comprobación de la clave, no se encuentra ninguna clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-285">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="9609c-286">El valor de clave se inserta en el diccionario y se devuelve el valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-286">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="9609c-287">La clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-287">The key is not in the dictionary.</span></span> <span data-ttu-id="9609c-288">`valueFactory` genera un valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-288">`valueFactory` generates a value.</span></span> <span data-ttu-id="9609c-289">Mientras `valueFactory` es generar el valor, un subproceso diferente que inserta un valor para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-289">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="9609c-290">Después de `valueFactory` ejecuta y tras la nueva comprobación de la clave, se encuentra la clave insertada por el otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="9609c-290">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="9609c-291">Se devuelve el valor insertado por el otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="9609c-291">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-292"><paramref name="key" /> o <paramref name="valueFactory" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-292"><paramref name="key" /> or <paramref name="valueFactory" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-293">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-293">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-294">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-294">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-295">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-295">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd (key As TKey, value As TValue) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * 'Value -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-296">Clave del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-296">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-297">Valor que se va a agregar si la clave aún no existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-297">The value to be added, if the key does not already exist.</span></span></param>
        <summary><span data-ttu-id="9609c-298">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> si la clave no existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-298">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> if the key does not already exist.</span></span> <span data-ttu-id="9609c-299">Devuelve el nuevo valor, o el valor existente si existe la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-299">Returns the new value, or the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-300">Valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-300">The value for the key.</span></span> <span data-ttu-id="9609c-301">Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-301">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-302">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-302"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-303">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-303">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-304">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-304">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-305">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-305">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetOrAdd&lt;TArg&gt;">
      <MemberSignature Language="C#" Value="public TValue GetOrAdd&lt;TArg&gt; (TKey key, Func&lt;TKey,TArg,TValue&gt; valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrAdd&lt;TArg&gt;(!TKey key, class System.Func`3&lt;!TKey, !!TArg, !TValue&gt; valueFactory, !!TArg factoryArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAdd(Of TArg) (key As TKey, valueFactory As Func(Of TKey, TArg, TValue), factoryArgument As TArg) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg&gt;&#xA; TValue GetOrAdd(TKey key, Func&lt;TKey, TArg, TValue&gt; ^ valueFactory, TArg factoryArgument);" />
      <MemberSignature Language="F#" Value="member this.GetOrAdd : 'Key * Func&lt;'Key, 'Arg, 'Value&gt; * 'Arg -&gt; 'Value" Usage="concurrentDictionary.GetOrAdd (key, valueFactory, factoryArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="valueFactory" Type="System.Func&lt;TKey,TArg,TValue&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="factoryArgument" Type="TArg" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TArg"><span data-ttu-id="9609c-306">El tipo de argumento que se pasará a <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-306">The type of an argument to pass into <paramref name="valueFactory" />.</span></span></typeparam>
        <param name="key"><span data-ttu-id="9609c-307">Clave del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-307">The key of the element to add.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="9609c-308">Función que se usa para generar un valor para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-308">The function used to generate a value for the key.</span></span></param>
        <param name="factoryArgument"><span data-ttu-id="9609c-309">Valor de argumento que se pasará a <paramref name="valueFactory" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-309">An argument value to pass into <paramref name="valueFactory" />.</span></span></param>
        <summary><span data-ttu-id="9609c-310">Agrega un par clave-valor a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> mediante la función especificada y un argumento si la clave aún no existe, o devuelve el valor existente si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-310">Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> by using the specified function and an argument if the key does not already exist, or returns the existing value if the key exists.</span></span></summary>
        <returns><span data-ttu-id="9609c-311">Valor de la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-311">The value for the key.</span></span> <span data-ttu-id="9609c-312">Será el valor existente de la clave si esta ya existe en el diccionario o será un nuevo valor si la clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-312">This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks   
 <span data-ttu-id="9609c-313">Para las modificaciones y las operaciones de escritura en el diccionario, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> bloqueo específico se utiliza para garantizar la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9609c-313">For modifications and write operations to the dictionary, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> uses fine-grained locking to ensure thread safety.</span></span> <span data-ttu-id="9609c-314">(Las operaciones de lectura en el diccionario se realizan de forma libre de bloqueo). Sin embargo, el `valueFactory` se llama al delegado fuera de los bloqueos para evitar los problemas que pueden surgir ejecutar código desconocido en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="9609c-314">(Read operations on the dictionary are performed in a lock-free manner.) However, the `valueFactory` delegate is called outside the locks to avoid the problems that can arise from executing unknown code under a lock.</span></span> <span data-ttu-id="9609c-315">Por lo tanto, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> no es atómico con respecto a todas las operaciones en el <xref:System.Collections.Concurrent.ConcurrentDictionary%602> clase.</span><span class="sxs-lookup"><span data-stu-id="9609c-315">Therefore, <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is not atomic with regards to all other operations on the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> class.</span></span>  

 <span data-ttu-id="9609c-316">Puesto que se pueden insertar un clave y valor por otro subproceso mientras `valueFactory` es generar un valor, no puede confiar en que simplemente porque `valueFactory` ejecuta, su valor generado se inserta en el diccionario y se devolverá.</span><span class="sxs-lookup"><span data-stu-id="9609c-316">Since a key/value can be inserted by another thread while `valueFactory` is generating a value, you cannot trust that just because `valueFactory` executed, its produced value will be inserted into the dictionary and returned.</span></span> <span data-ttu-id="9609c-317">Si se llama a <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultáneamente en subprocesos diferentes, `valueFactory` puede llamarse varias veces, pero solo un par clave-valor se agregarán al diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-317">If you call <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> simultaneously on different threads, `valueFactory` may be called multiple times, but only one key/value pair will be added to the dictionary.</span></span> 
 
 <span data-ttu-id="9609c-318">El valor devuelto depende de la presencia de la clave en el diccionario y si se inserta un valor de clave por otro subproceso después <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> se denomina pero antes `valueFactory` genera un valor:</span><span class="sxs-lookup"><span data-stu-id="9609c-318">The return value depends on the presence of the key in the dictionary and whether a key/value is inserted by another thread after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetOrAdd%2A> is called but before `valueFactory` generates a value:</span></span>

 | <span data-ttu-id="9609c-319">Escenario</span><span class="sxs-lookup"><span data-stu-id="9609c-319">Scenario</span></span> | <span data-ttu-id="9609c-320">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="9609c-320">Return value</span></span> |
 | -------- | ------------ |
 | <span data-ttu-id="9609c-321">La clave ya está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-321">The key is already in the dictionary.</span></span> | <span data-ttu-id="9609c-322">Se devuelve el valor existente.</span><span class="sxs-lookup"><span data-stu-id="9609c-322">The existing value is returned.</span></span> |
 | <span data-ttu-id="9609c-323">La clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-323">The key is not in the dictionary.</span></span> <span data-ttu-id="9609c-324">`valueFactory` genera un valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-324">`valueFactory` generates a value.</span></span> <span data-ttu-id="9609c-325">En la nueva comprobación de la clave, no se encuentra ninguna clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-325">On rechecking for the key, no key is found.</span></span> | <span data-ttu-id="9609c-326">El valor de clave se inserta en el diccionario y se devuelve el valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-326">The key/value is inserted into the dictionary, and the value is returned.</span></span> |
 | <span data-ttu-id="9609c-327">La clave no está en el diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-327">The key is not in the dictionary.</span></span> <span data-ttu-id="9609c-328">`valueFactory` genera un valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-328">`valueFactory` generates a value.</span></span> <span data-ttu-id="9609c-329">Mientras `valueFactory` es generar el valor, un subproceso diferente que inserta un valor para la clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-329">While `valueFactory` is generating the value, a different thread inserts a value for the key.</span></span> <span data-ttu-id="9609c-330">Después de `valueFactory` ejecuta y tras la nueva comprobación de la clave, se encuentra la clave insertada por el otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="9609c-330">After `valueFactory` executes and upon rechecking for the key, the key inserted by the other thread is found.</span></span> | <span data-ttu-id="9609c-331">Se devuelve el valor insertado por el otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="9609c-331">The value inserted by the other thread is returned.</span></span> |
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-332"><paramref name="key" /> es un <see langword="null" /> referencia (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9609c-332"><paramref name="key" /> is a <see langword="null" /> reference (Nothing in Visual Basic).</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-333">El diccionario contiene demasiados elementos.</span><span class="sxs-lookup"><span data-stu-id="9609c-333">The dictionary contains too many elements.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-334">Obtiene un valor que indica si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vacío.</span><span class="sxs-lookup"><span data-stu-id="9609c-334">Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty.</span></span></summary>
        <value><span data-ttu-id="9609c-335">Es <see langword="true" /> si <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> está vacío, en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-335"><see langword="true" /> if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> is empty; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-336">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-336">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-337">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-337">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-338">Clave del valor que se va a obtener o establecer.</span><span class="sxs-lookup"><span data-stu-id="9609c-338">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="9609c-339">Obtiene o establece el valor asociado a la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="9609c-339">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="9609c-340">El valor del par clave-valor situado en índice especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-340">The value of the key/value pair at the specified index.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-341"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-341"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException"><span data-ttu-id="9609c-342">La propiedad se recupera y <paramref name="key" /> no existe en la colección.</span><span class="sxs-lookup"><span data-stu-id="9609c-342">The property is retrieved and <paramref name="key" /> does not exist in the collection.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-343">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-343">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-344">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-344">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-345">Obtiene una colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-345">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-346">Colección de todas las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-346">A collection of keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-347">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-347">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-348">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-348">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><span data-ttu-id="9609c-349"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> que se va a agregar al diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-349">The <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to add to the dictionary.</span></span></param>
        <summary><span data-ttu-id="9609c-350">Agrega un elemento a la colección.</span><span class="sxs-lookup"><span data-stu-id="9609c-350">Adds an item to the collection.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-351">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-351">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-352">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-352">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><span data-ttu-id="9609c-353">Clave que se buscará en <see cref="T:System.Collections.Generic.ICollection`1" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-353">The key to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</span></span></param>
        <summary><span data-ttu-id="9609c-354">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> contiene un elemento con la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="9609c-354">Gets whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains an element with the specified key.</span></span></summary>
        <returns><span data-ttu-id="9609c-355"><see langword="true" /> si la colección <see cref="T:System.Collections.Generic.ICollection`1" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-355"><see langword="true" /> if the <see cref="T:System.Collections.Generic.ICollection`1" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-356">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-356">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-357">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-357">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="9609c-358">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-358">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="9609c-359">La matriz debe tener una indización de base cero.</span><span class="sxs-lookup"><span data-stu-id="9609c-359">The array must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="9609c-360">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</span><span class="sxs-lookup"><span data-stu-id="9609c-360">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="9609c-361">Copia los elementos <see cref="T:System.Collections.ICollection" /> en una matriz, comenzando en el índice especificado de la matriz.</span><span class="sxs-lookup"><span data-stu-id="9609c-361">Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an array, starting at the specified array index.</span></span></summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-362">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-362">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-363">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-363">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-364">Obtiene un valor que indica si <see cref="T:System.Collections.ICollection" /> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="9609c-364">Gets a value that indicates whether the <see cref="T:System.Collections.ICollection" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="9609c-365">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.ICollection" /> es de solo lectura; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-365"><see langword="true" /> if the <see cref="T:System.Collections.ICollection" /> is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-366">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-366">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-367">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-367">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><span data-ttu-id="9609c-368"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="9609c-368">The <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to remove.</span></span></param>
        <summary><span data-ttu-id="9609c-369">Quita el par clave-valor especificado de la colección.</span><span class="sxs-lookup"><span data-stu-id="9609c-369">Removes the specified key/value pair from the collection.</span></span></summary>
        <returns><span data-ttu-id="9609c-370">Es <see langword="true" /> si el elemento se quita correctamente; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-370"><see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9609c-371">Este método también devuelve false si no se encontró <paramref name="key" /> en la <see cref="T:System.Collections.Generic.ICollection`1" /> original.</span><span class="sxs-lookup"><span data-stu-id="9609c-371">This method also returns false if <paramref name="key" /> was not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-372">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-372">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-373">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-373">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;TKey,TValue&gt;.Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As TKey, value As TValue) Implements IDictionary(Of TKey, TValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Add(TKey key, TValue value) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-374">Objeto que se va a utilizar como clave del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-374">The object to use as the key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-375">El objeto que se va a usar como valor del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-375">The object to use as the value of the element to add.</span></span></param>
        <summary><span data-ttu-id="9609c-376">Agrega la clave y el valor especificados a <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-376">Adds the specified key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-377">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-377"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-378">Ya existe un elemento con la misma clave en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-378">An element with the same key already exists in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-379">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-379">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-380">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-380">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-381">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-381">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;TKey,TValue&gt;.Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As TKey) As Boolean Implements IDictionary(Of TKey, TValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Remove(TKey key) = System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-382">Clave del elemento que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="9609c-382">The key of the element to remove.</span></span></param>
        <summary><span data-ttu-id="9609c-383">Quita el elemento con la clave especificada de <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-383">Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-384">Es <see langword="true" /> si el elemento se quita correctamente; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-384"><see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9609c-385">Este método también devuelve <see langword="false" /> si no se encontró <paramref name="key" /> en el <see cref="T:System.Collections.Generic.IDictionary`2" /> original.</span><span class="sxs-lookup"><span data-stu-id="9609c-385">This method also returns <see langword="false" /> if <paramref name="key" /> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-386">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-386"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-387">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-387">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-388">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-388">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-389">Obtiene una colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-389">Gets a collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-390">Colección que contiene las claves de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-390">A collection containing the keys in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-391">Obtiene una colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-391">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-392">Colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-392">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="9609c-393">Matriz unidimensional que constituye el destino de los elementos copiados desde <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-393">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="9609c-394">La matriz debe tener una indización de base cero.</span><span class="sxs-lookup"><span data-stu-id="9609c-394">The array must have zero-based indexing.</span></span></param>
        <param name="index"><span data-ttu-id="9609c-395">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</span><span class="sxs-lookup"><span data-stu-id="9609c-395">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="9609c-396">Copia los elementos <see cref="T:System.Collections.ICollection" /> en una matriz, comenzando en el índice especificado de la matriz.</span><span class="sxs-lookup"><span data-stu-id="9609c-396">Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an array, starting at the specified array index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-397">El valor de <paramref name="array" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-397"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9609c-398"><paramref name="index" /> es menor que 0.</span><span class="sxs-lookup"><span data-stu-id="9609c-398"><paramref name="index" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-399"><paramref name="index" /> es igual o mayor que la longitud de la <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-399"><paramref name="index" /> is equal to or greater than the length of the <paramref name="array" />.</span></span>  
  
<span data-ttu-id="9609c-400">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-400">-or-</span></span> 
<span data-ttu-id="9609c-401">El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="9609c-401">The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-402">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-402">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-403">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-403">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-404">Obtiene un valor que indica si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado con SyncRoot.</span><span class="sxs-lookup"><span data-stu-id="9609c-404">Gets a value that indicates whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized with the SyncRoot.</span></span></summary>
        <value><span data-ttu-id="9609c-405">Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-405"><see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9609c-406">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> esta propiedad siempre devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-406">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-407">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-407">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-408">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-408">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-409">Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-409">Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</span></span> <span data-ttu-id="9609c-410">Esta propiedad no es compatible.</span><span class="sxs-lookup"><span data-stu-id="9609c-410">This property is not supported.</span></span></summary>
        <value><span data-ttu-id="9609c-411">Siempre devuelve null.</span><span class="sxs-lookup"><span data-stu-id="9609c-411">Always returns null.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9609c-412">Esta propiedad no es compatible.</span><span class="sxs-lookup"><span data-stu-id="9609c-412">This property is not supported.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-413">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-413">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-414">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-414">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-415">Objeto que se va a utilizar como clave.</span><span class="sxs-lookup"><span data-stu-id="9609c-415">The object to use as the key.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-416">Objeto que se va a utilizar como valor.</span><span class="sxs-lookup"><span data-stu-id="9609c-416">The object to use as the value.</span></span></param>
        <summary><span data-ttu-id="9609c-417">Agrega la clave y el valor especificados al diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-417">Adds the specified key and value to the dictionary.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-418">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-418"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-419"><paramref name="key" /> es de un tipo que no se puede asignar al tipo de clave de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-419"><paramref name="key" /> is of a type that is not assignable to the key type  of the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="9609c-420">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-420">-or-</span></span> 
 <span data-ttu-id="9609c-421"><paramref name="value" /> es de un tipo que no se puede asignar al tipo de valores en el <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-421"><paramref name="value" /> is of a type that is not assignable to the type of values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span>  
  
<span data-ttu-id="9609c-422">-o bien-</span><span class="sxs-lookup"><span data-stu-id="9609c-422">-or-</span></span> 
<span data-ttu-id="9609c-423">Un valor con la misma clave ya existe en el <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-423">A value with the same key already exists in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-424">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-424">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-425">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-425">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-426">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-426">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-427">Clave que se buscará en <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-427">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></param>
        <summary><span data-ttu-id="9609c-428">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="9609c-428">Gets a value that indicates the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key.</span></span></summary>
        <returns><span data-ttu-id="9609c-429"><see langword="true" /> si la colección <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-429"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-430">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-430"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-431">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-431">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-432">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-432">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-433">Proporciona un <see cref="T:System.Collections.IDictionaryEnumerator" /> para <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-433">Provides a <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-434">Estructura <see cref="T:System.Collections.IDictionaryEnumerator" /> para la colección <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-434">A <see cref="T:System.Collections.IDictionaryEnumerator" /> for the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-435">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-435">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-436">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-436">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-437">Obtiene un valor que indica si el objeto <see cref="T:System.Collections.Generic.IDictionary`2" /> tiene un tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="9609c-437">Gets a value that indicates whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="9609c-438">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-438"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> has a fixed size; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9609c-439">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, esta propiedad siempre devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-439">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-440">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-440">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-441">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-441">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-442">Obtiene un valor que indica si <see cref="T:System.Collections.Generic.IDictionary`2" /> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="9609c-442">Gets a value that indicates whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="9609c-443">Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> es de solo lectura; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-443"><see langword="true" /> if the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9609c-444">Para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, esta propiedad siempre devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-444">For <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, this property always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-445">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-445">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-446">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-446">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-447">Clave del valor que se va a obtener o establecer.</span><span class="sxs-lookup"><span data-stu-id="9609c-447">The key of the value to get or set.</span></span></param>
        <summary><span data-ttu-id="9609c-448">Obtiene o establece el valor asociado a la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="9609c-448">Gets or sets the value associated with the specified key.</span></span></summary>
        <value><span data-ttu-id="9609c-449">Valor asociado a la clave especificada, o <see langword="null" /> si <paramref name="key" /> no está en el diccionario o si <paramref name="key" /> es de un tipo no asignable al tipo de clave de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-449">The value associated with the specified key, or  <see langword="null" /> if <paramref name="key" /> is not in the dictionary or <paramref name="key" /> is of a type that is not assignable to the key type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-450"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-450"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9609c-451">Se está asignando un valor, y <paramref name="key" /> es de un tipo no asignable al tipo de clave o el tipo de valor de la <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-451">A value is being assigned, and <paramref name="key" /> is of a type that is not assignable to the key type or the value type of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-452">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-452">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-453">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-453">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-454">Obtiene un elemento <see cref="T:System.Collections.ICollection" /> que contiene las claves de <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-454">Gets an <see cref="T:System.Collections.ICollection" /> that contains the keys of the  <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-455">Interfaz que contiene las claves de <see cref="T:System.Collections.Generic.IDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-455">An interface that contains the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-456">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-456">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-457">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-457">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-458">Clave del elemento que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="9609c-458">The key of the element to remove.</span></span></param>
        <summary><span data-ttu-id="9609c-459">Quita el elemento con la clave especificada de <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-459">Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-460">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-460"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-461">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-461">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-462">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-462">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-463">Obtiene un <see cref="T:System.Collections.ICollection" /> que contiene los valores de <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-463">Gets an <see cref="T:System.Collections.ICollection" /> that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></summary>
        <value><span data-ttu-id="9609c-464">Interfaz que contiene los valores de <see cref="T:System.Collections.IDictionary" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-464">An interface that contains the values in the <see cref="T:System.Collections.IDictionary" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-465">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-465">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-466">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-466">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-467">Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-467">Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-468">Enumerador para <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-468">An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-469">El enumerador devuelto por el diccionario es seguro usar simultáneamente con lecturas y escrituras en el diccionario, pero no representa una instantánea en el momento del tiempo del diccionario.</span><span class="sxs-lookup"><span data-stu-id="9609c-469">The enumerator returned from the dictionary is safe to use concurrently with reads and writes to the dictionary, however it does not represent a moment-in-time snapshot of the dictionary.</span></span> <span data-ttu-id="9609c-470">El contenido expuesto a través del enumerador puede contener las modificaciones realizadas en el diccionario después <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> llamó.</span><span class="sxs-lookup"><span data-stu-id="9609c-470">The contents exposed through the enumerator may contain modifications made to the dictionary after <xref:System.Collections.Concurrent.ConcurrentDictionary%602.GetEnumerator%2A> was called.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-471">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-471">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-472">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-472">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As KeyValuePair(Of TKey, TValue)()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[]" Usage="concurrentDictionary.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9609c-473">Copia en una nueva matriz los pares valor-clave almacenados en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /></span><span class="sxs-lookup"><span data-stu-id="9609c-473">Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> to a new array.</span></span></summary>
        <returns><span data-ttu-id="9609c-474">Nueva matriz que contiene una instantánea de los pares clave-valor copiados de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-474">A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-475">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-475">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-476">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-476">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'Key * 'Value -&gt; bool" Usage="concurrentDictionary.TryAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-477">Clave del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-477">The key of the element to add.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-478">Valor del elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="9609c-478">The value of the element to add.</span></span> <span data-ttu-id="9609c-479">El valor puede ser <see langword="null" /> para los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="9609c-479">The value can be  <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="9609c-480">Intenta agregar la clave y el valor especificados a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-480">Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-481">Es <see langword="true" /> si el par clave-valor se agregó a <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> correctamente; es <see langword="false" /> si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-481"><see langword="true" /> if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> successfully; <see langword="false" /> if the key already exists.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9609c-482">Este método devuelve `false` si la clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-482">This method returns `false` if the key already exists.</span></span> <span data-ttu-id="9609c-483">Use la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> o <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> método para actualizar el valor en caso de una clave ya existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-483">Use the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> or <xref:System.Collections.Concurrent.ConcurrentDictionary%602.AddOrUpdate%2A> method to update the value in case a key already exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9609c-484">El ejemplo siguiente muestra cómo llamar a la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> método:</span><span class="sxs-lookup"><span data-stu-id="9609c-484">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryAdd%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-485"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-485"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="9609c-486">El diccionario ya contiene el número máximo de elementos (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="9609c-486">The dictionary already contains the maximum number of elements (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-487">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-487">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-488">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-488">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-489">Clave del valor que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="9609c-489">The key of the value to get.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-490">Cuando este método devuelve un valor, contiene el objeto del elemento <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> con la clave especificada o el valor predeterminado del tipo si se produjo un error en la operación.</span><span class="sxs-lookup"><span data-stu-id="9609c-490">When this method returns, contains the object from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> that has the specified key, or the default value of the type if the operation failed.</span></span></param>
        <summary><span data-ttu-id="9609c-491">Intenta obtener el valor asociado a la clave especificada de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-491">Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-492">Es <see langword="true" /> si se encontró la clave en <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-492"><see langword="true" /> if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-493"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-493"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-494">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-494">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-495">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-495">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryRemove">
      <MemberSignature Language="C#" Value="public bool TryRemove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryRemove(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryRemove (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryRemove(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryRemove : 'Key *  -&gt; bool" Usage="concurrentDictionary.TryRemove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-496">Clave del elemento que se va a quitar y devolver.</span><span class="sxs-lookup"><span data-stu-id="9609c-496">The key of the element to remove and return.</span></span></param>
        <param name="value"><span data-ttu-id="9609c-497">Cuando este método devuelve un valor, contiene el objeto quitado de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, o el valor predeterminado del tipo <see langword="TValue" /> si <paramref name="key" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="9609c-497">When this method returns, contains the object removed from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />, or the default value of  the <see langword="TValue" /> type if <paramref name="key" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="9609c-498">Intenta quitar y devolver el valor que tiene la clave especificada de <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-498">Attempts to remove and return the value that has the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-499">Es <see langword="true" /> si el objeto se ha quitado correctamente; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-499"><see langword="true" /> if the object was removed successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9609c-500">El ejemplo siguiente muestra cómo llamar a la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> método:</span><span class="sxs-lookup"><span data-stu-id="9609c-500">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryRemove%2A?displayProperty=nameWithType> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-501"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-501"><paramref name="key" /> is  <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-502">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-502">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-503">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-503">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryUpdate">
      <MemberSignature Language="C#" Value="public bool TryUpdate (TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUpdate(!TKey key, !TValue newValue, !TValue comparisonValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUpdate (key As TKey, newValue As TValue, comparisonValue As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);" />
      <MemberSignature Language="F#" Value="member this.TryUpdate : 'Key * 'Value * 'Value -&gt; bool" Usage="concurrentDictionary.TryUpdate (key, newValue, comparisonValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="newValue" Type="TValue" />
        <Parameter Name="comparisonValue" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="9609c-504">Clave cuyo valor se compara con <paramref name="comparisonValue" /> y que posiblemente se reemplace.</span><span class="sxs-lookup"><span data-stu-id="9609c-504">The key of the value that is compared with <paramref name="comparisonValue" /> and possibly replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="9609c-505">Valor que reemplaza el valor del elemento que tiene la <paramref name="key" /> especificada si al compararlos se determina que son iguales.</span><span class="sxs-lookup"><span data-stu-id="9609c-505">The value that replaces the value of the element that has the specified <paramref name="key" /> if the comparison results in equality.</span></span></param>
        <param name="comparisonValue"><span data-ttu-id="9609c-506">Valor que se compara con el valor del elemento que tiene el elemento <paramref name="key" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="9609c-506">The value that is compared with the value of the element that has the specified <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="9609c-507">Actualiza el valor asociado a <paramref name="key" /> a <paramref name="newValue" /> si el valor existente con <paramref name="key" /> es igual a <paramref name="comparisonValue" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-507">Updates the value associated with <paramref name="key" /> to <paramref name="newValue" /> if the existing value with <paramref name="key" /> is equal to <paramref name="comparisonValue" />.</span></span></summary>
        <returns><span data-ttu-id="9609c-508">Es <see langword="true" /> si el valor con <paramref name="key" /> era igual a <paramref name="comparisonValue" /> y se sustituyó por <paramref name="newValue" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-508"><see langword="true" /> if the value with <paramref name="key" /> was equal to <paramref name="comparisonValue" /> and was replaced with <paramref name="newValue" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9609c-509">El ejemplo siguiente muestra cómo llamar a la <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> método:</span><span class="sxs-lookup"><span data-stu-id="9609c-509">The following example shows how to call the <xref:System.Collections.Concurrent.ConcurrentDictionary%602.TryUpdate%2A> method:</span></span>  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/cs/concdictionary.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentdictionary/vb/concdictionary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9609c-510">El valor de <paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-510"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-511">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-511">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-512">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-512">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Concurrent.ConcurrentDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9609c-513">Obtiene una colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-513">Gets a collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></summary>
        <value><span data-ttu-id="9609c-514">Colección que contiene los valores de <see cref="T:System.Collections.Generic.Dictionary`2" />.</span><span class="sxs-lookup"><span data-stu-id="9609c-514">A collection that contains the values in the <see cref="T:System.Collections.Generic.Dictionary`2" />.</span></span></value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd"><span data-ttu-id="9609c-515">Colecciones seguras para subprocesos</span><span class="sxs-lookup"><span data-stu-id="9609c-515">Thread-Safe Collections</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/81b64b95-13f7-4532-9249-ab532f629598"><span data-ttu-id="9609c-516">Procedimiento para agregar y quitar elementos de ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="9609c-516">How to: Add and Remove Items from a ConcurrentDictionary</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>