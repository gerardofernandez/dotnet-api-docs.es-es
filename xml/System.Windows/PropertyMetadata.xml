<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="423f853a60d99a5767f47d8a9e4d3ef0dce3cb15" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39845063" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="5842e-101">Define ciertos aspectos de comportamiento de una propiedad de dependencia tal como se aplica a un tipo específico, incluidas las condiciones con las que se registró.</span><span class="sxs-lookup"><span data-stu-id="5842e-101">Defines certain behavior aspects of a dependency property as it is applied to a specific type, including conditions it was registered with.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-102">Los metadatos de propiedad pueden definirse y se usa durante el registro de la propiedad de dependencia cuando se llama a la <xref:System.Windows.DependencyProperty.Register%2A> método (o variaciones para las propiedades adjuntas o las propiedades de dependencia de solo lectura), o después del registro de propietario original cuando se llama a la <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5842e-102">Property metadata can be defined and used during dependency property registration when calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or variations for attached properties or read-only dependency properties), or after original owner registration when calling the <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> method.</span></span> <span data-ttu-id="5842e-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> También toma los metadatos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-103"><xref:System.Windows.DependencyProperty.AddOwner%2A> also takes property metadata.</span></span>  
  
 <span data-ttu-id="5842e-104">Esta clase es una clase base concreta que se puede usar en cada una de estas llamadas.</span><span class="sxs-lookup"><span data-stu-id="5842e-104">This class is a concrete base class that can be used in each of these calls.</span></span> <span data-ttu-id="5842e-105">Sin embargo, es muy común para especificar los metadatos mediante una de las clases derivadas como <xref:System.Windows.FrameworkPropertyMetadata>.</span><span class="sxs-lookup"><span data-stu-id="5842e-105">However, it is very common to specify metadata using one of the derived classes such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="5842e-106">Estas clases derivadas admiten metadatos más detallados incluidos como valores de propiedad booleano, que son útiles para detectar o habilitar algunos comportamientos de diseño y el sistema de propiedad sólo se implementan en el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] nivel de marco.</span><span class="sxs-lookup"><span data-stu-id="5842e-106">These derived classes support more detailed metadata carried as Boolean property values, which are useful for either detecting or enabling some property system and layout behaviors that are only implemented at the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework level.</span></span>  
  
 <span data-ttu-id="5842e-107">Varias propiedades de esta clase son lectura y escritura para el modelo de objetos, pero solo se pueden escribir antes de la instancia que se va a usar en una operación de propiedad del sistema, como <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="5842e-107">Several properties of this class are read-write to the object model, but can only be written prior to the instance being used in a property system operation such as <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>.</span></span> <span data-ttu-id="5842e-108">Cada una de estas propiedades también se podría haber establecido por el constructor, pero se exponen para que <xref:System.Windows.PropertyMetadata.Merge%2A> las implementaciones de método pueden establecerlas.</span><span class="sxs-lookup"><span data-stu-id="5842e-108">Each of these properties could also have been set by the constructor but are exposed so that <xref:System.Windows.PropertyMetadata.Merge%2A> method implementations can set them.</span></span>  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="5842e-109">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="5842e-109">XAML Text Usage</span></span>  
 <span data-ttu-id="5842e-110">Este tipo y los miembros de este tipo, no se utilizan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5842e-110">This type, and members of this type, are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5842e-111">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-111">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="5842e-112">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-112">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="5842e-113">Valor predeterminado que se especifica para una propiedad de dependencia, proporcionado normalmente como un valor de algún tipo específico.</span><span class="sxs-lookup"><span data-stu-id="5842e-113">The default value to specify for a dependency property, usually provided as a value of some specific type.</span></span></param>
        <summary><span data-ttu-id="5842e-114">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" /> con un valor predeterminado especificado para la propiedad de dependencia a la que se aplicarán estos metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-114">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with a specified default value for the dependency property that this metadata will be applied to.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-115">El tipo del valor proporcionado para `defaultValue` debe coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a.</span><span class="sxs-lookup"><span data-stu-id="5842e-115">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="5842e-116">Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación (el error de coincidencia producirá una excepción en tiempo de ejecución).</span><span class="sxs-lookup"><span data-stu-id="5842e-116">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="5842e-117">Aunque es el valor predeterminado por el constructor sin parámetros, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> no se puede especificar.</span><span class="sxs-lookup"><span data-stu-id="5842e-117">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="5842e-118">Si intenta hacerlo, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-118">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5842e-119"><paramref name="defaultValue" /> no se puede establecer en el valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-119"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback"><span data-ttu-id="5842e-120">Referencia a una implementación de controlador a la que va a llamar el sistema de propiedades cada vez que cambie el valor real de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-120">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="5842e-121">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" /> con la referencia de implementación de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="5842e-121">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="5842e-122">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de algún tipo específico.</span><span class="sxs-lookup"><span data-stu-id="5842e-122">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="5842e-123">Referencia a una implementación de controlador a la que va a llamar el sistema de propiedades cada vez que cambie el valor real de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-123">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <summary><span data-ttu-id="5842e-124">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" /> con el valor predeterminado y la referencia de implementación de <see cref="T:System.Windows.PropertyChangedCallback" /> especificados.</span><span class="sxs-lookup"><span data-stu-id="5842e-124">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-125">El tipo del valor proporcionado `defaultValue` debe coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a.</span><span class="sxs-lookup"><span data-stu-id="5842e-125">The type of the value provided `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="5842e-126">Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación (el error de coincidencia producirá una excepción en tiempo de ejecución).</span><span class="sxs-lookup"><span data-stu-id="5842e-126">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="5842e-127">Aunque es el valor predeterminado por el constructor sin parámetros, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> no se puede especificar.</span><span class="sxs-lookup"><span data-stu-id="5842e-127">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="5842e-128">Si intenta hacerlo, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-128">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5842e-129"><paramref name="defaultValue" /> no se puede establecer en el valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-129"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue"><span data-ttu-id="5842e-130">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de algún tipo específico.</span><span class="sxs-lookup"><span data-stu-id="5842e-130">The default value of the dependency property, usually provided as a value of some specific type.</span></span></param>
        <param name="propertyChangedCallback"><span data-ttu-id="5842e-131">Referencia a una implementación de controlador a la que va a llamar el sistema de propiedades cada vez que cambie el valor real de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-131">Reference to a handler implementation that is to be called by the property system whenever the effective value of the property changes.</span></span></param>
        <param name="coerceValueCallback"><span data-ttu-id="5842e-132">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-132">Reference to a handler implementation that is to be called whenever the property system calls <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> against this property.</span></span></param>
        <summary><span data-ttu-id="5842e-133">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.PropertyMetadata" /> con el valor predeterminado y las devoluciones de llamada especificados.</span><span class="sxs-lookup"><span data-stu-id="5842e-133">Initializes a new instance of the <see cref="T:System.Windows.PropertyMetadata" /> class with the specified default value and callbacks.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-134">Si desea especificar un <xref:System.Windows.CoerceValueCallback> pero no un <xref:System.Windows.PropertyChangedCallback>, puede pasar `null` para el `propertyChangedCallback` parámetro.</span><span class="sxs-lookup"><span data-stu-id="5842e-134">If you want to specify a <xref:System.Windows.CoerceValueCallback> but not a <xref:System.Windows.PropertyChangedCallback>, you can pass `null` for the `propertyChangedCallback` parameter.</span></span>  
  
 <span data-ttu-id="5842e-135">El tipo del valor proporcionado para `defaultValue` debe coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a.</span><span class="sxs-lookup"><span data-stu-id="5842e-135">The type of the value provided for `defaultValue` must be match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</span></span> <span data-ttu-id="5842e-136">Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación (el error de coincidencia producirá una excepción en tiempo de ejecución).</span><span class="sxs-lookup"><span data-stu-id="5842e-136">Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation (the mismatch will raise a run-time exception).</span></span>  
  
 <span data-ttu-id="5842e-137">Aunque es el valor predeterminado por el constructor sin parámetros, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> no se puede especificar.</span><span class="sxs-lookup"><span data-stu-id="5842e-137">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be specified.</span></span> <span data-ttu-id="5842e-138">Si intenta hacerlo, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-138">Attempting to do so will raise an exception.</span></span>  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5842e-139"><paramref name="defaultValue" /> no se puede establecer en el valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-139"><paramref name="defaultValue" /> cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5842e-140">Obtiene o establece una referencia a una implementación de <see cref="T:System.Windows.CoerceValueCallback" /> especificada en estos metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-140">Gets or sets a reference to a <see cref="T:System.Windows.CoerceValueCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="5842e-141">Referencia de implementación de <see cref="T:System.Windows.CoerceValueCallback" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-141">A <see cref="T:System.Windows.CoerceValueCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-142">Las devoluciones de llamada en los metadatos de propiedad no son miembros públicos normalmente en el tipo contenedor, por lo que el valor de esta propiedad no es importante para la mayoría de los escenarios que simplemente utilizan los metadatos de una propiedad de dependencia existente.</span><span class="sxs-lookup"><span data-stu-id="5842e-142">The callbacks in property metadata are not typically public members on the containing type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="5842e-143">Una razón se expone esta propiedad es para que las subclases de metadatos pueden realizar la lógica de combinación si especifican metadatos base y metadatos de invalidación o agregando un <xref:System.Windows.CoerceValueCallback>.</span><span class="sxs-lookup"><span data-stu-id="5842e-143">One reason this property is exposed is so that metadata subclasses can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.CoerceValueCallback>.</span></span> <span data-ttu-id="5842e-144">Sin embargo, el valor predeterminado de mezcla lógica para un <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> consiste en reemplazar el anterior.</span><span class="sxs-lookup"><span data-stu-id="5842e-144">However, the default merge logic for a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is to replace the previous one.</span></span>  
  
 <span data-ttu-id="5842e-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se define en el modelo de objetos de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="5842e-145"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="5842e-146">Esto sucede así <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se pueden ajustar después de la inicialización de la <xref:System.Windows.PropertyMetadata> propio objeto.</span><span class="sxs-lookup"><span data-stu-id="5842e-146">This is so <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="5842e-147">Sin embargo, una vez que se consumen los metadatos como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y las propiedades se consideran inmutables.</span><span class="sxs-lookup"><span data-stu-id="5842e-147">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="5842e-148">Se intentó establecer <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> una vez <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-148">Attempting to set <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5842e-149">No se puede establecer una propiedad de metadatos una vez que se aplica a una operación de propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="5842e-149">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5842e-150">Obtiene o establece el valor predeterminado de la propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="5842e-150">Gets or sets the default value of the dependency property.</span></span></summary>
        <value><span data-ttu-id="5842e-151">Valor predeterminado de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-151">The default value of the property.</span></span> <span data-ttu-id="5842e-152">El valor predeterminado en un <see cref="T:System.Windows.PropertyMetadata" /> instancia creada con el constructor sin parámetros será <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-152">The default value on a <see cref="T:System.Windows.PropertyMetadata" /> instance created with the parameterless constructor will be <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> se define en el modelo de objetos de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="5842e-153"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="5842e-154">Esto sucede así <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se pueden ajustar después de la inicialización de la <xref:System.Windows.PropertyMetadata> propio objeto.</span><span class="sxs-lookup"><span data-stu-id="5842e-154">This is so <xref:System.Windows.PropertyMetadata.DefaultValue%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="5842e-155">Sin embargo, una vez que se consumen los metadatos como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y las propiedades se consideran inmutables.</span><span class="sxs-lookup"><span data-stu-id="5842e-155">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="5842e-156">Se intentó establecer <xref:System.Windows.PropertyMetadata.DefaultValue%2A> una vez <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-156">Attempting to set <xref:System.Windows.PropertyMetadata.DefaultValue%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 <span data-ttu-id="5842e-157">Aunque es el valor predeterminado por el constructor sin parámetros, un `defaultValue` de <xref:System.Windows.DependencyProperty.UnsetValue> no se puede establecer mediante <xref:System.Windows.PropertyMetadata.DefaultValue%2A> o el constructor.</span><span class="sxs-lookup"><span data-stu-id="5842e-157">Although it is the default per the parameterless constructor, a `defaultValue` of <xref:System.Windows.DependencyProperty.UnsetValue> cannot be set using either <xref:System.Windows.PropertyMetadata.DefaultValue%2A> or the constructor.</span></span> <span data-ttu-id="5842e-158">Si intenta hacerlo, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-158">Attempting to do so will raise an exception.</span></span>  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a><span data-ttu-id="5842e-159">Uso de texto XAML</span><span class="sxs-lookup"><span data-stu-id="5842e-159">XAML Text Usage</span></span>  
 <span data-ttu-id="5842e-160">Los miembros de este tipo no se utilizan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5842e-160">Members of this type are not typically used in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="5842e-161">No se puede establecer en el valor <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> tras su creación.</span><span class="sxs-lookup"><span data-stu-id="5842e-161">Cannot be set to the value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> once created.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5842e-162">No se puede establecer una propiedad de metadatos una vez que se aplica a una operación de propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="5842e-162">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5842e-163">Obtiene un valor que determina si se han aplicado los metadatos a una propiedad de alguna manera, lo que ha producido el estado inmutable de esta instancia de metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-163">Gets a value that determines whether the metadata has been applied to a property in some way, resulting in the immutable state of that metadata instance.</span></span></summary>
        <value><span data-ttu-id="5842e-164"><see langword="true" /> si la instancia de metadatos es inmutable; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-164"><see langword="true" /> if the metadata instance is immutable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-165">Las distintas propiedades de <xref:System.Windows.PropertyMetadata>, tales como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, se definen en el modelo de objetos de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="5842e-165">Various properties of <xref:System.Windows.PropertyMetadata>, such as <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, are defined in the object model as read-write.</span></span> <span data-ttu-id="5842e-166">Esto es para que dichas propiedades se pueden ajustar después de la inicialización de la <xref:System.Windows.PropertyMetadata> propio objeto.</span><span class="sxs-lookup"><span data-stu-id="5842e-166">This is so those properties can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="5842e-167">Sin embargo, una vez que los metadatos se aplican a una propiedad de dependencia como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y las propiedades se consideran inmutables.</span><span class="sxs-lookup"><span data-stu-id="5842e-167">However, once the metadata is applied to a dependency property as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="5842e-168">En el momento de una de estas llamadas, <xref:System.Windows.PropertyMetadata.OnApply%2A> se llama a, y el valor de esta propiedad se establece en `true`.</span><span class="sxs-lookup"><span data-stu-id="5842e-168">At the time of one of these calls, <xref:System.Windows.PropertyMetadata.OnApply%2A> is called, and the value of this property is set to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5842e-169">El ejemplo siguiente se comprueba <xref:System.Windows.PropertyMetadata.IsSealed%2A> antes de una operación de establecimiento de una propiedad de metadatos personalizados.</span><span class="sxs-lookup"><span data-stu-id="5842e-169">The following example  checks <xref:System.Windows.PropertyMetadata.IsSealed%2A> prior to a set operation of a custom metadata property.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata"><span data-ttu-id="5842e-170">Metadatos base para combinar con los valores de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="5842e-170">The base metadata to merge with this instance's values.</span></span></param>
        <param name="dp"><span data-ttu-id="5842e-171">Propiedad de dependencia a la que se aplican estos metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-171">The dependency property to which this metadata is being applied.</span></span></param>
        <summary><span data-ttu-id="5842e-172">Combina estos metadatos con los metadatos base.</span><span class="sxs-lookup"><span data-stu-id="5842e-172">Merges this metadata with the base metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-173">Este método se usa internamente cuando se invalida los metadatos (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método).</span><span class="sxs-lookup"><span data-stu-id="5842e-173">This method is used internally when metadata is being overridden (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5842e-174">El ejemplo siguiente implementa una combinación de un tipo de metadatos personalizados que agrega una propiedad adicional a los metadatos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="5842e-174">The following example implements a merge for a custom metadata type that adds an additional property to the property metadata.</span></span>  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><span data-ttu-id="5842e-175"><para>Las implementaciones que se derivan de la clase <see cref="T:System.Windows.PropertyMetadata" /> deben invalidar este método para tener en cuenta las propiedades de metadatos que hayan agregado en sus implementaciones. Por ejemplo, su implementación podría haber agregado un nuevo valor de enumeración basada en marcas y el <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementación, a continuación, podrá combinar esos indicadores correctamente.  Llame siempre a la implementación base antes que el código de implementación, ya que la implementación base se ocupa de combinar todas las propiedades ya definidas en el <see cref="T:System.Windows.PropertyMetadata" /> tipo.  El comportamiento exacto de la combinación es decisión suya. Puede elegir tener valores combinados, revierta al valor base si se han dejado los metadatos derivados en el valor predeterminado, o muchos otros comportamientos basados en los tipos de propiedades que se ha agregado a la clase de metadatos concreto y sus significados.</para></span><span class="sxs-lookup"><span data-stu-id="5842e-175"><para>Class implementations that derive from <see cref="T:System.Windows.PropertyMetadata" /> should override this method to account for any metadata properties they have added in their implementations. For instance, your implementation might have added a new flagwise enumeration value, and the <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementation should then be able to combine those flags correctly.  Always call the base implementation prior to your implementation code, because the base implementation takes care of merging all the properties already defined on the <see cref="T:System.Windows.PropertyMetadata" /> type.  The exact behavior of the merge is up to you. You could choose to have values combined, revert to base value if the derived metadata were left at the default, or many other behaviors based on the types of properties you have added to your particular metadata class, and their meanings.</para></span></span></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="5842e-176">Propiedad de dependencia a la que se han aplicado los metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-176">The dependency property to which the metadata has been applied.</span></span></param>
        <param name="targetType"><span data-ttu-id="5842e-177">Tipo asociado a estos metadatos si se trata de metadatos específicos de tipo.</span><span class="sxs-lookup"><span data-stu-id="5842e-177">The type associated with this metadata if this is type-specific metadata.</span></span> <span data-ttu-id="5842e-178">Si éstos son los metadatos predeterminados, este valor es una referencia null.</span><span class="sxs-lookup"><span data-stu-id="5842e-178">If this is default metadata, this value is a null reference.</span></span></param>
        <summary><span data-ttu-id="5842e-179">Se le llama cuando los metadatos se han aplicado a una propiedad, que indica que se sellan los metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-179">Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-180">Las subclases deben asegurar que cualquier mutabilidad de la estructura de datos de un <xref:System.Windows.PropertyMetadata> subclase debe marcarse como inmutable una vez <xref:System.Windows.PropertyMetadata.OnApply%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="5842e-180">Subclasses should assure that any mutability of the data structure of a <xref:System.Windows.PropertyMetadata> subclass should be marked as immutable once <xref:System.Windows.PropertyMetadata.OnApply%2A> is called.</span></span> <span data-ttu-id="5842e-181">Se le llama una vez que los metadatos se aplican a una operación del sistema de propiedades (registrar, agregar propietario, invalidar metadatos).</span><span class="sxs-lookup"><span data-stu-id="5842e-181">This will be called once the metadata is applied to a property system operation (register, add owner, override metadata).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="5842e-182">Obtiene o establece una referencia a una implementación de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada en estos metadatos.</span><span class="sxs-lookup"><span data-stu-id="5842e-182">Gets or sets a reference to a <see cref="T:System.Windows.PropertyChangedCallback" /> implementation specified in this metadata.</span></span></summary>
        <value><span data-ttu-id="5842e-183">Referencia de implementación de <see cref="T:System.Windows.PropertyChangedCallback" />.</span><span class="sxs-lookup"><span data-stu-id="5842e-183">A <see cref="T:System.Windows.PropertyChangedCallback" /> implementation reference.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5842e-184">Las devoluciones de llamada en los metadatos de propiedad no son miembros públicos normalmente en el tipo de definición, por lo que el valor de esta propiedad no es importante para la mayoría de los escenarios que simplemente utilizan los metadatos de una propiedad de dependencia existente.</span><span class="sxs-lookup"><span data-stu-id="5842e-184">The callbacks in property metadata are not typically public members on the defining type, so the value of this property is not important for most scenarios that just consume an existing dependency property's metadata.</span></span> <span data-ttu-id="5842e-185">Una razón se expone esta propiedad es para que las clases de metadatos pueden realizar la lógica de combinación si se especifican metadatos base y metadatos de invalidación o agregando un <xref:System.Windows.PropertyChangedCallback>.</span><span class="sxs-lookup"><span data-stu-id="5842e-185">One reason this property is exposed is so that metadata classes can perform their desired merge logic if both base metadata and overriding/adding metadata specify a <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="5842e-186">La lógica de combinación predeterminada consiste en mantener todos los <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementaciones en una tabla y llamada de ellos, con las devoluciones de llamada establecidas por la clase más profunda en la jerarquía que se ejecuta primero.</span><span class="sxs-lookup"><span data-stu-id="5842e-186">The default merge logic for is to maintain all <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> implementations in a table and call each of them, with callbacks established by the deepest class in hierarchy running first.</span></span>  
  
 <span data-ttu-id="5842e-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se define en el modelo de objetos de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="5842e-187"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is defined in the object model as read-write.</span></span> <span data-ttu-id="5842e-188">Esto sucede así <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se pueden ajustar después de la inicialización de la <xref:System.Windows.PropertyMetadata> propio objeto.</span><span class="sxs-lookup"><span data-stu-id="5842e-188">This is so <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> can be adjusted after initialization of the <xref:System.Windows.PropertyMetadata> object itself.</span></span> <span data-ttu-id="5842e-189">Sin embargo, una vez que se consumen los metadatos como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y las propiedades se consideran inmutables.</span><span class="sxs-lookup"><span data-stu-id="5842e-189">However, once the metadata is consumed as part of a call to <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, the property system will seal that metadata instance and the properties are now considered immutable.</span></span> <span data-ttu-id="5842e-190">Se intentó establecer <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> una vez <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="5842e-190">Attempting to set <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> once <xref:System.Windows.PropertyMetadata.IsSealed%2A> is `true` on this metadata instance will raise an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="5842e-191">No se puede establecer una propiedad de metadatos una vez que se aplica a una operación de propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="5842e-191">Cannot set a metadata property once it is applied to a dependency property operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>