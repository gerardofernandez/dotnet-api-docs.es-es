<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a6c8f64cb523baf870330f4332b567df43a0e14" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57929418" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="765bf-101"><see cref="T:System.Windows.FrameworkContentElement" /> es la implementación de nivel de marco de WPF y la expansión de la clase base <see cref="T:System.Windows.ContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-101"><see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span></span> <span data-ttu-id="765bf-102"><see cref="T:System.Windows.FrameworkContentElement" /> agrega compatibilidad para las API de entrada adicionales (incluye información sobre herramientas y menús contextuales), guiones gráficos, el contexto de datos para el enlace de datos, la compatibilidad de estilos y las API del asistente del árbol lógico.</span><span class="sxs-lookup"><span data-stu-id="765bf-102"><see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-103"><xref:System.Windows.FrameworkContentElement> aún no define su propio comportamiento de representación; creación de instancias reales <xref:System.Windows.FrameworkContentElement> instancia de la clase en código o marcado es posible, pero no muestra nada en una [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicación [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="765bf-104">Lógica de representación debe proporcionarse mediante las clases que toman <xref:System.Windows.FrameworkContentElement> elementos secundarios como parte de su modelo de contenido, o en <xref:System.Windows.FrameworkContentElement> las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="765bf-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="765bf-105"><xref:System.Windows.FrameworkContentElement> muchos de los mismos es semejante deliberadamente [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] como <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="765bf-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="765bf-106">Tenga en cuenta que ciertos [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] se encuentra en <xref:System.Windows.FrameworkElement> no tendrán un <xref:System.Windows.FrameworkContentElement> equivalente.</span><span class="sxs-lookup"><span data-stu-id="765bf-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="765bf-107">Algunos de los <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] tienen funcionalidad como la representación de geometría o de diseño, que no son relevantes para un <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="765bf-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="765bf-108">La mayoría de los existentes <xref:System.Windows.FrameworkContentElement> las clases derivadas se encuentra en la <xref:System.Windows.Documents> espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="765bf-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="765bf-109">Muchas de estas clases derivadas implementan elementos para el modelo de documentos dinámicos.</span><span class="sxs-lookup"><span data-stu-id="765bf-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="765bf-110">Ciertas clases derivadas como <xref:System.Windows.Documents.Hyperlink> tiene algunas funcionalidades tipo control, pero se derivan <xref:System.Windows.FrameworkContentElement> tal que los elementos de tipo de control pueden participar en el modelo de documentos dinámicos.</span><span class="sxs-lookup"><span data-stu-id="765bf-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-111">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="765bf-112">Elemento secundario que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="765bf-112">The child element to be added.</span></span></param>
        <summary><span data-ttu-id="765bf-113">Agrega el elemento proporcionado como elemento secundario de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-113">Adds the provided element as a child of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-114">Este método puede producir una excepción si se llama a la vez cuando el árbol lógico es que se recorre en otro proceso.</span><span class="sxs-lookup"><span data-stu-id="765bf-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="765bf-115">La mayoría <xref:System.Windows.FrameworkContentElement> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <xref:System.Windows.Documents.Span.Inlines%2A> en el <xref:System.Windows.Documents.Span> clase; <xref:System.Windows.Documents.Section.Blocks%2A> en el <xref:System.Windows.Documents.Section> clase).</span><span class="sxs-lookup"><span data-stu-id="765bf-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="765bf-116">Normalmente, puede evitar cualquier necesidad de manipular directamente el árbol lógico si deriva de estas clases en su lugar.</span><span class="sxs-lookup"><span data-stu-id="765bf-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="765bf-117">Trabajar con el árbol lógico para elementos de contenido es un escenario avanzado que puede requerir un analizador especializado o un especializado <xref:System.Windows.FrameworkElement> que actúa como el elemento de representación primario (host de contenido).</span><span class="sxs-lookup"><span data-stu-id="765bf-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="765bf-118">Para obtener más información sobre cómo usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> y <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-119">Se llama antes de inicializar un elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-119">Called before an element is initialized.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="765bf-120">Invalide este método para proporcionar un control especial que debe producirse antes de que el elemento se inicializa durante el proceso de carga.</span><span class="sxs-lookup"><span data-stu-id="765bf-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span></span>  
  
<span data-ttu-id="765bf-121">La implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.</span><span class="sxs-lookup"><span data-stu-id="765bf-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
<span data-ttu-id="765bf-122">La implementación base producirá una excepción si <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> se llama más de una vez en el mismo elemento antes de llegar a <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="765bf-123">Empieza la secuencia de acciones contenidas en el guión gráfico proporcionado.</span><span class="sxs-lookup"><span data-stu-id="765bf-123">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="765bf-124">Guión gráfico que se va a iniciar.</span><span class="sxs-lookup"><span data-stu-id="765bf-124">The storyboard to begin.</span></span></param>
        <summary><span data-ttu-id="765bf-125">Empieza la secuencia de acciones contenidas en el guión gráfico proporcionado.</span><span class="sxs-lookup"><span data-stu-id="765bf-125">Begins the sequence of actions that are contained in the provided storyboard.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-126">Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno".</span><span class="sxs-lookup"><span data-stu-id="765bf-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="765bf-127">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</span><span class="sxs-lookup"><span data-stu-id="765bf-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="765bf-128">Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="765bf-129">Guión gráfico que se va a iniciar.</span><span class="sxs-lookup"><span data-stu-id="765bf-129">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="765bf-130">Valor de la enumeración que describe el comportamiento que se va a usar si ya está animada una propiedad descrita en el guión gráfico.</span><span class="sxs-lookup"><span data-stu-id="765bf-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span></span></param>
        <summary><span data-ttu-id="765bf-131">Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con opciones especificadas para lo que debería ocurrir si la propiedad ya está animada.</span><span class="sxs-lookup"><span data-stu-id="765bf-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-132">Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno".</span><span class="sxs-lookup"><span data-stu-id="765bf-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="765bf-133">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</span><span class="sxs-lookup"><span data-stu-id="765bf-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="765bf-134">Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="765bf-135">Mediante el campo Compose de HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="765bf-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="765bf-136">Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el uso de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de control de tiempo no no quita automáticamente los relojes.</span><span class="sxs-lookup"><span data-stu-id="765bf-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="765bf-137">Para evitar problemas de rendimiento cuando aplique muchos relojes mediante el uso de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado.</span><span class="sxs-lookup"><span data-stu-id="765bf-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="765bf-138">Hay varias formas de quitar un reloj:</span><span class="sxs-lookup"><span data-stu-id="765bf-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="765bf-139">Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado.</span><span class="sxs-lookup"><span data-stu-id="765bf-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="765bf-140">Especifique la propiedad animada como primer parámetro, y `null` como el segundo.</span><span class="sxs-lookup"><span data-stu-id="765bf-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="765bf-141">Esto quita todos los relojes de animación de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="765bf-142">Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="765bf-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="765bf-143">Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj.</span><span class="sxs-lookup"><span data-stu-id="765bf-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="765bf-144">Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`.</span><span class="sxs-lookup"><span data-stu-id="765bf-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="765bf-145">Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> evento no se produce si la duración efectiva del reloj es para siempre.</span><span class="sxs-lookup"><span data-stu-id="765bf-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="765bf-146">En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="765bf-147">Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.</span><span class="sxs-lookup"><span data-stu-id="765bf-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="765bf-148">Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.</span><span class="sxs-lookup"><span data-stu-id="765bf-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="765bf-149">Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard"><span data-ttu-id="765bf-150">Guión gráfico que se va a iniciar.</span><span class="sxs-lookup"><span data-stu-id="765bf-150">The storyboard to begin.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="765bf-151">Valor de la enumeración que describe el comportamiento que se va a usar si ya está animada una propiedad descrita en el guión gráfico.</span><span class="sxs-lookup"><span data-stu-id="765bf-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span></span></param>
        <param name="isControllable"><span data-ttu-id="765bf-152">Declara si la animación se puede controlar (se puede pausar) después de que se ha iniciado.</span><span class="sxs-lookup"><span data-stu-id="765bf-152">Declares whether the animation is controllable (can be paused) after it is started.</span></span></param>
        <summary><span data-ttu-id="765bf-153">Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con el estado especificado para el control de la animación una vez iniciado.</span><span class="sxs-lookup"><span data-stu-id="765bf-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-154">Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno".</span><span class="sxs-lookup"><span data-stu-id="765bf-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="765bf-155">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</span><span class="sxs-lookup"><span data-stu-id="765bf-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="765bf-156">Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="765bf-157">Mediante el campo Compose de HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="765bf-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="765bf-158">Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el uso de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de control de tiempo no no quita estos relojes automáticamente.</span><span class="sxs-lookup"><span data-stu-id="765bf-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="765bf-159">Para evitar problemas de rendimiento cuando aplique muchos relojes mediante el uso de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado.</span><span class="sxs-lookup"><span data-stu-id="765bf-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="765bf-160">Hay varias formas de quitar un reloj:</span><span class="sxs-lookup"><span data-stu-id="765bf-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="765bf-161">Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado.</span><span class="sxs-lookup"><span data-stu-id="765bf-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="765bf-162">Especifique la propiedad animada como primer parámetro, y `null` como el segundo.</span><span class="sxs-lookup"><span data-stu-id="765bf-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="765bf-163">Esto quita todos los relojes de animación de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="765bf-164">Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="765bf-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="765bf-165">Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj.</span><span class="sxs-lookup"><span data-stu-id="765bf-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="765bf-166">Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`.</span><span class="sxs-lookup"><span data-stu-id="765bf-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="765bf-167">Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> evento no se produce si la duración efectiva del reloj es para siempre.</span><span class="sxs-lookup"><span data-stu-id="765bf-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="765bf-168">En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="765bf-169">Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.</span><span class="sxs-lookup"><span data-stu-id="765bf-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="765bf-170">Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.</span><span class="sxs-lookup"><span data-stu-id="765bf-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="765bf-171">Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-172">Obtiene o establece el <see cref="T:System.Windows.Data.BindingGroup" /> que se usa para el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></summary>
        <value><span data-ttu-id="765bf-173">Objeto <see cref="T:System.Windows.Data.BindingGroup" /> que se usa para el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-174">Un <xref:System.Windows.Data.BindingGroup> puede usarse para validar los valores de varias propiedades de un objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="765bf-175">Por ejemplo, suponga que una aplicación solicita al usuario que escriba una dirección y, a continuación, rellena un objeto de tipo `Address`, que tiene las propiedades `Street`, `City`, `ZipCode`, y `Country`, con los valores que el usuario proporcionado.</span><span class="sxs-lookup"><span data-stu-id="765bf-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="765bf-176">La aplicación tiene un panel que contiene cuatro <xref:System.Windows.Controls.TextBox> controles, cada uno de los cuales está enlazado a una de las propiedades del objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object's properties.</span></span> <span data-ttu-id="765bf-177">Puede usar un <xref:System.Windows.Controls.ValidationRule> en un <xref:System.Windows.Data.BindingGroup> para validar la `Address` objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="765bf-178">Por ejemplo, el <xref:System.Windows.Controls.ValidationRule> puede asegurarse de que el código postal es válido para el país de la dirección.</span><span class="sxs-lookup"><span data-stu-id="765bf-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="765bf-179">Los elementos secundarios heredan la <xref:System.Windows.Data.BindingGroup> de sus elementos primarios, al igual que con cualquier otra propiedad heredable.</span><span class="sxs-lookup"><span data-stu-id="765bf-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-180">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-181">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="765bf-182">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-182">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-183">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-184">Intenta mostrar este elemento, en cualquier región desplazable que lo contenga.</span><span class="sxs-lookup"><span data-stu-id="765bf-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-185">Al llamar a este método, de hecho a <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> en cualquier área desplazable primaria que contiene el elemento (el elemento primario puede ser muy bien un <xref:System.Windows.FrameworkElement>, no un <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="765bf-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="765bf-186">Si este elemento no está contenida en un área desplazable, todavía se provoca el evento, pero no habrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="765bf-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)"><span data-ttu-id="765bf-187">Procedimiento Crear un control ScrollViewer</span><span class="sxs-lookup"><span data-stu-id="765bf-187">How to: Create a ScrollViewer</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-188">Obtiene o establece el elemento de menú contextual que debería aparecer cuando se solicite el menú contextual a través de la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] desde este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span></span></summary>
        <value><span data-ttu-id="765bf-189">Menú contextual que este elemento utiliza.</span><span class="sxs-lookup"><span data-stu-id="765bf-189">The context menu that this element uses.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-190">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-191">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="765bf-192">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-193">None</span><span class="sxs-lookup"><span data-stu-id="765bf-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-194">Los siguientes lugares de ejemplo una <xref:System.Windows.Controls.ContextMenu> en un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="765bf-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-195">Se produce inmediatamente antes de que se cierre cualquier menú contextual en el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-195">Occurs just before any context menu on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-196">Para suprimir el cierre menús contextuales, los controladores del evento deben marcará como controlado.</span><span class="sxs-lookup"><span data-stu-id="765bf-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="765bf-197">Para usar este evento como un <xref:System.Windows.EventTrigger> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:</span><span class="sxs-lookup"><span data-stu-id="765bf-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="765bf-198">(Este uso es necesario porque la implementación de eventos en <xref:System.Windows.FrameworkContentElement> que expone el evento de servicio subyacente no asigna correctamente el <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificador para su uso en desencadenadores).</span><span class="sxs-lookup"><span data-stu-id="765bf-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-199">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-200">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="765bf-201">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-201">Routing strategy</span></span>|<span data-ttu-id="765bf-202">Propagación</span><span class="sxs-lookup"><span data-stu-id="765bf-202">Bubbling</span></span>|  
|<span data-ttu-id="765bf-203">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-204">El ejemplo siguiente implementa un controlador que cambia el cursor sobre una región con nombre `DisplayArea` (no mostrado).</span><span class="sxs-lookup"><span data-stu-id="765bf-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="765bf-205">El comentario de forma sugerente un <xref:System.Windows.UIElement> uso, pero en realidad en este ejemplo sería idéntico si `DisplayArea` eran un <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="765bf-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-206">Identifica la <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-207">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-208">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-209">Se produce cuando se abre cualquier menú contextual en el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-209">Occurs when any context menu on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-210">Para abrir manualmente los menús contextuales, controladores de los eventos deben marcar el evento pertinente como controlado.</span><span class="sxs-lookup"><span data-stu-id="765bf-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="765bf-211">En caso contrario, el valor existente de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propiedad se usará para abrir automáticamente un menú contextual.</span><span class="sxs-lookup"><span data-stu-id="765bf-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="765bf-212">Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propiedad y, a continuación, abra el nuevo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="765bf-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="765bf-213">Sin embargo, hay un problema de tiempo que debe tener en cuenta.</span><span class="sxs-lookup"><span data-stu-id="765bf-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="765bf-214">Para reemplazar completamente el menú contextual a través de un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> controlador, el menú contextual inicial no debe ser null o están vacías.</span><span class="sxs-lookup"><span data-stu-id="765bf-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="765bf-215">Como alternativa, deberá controlar el evento y, a continuación, abra manualmente un nuevo menú contextual.</span><span class="sxs-lookup"><span data-stu-id="765bf-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="765bf-216">Para obtener más detalles, vea [Cómo: Controlar el evento ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-216">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="765bf-217">Para usar este evento como un <xref:System.Windows.EventTrigger> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:</span><span class="sxs-lookup"><span data-stu-id="765bf-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="765bf-218">(Este uso es necesario porque la implementación de eventos en <xref:System.Windows.FrameworkContentElement> que expone el evento de servicio subyacente no asigna correctamente el <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificador para su uso en desencadenadores).</span><span class="sxs-lookup"><span data-stu-id="765bf-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-219">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-220">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="765bf-221">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-221">Routing strategy</span></span>|<span data-ttu-id="765bf-222">Propagación</span><span class="sxs-lookup"><span data-stu-id="765bf-222">Bubbling</span></span>|  
|<span data-ttu-id="765bf-223">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-224">Identifica la <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-225">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-226">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-227">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-228">Obtiene o establece el cursor que aparecerá cuando el puntero del mouse se encuentre sobre este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span></span></summary>
        <value><span data-ttu-id="765bf-229">Cursor que se va a mostrar.</span><span class="sxs-lookup"><span data-stu-id="765bf-229">The cursor to display.</span></span> <span data-ttu-id="765bf-230">El valor predeterminado se define como <see langword="null" /> por esta propiedad de dependencia.</span><span class="sxs-lookup"><span data-stu-id="765bf-230">The default value is defined as <see langword="null" /> per this dependency property.</span></span> <span data-ttu-id="765bf-231">Sin embargo, el valor predeterminado en la práctica en tiempo de ejecución depende de diversos factores.</span><span class="sxs-lookup"><span data-stu-id="765bf-231">However, the practical default at run time will come from a variety of factors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-232">Al establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesador se basa en la conversión de tipos para el <xref:System.Windows.Input.Cursor> clase para evaluar la cadena.</span><span class="sxs-lookup"><span data-stu-id="765bf-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="765bf-233">La cadena proporcionada se debe evaluar como un <xref:System.Windows.Input.CursorType> valor.</span><span class="sxs-lookup"><span data-stu-id="765bf-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="765bf-234">Para obtener información más detallada, vea <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="765bf-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="765bf-235">Si el cursor según lo establecido por esta propiedad se o no se mostrará cuando el puntero del mouse está sobre este elemento también es dependiente del valor de la <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="765bf-236">Además, las consideraciones relacionadas con eventos como un arrastre activo, la captura del mouse, modos dentro de los controles etc., de edición de texto también afectará el cursor con prioridad más alta que el valor especificado en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="765bf-237">Para revertir el comportamiento de establecer esta propiedad en el valor predeterminado eventual, establézcalo en `null` nuevo.</span><span class="sxs-lookup"><span data-stu-id="765bf-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="765bf-238">El `null` predeterminado realmente significa que determinación del valor de cursor viable se aplaza aquí y debe obtenerse desde cualquier parte.</span><span class="sxs-lookup"><span data-stu-id="765bf-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="765bf-239">Si aparece sin valores de cualquier origen, el cursor predeterminado mediante programación a través de un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplicación será una flecha.</span><span class="sxs-lookup"><span data-stu-id="765bf-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="765bf-240">Cada movimiento del mouse sobre un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicación genera un <xref:System.Windows.ContentElement.QueryCursor> eventos.</span><span class="sxs-lookup"><span data-stu-id="765bf-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="765bf-241">El evento se propaga y cualquier elemento en la ruta tiene la oportunidad de controlar el evento y establecer el valor del cursor a través de los argumentos de este evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="765bf-242">Si esto sucede, el hecho de que el evento se controla y tiene un valor modificado en los argumentos tiene prioridad sobre el valor de la <xref:System.Windows.FrameworkContentElement.Cursor%2A> propiedad en cualquier nivel, a menos que <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> está establecido.</span><span class="sxs-lookup"><span data-stu-id="765bf-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="765bf-243">Si no crea un cursor personalizado, normalmente se establece esta propiedad en un valor de propiedad estática de la <xref:System.Windows.Input.Cursors> clase.</span><span class="sxs-lookup"><span data-stu-id="765bf-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="765bf-244">Establecer el <xref:System.Windows.Input.Cursor> en un valor personalizado no está habilitado en confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="765bf-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="765bf-245">Para obtener más información sobre los cursores personalizados, vea [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-245">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-246">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-247">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="765bf-248">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-249">None</span><span class="sxs-lookup"><span data-stu-id="765bf-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-250">El ejemplo siguiente establece el cursor en un valor personalizado.</span><span class="sxs-lookup"><span data-stu-id="765bf-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-251">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-252">Obtiene o establece el contexto de datos para un elemento cuando participa en un enlace de datos.</span><span class="sxs-lookup"><span data-stu-id="765bf-252">Gets or sets the data context for an element when it participates in data binding.</span></span></summary>
        <value><span data-ttu-id="765bf-253">Objeto que se va a usar como contexto de datos.</span><span class="sxs-lookup"><span data-stu-id="765bf-253">The object to use as data context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-254">*Contexto de datos* es un concepto que permite que los elementos heredar información de sus elementos primarios sobre el origen de enlace que se usa para el enlace, así como otras características del enlace, como la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="765bf-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="765bf-255">Contexto de datos se puede establecer directamente en un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objeto, con los enlaces que se evalúe como propiedades de ese objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="765bf-256">Como alternativa, puede establecer el contexto de datos en un <xref:System.Windows.Data.DataSourceProvider> objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="765bf-257">Esta propiedad de dependencia hereda los valores de propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-257">This dependency property inherits property values.</span></span> <span data-ttu-id="765bf-258">Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkContentElement.DataContext%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkContentElement.DataContext%2A> valor del elemento primario más cercano con este valor asignado.</span><span class="sxs-lookup"><span data-stu-id="765bf-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="765bf-259">Como alternativa, puede usar una de las siguientes propiedades de la <xref:System.Windows.Data.Binding> clase para especificar explícitamente el origen de enlace: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, o <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="765bf-260">Para obtener más información, vea [Cómo: Especifique el origen de enlace](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-260">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="765bf-261">En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> con más frecuencia se establece como un <xref:System.Windows.Data.Binding> declaración.</span><span class="sxs-lookup"><span data-stu-id="765bf-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="765bf-262">Puede usar la sintaxis de elemento de propiedad o la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="765bf-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="765bf-263">Sintaxis de atributo se muestra en el ejemplo de esta página.</span><span class="sxs-lookup"><span data-stu-id="765bf-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="765bf-264">También puede establecer <xref:System.Windows.FrameworkContentElement.DataContext%2A> en el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="765bf-265">Uso de elementos de propiedad XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-266">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-266">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-267">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-267">XAML Values</span></span>  
 <span data-ttu-id="765bf-268">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="765bf-268">*dataContextObject*</span></span>  
 <span data-ttu-id="765bf-269">Un objeto directamente incrustado que actúa como contexto de datos para todos los enlaces dentro del elemento primario.</span><span class="sxs-lookup"><span data-stu-id="765bf-269">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="765bf-270">Normalmente, este objeto es un <xref:System.Windows.Data.Binding> u otro <xref:System.Windows.Data.BindingBase> subclase.</span><span class="sxs-lookup"><span data-stu-id="765bf-270">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="765bf-271">Como alternativa, los datos sin procesar de cualquier [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] diseñado para el enlace se puede colocar aquí, con los enlaces reales definidos después del tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-271">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="765bf-272">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="765bf-272">*bindingUsage*</span></span>  
 <span data-ttu-id="765bf-273">Uso de enlace que se evalúa como un contexto de datos adecuado.</span><span class="sxs-lookup"><span data-stu-id="765bf-273">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="765bf-274">Para obtener más información, consulte [Binding (extensión de marcado)](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-274">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="765bf-275">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="765bf-275">*resourceExtension*</span></span>  
 <span data-ttu-id="765bf-276">Uno de los siguientes: `StaticResource`, o `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="765bf-276">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="765bf-277">Esto se usa cuando se hace referencia a datos sin procesar que se define como un objeto en los recursos.</span><span class="sxs-lookup"><span data-stu-id="765bf-277">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="765bf-278">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-278">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="765bf-279">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="765bf-279">*contextResourceKey*</span></span>  
 <span data-ttu-id="765bf-280">El identificador de clave para el objeto que se solicita desde un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-280">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-281">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-281">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-282">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-282">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="765bf-283">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-283">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-284">En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo objeto de datos personalizado, Establece el objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>y establecer la ruta de acceso de enlace a una propiedad dentro de él.</span><span class="sxs-lookup"><span data-stu-id="765bf-284">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-285">Se produce cuando cambia el contexto de datos de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-285">Occurs when this element's data context changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-286">Para obtener una explicación de los contextos de datos y el enlace de datos, vea [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-286">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="765bf-287">Cuando un elemento <xref:System.Windows.FrameworkContentElement.DataContext%2A> cambios, todas las propiedades enlazadas a datos de este elemento podrían verse afectados.</span><span class="sxs-lookup"><span data-stu-id="765bf-287">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="765bf-288">Esto se aplica a los elementos que son descendientes del elemento actual, que heredan el contexto de datos, y también el propio elemento actual.</span><span class="sxs-lookup"><span data-stu-id="765bf-288">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="765bf-289">Todos los enlaces de este tipo, volver a interpretan el nuevo <xref:System.Windows.FrameworkContentElement.DataContext%2A> para reflejar el nuevo valor en los enlaces.</span><span class="sxs-lookup"><span data-stu-id="765bf-289">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="765bf-290">No hay ninguna garantía sobre el orden de estos cambios con respecto a la generación de la <xref:System.Windows.FrameworkContentElement.DataContextChanged> eventos.</span><span class="sxs-lookup"><span data-stu-id="765bf-290">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="765bf-291">Los cambios pueden producir antes del evento, después del evento, o ambos.</span><span class="sxs-lookup"><span data-stu-id="765bf-291">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-292">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-292">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-293">Obtiene o establece la clave que se debe usar para buscar la plantilla de estilo de este control en los temas.</span><span class="sxs-lookup"><span data-stu-id="765bf-293">Gets or sets the key to use to find the style template for this control in themes.</span></span></summary>
        <value><span data-ttu-id="765bf-294">La clave de estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-294">The style key.</span></span> <span data-ttu-id="765bf-295">Se espera que este valor sea la clase <see cref="T:System.Type" /> del elemento cuyo estilo se está creando para que funcione correctamente como parte de la búsqueda de estilo de tema.</span><span class="sxs-lookup"><span data-stu-id="765bf-295">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span></span> <span data-ttu-id="765bf-296"><see langword="null" /> es un valor aceptado para un caso determinado.</span><span class="sxs-lookup"><span data-stu-id="765bf-296"><see langword="null" /> is an accepted value for a certain case.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-297">Esta propiedad no se establece normalmente a través de cualquiera de sus establecedores directos.</span><span class="sxs-lookup"><span data-stu-id="765bf-297">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="765bf-298">En su lugar, invalida los metadatos específicos del tipo de esta propiedad de dependencia cada vez que crea una nueva subclase.</span><span class="sxs-lookup"><span data-stu-id="765bf-298">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="765bf-299">Cuando se subclase, llame a la <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método con el <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificador dentro del constructor estático de la subclase de control.</span><span class="sxs-lookup"><span data-stu-id="765bf-299">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="765bf-300">Por ejemplo, una clase insertada como <xref:System.Windows.Documents.Bold> realmente no tiene una implementación muy poco más allá de reemplazar el <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadatos en su constructor estático y exponer varios constructores de instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-300">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="765bf-301">El hecho de que los elementos rodeados por el <xref:System.Windows.Documents.Bold> etiqueta ganancia un <xref:System.Windows.Documents.TextElement.FontWeight%2A> propiedad de <xref:System.Windows.FontWeights.Bold%2A> se implementa dentro del estilo de tema que se hizo referencia estableciendo el valor predeterminado de <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> a `typeof(Bold)`.</span><span class="sxs-lookup"><span data-stu-id="765bf-301">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="765bf-302">Si desea que el elemento o el control no use deliberadamente estilos de tema, establezca el <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> propiedad `true`.</span><span class="sxs-lookup"><span data-stu-id="765bf-302">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-303">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-303">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-304">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-304">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="765bf-305">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-305">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-306">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-306">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-307">Se llama inmediatamente después de que se inicialice un elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-307">Called immediately after an element is initialized.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-308">Implemente este método para proporcionar un control especial que debe producirse cuando el elemento se inicializa durante el proceso de carga.</span><span class="sxs-lookup"><span data-stu-id="765bf-308">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="765bf-309">La implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.</span><span class="sxs-lookup"><span data-stu-id="765bf-309">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="765bf-310">Si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> se llamaba anteriormente, la base de implementación, se producirá la <xref:System.Windows.FrameworkContentElement.Initialized> eventos.</span><span class="sxs-lookup"><span data-stu-id="765bf-310">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="765bf-311">En caso contrario, si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> no se llamó al o no se pudo determinar si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> era llama, el evento no se genera.</span><span class="sxs-lookup"><span data-stu-id="765bf-311">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="765bf-312">Nombre del elemento que se va a buscar.</span><span class="sxs-lookup"><span data-stu-id="765bf-312">Name of the element to search for.</span></span></param>
        <summary><span data-ttu-id="765bf-313">Busca un elemento que tiene el nombre de identificador proporcionado.</span><span class="sxs-lookup"><span data-stu-id="765bf-313">Finds an element that has the provided identifier name.</span></span></summary>
        <returns><span data-ttu-id="765bf-314">Elemento solicitado.</span><span class="sxs-lookup"><span data-stu-id="765bf-314">The requested element.</span></span> <span data-ttu-id="765bf-315">Puede ser <see langword="null" /> si no se encontró ningún elemento coincidente.</span><span class="sxs-lookup"><span data-stu-id="765bf-315">May be <see langword="null" /> if no matching element was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-316">Si este elemento tiene elementos secundarios, estos elementos secundarios son todos buscada de forma recursiva el elemento con nombre solicitado.</span><span class="sxs-lookup"><span data-stu-id="765bf-316">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-317">En el ejemplo siguiente se establece una propiedad en un elemento se encuentra por nombre dentro de una referencia <xref:System.Windows.Documents.FlowDocument> en una página.</span><span class="sxs-lookup"><span data-stu-id="765bf-317">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="765bf-318">Identificador de clave del recurso que se debe encontrar.</span><span class="sxs-lookup"><span data-stu-id="765bf-318">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="765bf-319">Busca un recurso con la clave especificada e inicia una excepción si no se encuentra el recurso solicitado.</span><span class="sxs-lookup"><span data-stu-id="765bf-319">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span></span></summary>
        <returns><span data-ttu-id="765bf-320">Recurso encontrado, o <see langword="null" /> si no se encontró ningún recurso coincidente (pero también se iniciará una excepción si <see langword="null" />).</span><span class="sxs-lookup"><span data-stu-id="765bf-320">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="765bf-321">Si se llama a este método para una clave que no se encuentra, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="765bf-321">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="765bf-322">Si no desea controlar las excepciones para este caso, debe llamar en su lugar <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-322">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="765bf-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Devuelve `null` cuando se encuentra ningún recurso y no produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="765bf-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="765bf-324">Si no se encuentra el recurso en el elemento que realiza la llamada, se busca en el árbol primario mediante el árbol lógico, de la misma manera que sería el árbol se solicitaron si busca un recurso por clave en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="765bf-324">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="765bf-325">Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.</span><span class="sxs-lookup"><span data-stu-id="765bf-325">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-326">El ejemplo siguiente busca un recurso, tal como se define en el marcado y aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-326">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><span data-ttu-id="765bf-327">No se encontró la clave de recurso solicitada.</span><span class="sxs-lookup"><span data-stu-id="765bf-327">The requested resource key was not found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="765bf-328"><paramref name="resourceKey" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-328"><paramref name="resourceKey" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-329">Obtiene o establece un objeto que habilita la personalización de apariencia, efectos u otras características de estilo que se aplicarán a este elemento cuando capture el foco del teclado.</span><span class="sxs-lookup"><span data-stu-id="765bf-329">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span></span></summary>
        <value><span data-ttu-id="765bf-330">Estilo deseado que se aplicará en el foco.</span><span class="sxs-lookup"><span data-stu-id="765bf-330">The desired style to apply on focus.</span></span> <span data-ttu-id="765bf-331">El valor predeterminado declarado en la propiedad de dependencia es un elemento <see cref="T:System.Windows.Style" /> vacío estático.</span><span class="sxs-lookup"><span data-stu-id="765bf-331">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span></span> <span data-ttu-id="765bf-332">Sin embargo, el valor efectivo en tiempo de ejecución suele ser (aunque no siempre) un estilo que la compatibilidad de tema proporciona para los controles.</span><span class="sxs-lookup"><span data-stu-id="765bf-332">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-333">Al establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]estilos casi siempre se definen como un recurso, en lugar de en línea como un elemento y que suele recurso al que hace referencia como un <xref:System.Windows.StaticResourceExtension>.</span><span class="sxs-lookup"><span data-stu-id="765bf-333">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="765bf-334">Tenga en cuenta que esta propiedad afecta a la apariencia visual, pero no lo notifica en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="765bf-334">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="765bf-335">Esto es porque el cambio de apariencia visual está controlada por eventos y no se puede aplicar en todo momento y, por tanto, no debe notificar generalmente de cualquier información visual o de diseño en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="765bf-335">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="765bf-336">Conceptualmente, el comportamiento visual de foco aplicado a un control debe ser coherente desde un elemento a otro.</span><span class="sxs-lookup"><span data-stu-id="765bf-336">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="765bf-337">La manera más conveniente para exigir la coherencia es cambiar sólo el estilo visual de foco si se está creando un tema completo.</span><span class="sxs-lookup"><span data-stu-id="765bf-337">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="765bf-338">Establecer esta propiedad en estilos individuales y no como parte de un tema no es el uso previsto de esta propiedad, porque puede llevar a una experiencia de usuario confusa con respecto al foco de teclado.</span><span class="sxs-lookup"><span data-stu-id="765bf-338">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="765bf-339">Si desea un comportamiento específico del elemento que deliberadamente no sea coherente en un tema, un enfoque mucho mejor es usar desencadenadores en estilos para las propiedades de estado de entrada individuales, como <xref:System.Windows.UIElement.IsFocused%2A> o <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>y hacerlo de manera que no lo hace visualmente, interferir con cualquier estilo visual de foco existente.</span><span class="sxs-lookup"><span data-stu-id="765bf-339">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="765bf-340">Para obtener más información sobre la intención de diseño <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> y alternativas centrarse en las propiedades, vea [aplicar estilo a controles y FocusVisualStyle foco](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-340">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-341">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-341">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="765bf-342">Uso de elementos de propiedad XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-342">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-343">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-343">XAML Values</span></span>  
 <span data-ttu-id="765bf-344">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="765bf-344">*resourceExtension*</span></span>  
 <span data-ttu-id="765bf-345">Uno de los siguientes:, o.</span><span class="sxs-lookup"><span data-stu-id="765bf-345">One of the following: , or .</span></span> <span data-ttu-id="765bf-346">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-346">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="765bf-347">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="765bf-347">*styleResourceKey*</span></span>  
 <span data-ttu-id="765bf-348">La clave que identifica el estilo que se solicita.</span><span class="sxs-lookup"><span data-stu-id="765bf-348">The key that identifies the style being requested.</span></span> <span data-ttu-id="765bf-349">La clave hace referencia a un recurso existente en un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-349">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="765bf-350">Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="765bf-350">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="765bf-351">Consulte [plantillas y estilos alineados](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-351">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="765bf-352">Una referencia de enlace mediante o <xref:System.Windows.Data.Binding> también es posible, pero es poco común.</span><span class="sxs-lookup"><span data-stu-id="765bf-352">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-353">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-353">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-354">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-354">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="765bf-355">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-355">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-356">None</span><span class="sxs-lookup"><span data-stu-id="765bf-356">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-357">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-357">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-358">Obtiene o establece un valor que indica si <see cref="T:System.Windows.FrameworkContentElement" /> debe forzar que la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] represente el cursor declarado por la propiedad <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-358">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span></span></summary>
        <value><span data-ttu-id="765bf-359"><see langword="true" /> para forzar la presentación del cursor mientras está sobre este elemento con el fin de usar la configuración de esta instancia para el cursor (incluso en todos los elementos secundarios); de lo contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-359"><see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span></span> <span data-ttu-id="765bf-360">El valor predeterminado es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-360">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-361">Establecer esta propiedad en `true` invalidará las preferencias del cursor establecidas por los elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="765bf-361">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="765bf-362">Al hacerlo así que en general aplicación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] puede resultar confuso para el usuario, especialmente si los elementos secundarios se intentan especificar cursores.</span><span class="sxs-lookup"><span data-stu-id="765bf-362">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="765bf-363">Establecer <xref:System.Windows.FrameworkElement.ForceCursor%2A> es más adecuado en escenarios de composición o de creación de subclases de control.</span><span class="sxs-lookup"><span data-stu-id="765bf-363">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-364">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-364">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-365">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-365">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="765bf-366">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-366">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-367">None</span><span class="sxs-lookup"><span data-stu-id="765bf-367">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-368">El ejemplo siguiente fuerza el cursor mientras está sobre el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-368">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-369">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-369">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="765bf-370">Objeto <see cref="T:System.Windows.DependencyProperty" /> de destino del que se obtiene el enlace.</span><span class="sxs-lookup"><span data-stu-id="765bf-370">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span></span></param>
        <summary><span data-ttu-id="765bf-371">Obtiene el objeto <see cref="T:System.Windows.Data.BindingExpression" /> para el enlace de la propiedad especificada.</span><span class="sxs-lookup"><span data-stu-id="765bf-371">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span></span></summary>
        <returns><span data-ttu-id="765bf-372">Devuelve <see cref="T:System.Windows.Data.BindingExpression" /> si el destino son los datos enlazados; de lo contrario, devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-372">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="765bf-373">El ejemplo siguiente recupera un enlace consultando una propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-373">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-374">Devuelve a un elemento primario lógico alternativo para este elemento si no hay ningún elemento primario visual.</span><span class="sxs-lookup"><span data-stu-id="765bf-374">Returns an alternative logical parent for this element if there is no visual parent.</span></span> <span data-ttu-id="765bf-375">En este caso, un elemento primario <see cref="T:System.Windows.FrameworkContentElement" /> tiene siempre el mismo valor que la propiedad <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-375">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span></span></summary>
        <returns><span data-ttu-id="765bf-376">Devuelve un valor distinto de <see langword="null" /> cada vez que una implementación de nivel de marco de WPF de este método tiene una conexión de elemento primario no visual.</span><span class="sxs-lookup"><span data-stu-id="765bf-376">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-377">La implementación predeterminada devuelve al esperado único elemento primario visual.</span><span class="sxs-lookup"><span data-stu-id="765bf-377">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="765bf-378">Las implementaciones personalizadas podrían devolver relaciones primarias alternativas.</span><span class="sxs-lookup"><span data-stu-id="765bf-378">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-379">Se produce cuando se inicializa <see cref="T:System.Windows.FrameworkContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-379">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span></span> <span data-ttu-id="765bf-380">Este evento coincide con los casos donde el valor de la propiedad <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> cambia de <see langword="false" /> (o no definida) a <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-380">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-381">Será este evento se provoca cuando la <xref:System.Windows.FrameworkContentElement.EndInit%2A> o <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> se llama a métodos.</span><span class="sxs-lookup"><span data-stu-id="765bf-381">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="765bf-382">Las llamadas a estos métodos podrían haber realizado mediante código intencional o a través del [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proceso de carga.</span><span class="sxs-lookup"><span data-stu-id="765bf-382">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-383">Obtiene o establece el contexto de la entrada usada por este elemento <see cref="T:System.Windows.FrameworkContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-383">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <value><span data-ttu-id="765bf-384">Ámbito de entrada, que modifica cómo se interpreta la entrada desde métodos de entrada alternativos.</span><span class="sxs-lookup"><span data-stu-id="765bf-384">The input scope, which modifies how input from alternative input methods is interpreted.</span></span> <span data-ttu-id="765bf-385">El valor predeterminado es <see langword="null" /> (que da como resultado el control predeterminado de comandos).</span><span class="sxs-lookup"><span data-stu-id="765bf-385">The default value is <see langword="null" /> (which results in a default handling of commands).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-386">Esta propiedad de dependencia hereda los valores de propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-386">This dependency property inherits property values.</span></span> <span data-ttu-id="765bf-387">Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkElement.InputScope%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkElement.InputScope%2A> valor del elemento primario más cercano con este valor asignado.</span><span class="sxs-lookup"><span data-stu-id="765bf-387">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="765bf-388">Aunque un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] el uso de sintaxis se muestra y se permite sintácticamente, establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] no es habitual.</span><span class="sxs-lookup"><span data-stu-id="765bf-388">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-389">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-389">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-390">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-390">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="765bf-391">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-391">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-392">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-392">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-393">Obtiene un valor que indica si se ha inicializado este elemento, ya sea porque se ha cargado como [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] o porque se ha llamado explícitamente a su método <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-393">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span></span></summary>
        <value><span data-ttu-id="765bf-394"><see langword="true" /> si las llamadas al método o la carga mencionados anteriormente inicializan el elemento; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-394"><see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-395">Esta propiedad también puede ser `true` si este elemento se ha movido dentro del árbol de elementos que tiene un nuevo elemento primario y, por lo tanto, se carga de nuevo.</span><span class="sxs-lookup"><span data-stu-id="765bf-395">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-396">Obtiene un valor que indica si este elemento se ha cargado para la presentación.</span><span class="sxs-lookup"><span data-stu-id="765bf-396">Gets a value indicating whether this element has been loaded for presentation.</span></span></summary>
        <value><span data-ttu-id="765bf-397"><see langword="true" /> si el elemento actual está asociado a un árbol de elementos y se ha representado; <see langword="false" /> si el elemento nunca se ha asociado a un árbol de elementos cargado.</span><span class="sxs-lookup"><span data-stu-id="765bf-397"><see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-398">Desde una instancia recién creada, esta propiedad comienza `false`y sigue siendo `true` una vez que se establece en `true`, incluso si quita posteriormente mediante código.</span><span class="sxs-lookup"><span data-stu-id="765bf-398">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-399">El código de ejemplo siguiente usa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> como una comprobación condicional para garantizar que una función `displayData` elementos válidos (no mostrado) habrá cargado en la página que funciona, como parte de un controlador y a petición.</span><span class="sxs-lookup"><span data-stu-id="765bf-399">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="765bf-400">Que la misma lógica se ejecuta como un controlador de eventos <xref:System.Windows.FrameworkContentElement.Loaded>.</span><span class="sxs-lookup"><span data-stu-id="765bf-400">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-401">Obtiene o establece la información del idioma de localización o globalización que se aplica a un elemento individual.</span><span class="sxs-lookup"><span data-stu-id="765bf-401">Gets or sets localization/globalization language information that applies to an individual element.</span></span></summary>
        <value><span data-ttu-id="765bf-402">Información de la referencia cultural de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-402">The culture information for this element.</span></span> <span data-ttu-id="765bf-403">El valor predeterminado es una instancia <see cref="T:System.Windows.Markup.XmlLanguage" /> con su valor <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> establecido en la cadena "en-US".</span><span class="sxs-lookup"><span data-stu-id="765bf-403">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-404">Los formatos de cadena siguen el estándar RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="765bf-404">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="765bf-405">Por ejemplo, EE. UU. Inglés es "en-US".</span><span class="sxs-lookup"><span data-stu-id="765bf-405">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="765bf-406">Consulte <xref:System.Windows.Markup.XmlLanguage> para obtener más información sobre los valores y formato.</span><span class="sxs-lookup"><span data-stu-id="765bf-406">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="765bf-407">Esta propiedad de dependencia hereda los valores de propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-407">This dependency property inherits property values.</span></span> <span data-ttu-id="765bf-408">Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkElement.Language%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkElement.Language%2A> valor del elemento primario más cercano con este valor asignado.</span><span class="sxs-lookup"><span data-stu-id="765bf-408">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-409">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-409">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-410">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-410">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="765bf-411">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-411">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-412">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Language" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-412">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-413">Se produce cuando el elemento se presenta, se representa y está listo para la interacción.</span><span class="sxs-lookup"><span data-stu-id="765bf-413">Occurs when the element is laid out, rendered, and ready for interaction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-414">Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan.</span><span class="sxs-lookup"><span data-stu-id="765bf-414">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="765bf-415">Dirigir los eventos enrutados admiten otro comportamiento del evento enrutado: admiten una colección de controladores accesible y puede usarse como un <xref:System.Windows.EventTrigger> en un estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-415">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-416">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-417">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-417">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="765bf-418">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-418">Routing strategy</span></span>|<span data-ttu-id="765bf-419">Directa</span><span class="sxs-lookup"><span data-stu-id="765bf-419">Direct</span></span>|  
|<span data-ttu-id="765bf-420">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-420">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-421">Identifica la <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-421">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-422">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-422">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-423">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-423">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-424">Obtiene un enumerador para los elementos secundarios lógicos de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-424">Gets an enumerator for the logical child elements of this element.</span></span></summary>
        <value><span data-ttu-id="765bf-425">Enumerador para los elementos secundarios lógicos de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-425">An enumerator for logical child elements of this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-426">Para obtener más información sobre cómo usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> y <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-426">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="765bf-427">Dirección en la que se mueve el foco, como valor de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="765bf-427">The direction that focus is to be moved, as a value of the enumeration.</span></span></param>
        <summary><span data-ttu-id="765bf-428">Mueve el foco del teclado de este elemento a otro elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-428">Moves the keyboard focus from this element to another element.</span></span></summary>
        <returns><span data-ttu-id="765bf-429">Devuelve <see langword="true" /> si se mueve el foco correctamente; <see langword="false" /> si el elemento de destino no existe en la dirección especificada.</span><span class="sxs-lookup"><span data-stu-id="765bf-429">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-430">Obtiene o establece el nombre de identificación del elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-430">Gets or sets the identifying name of the element.</span></span> <span data-ttu-id="765bf-431">El nombre proporciona una referencia de instancia para que el código subyacente de programación, como el código del controlador de eventos, puede hacer referencia a un elemento una vez construido durante el análisis de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-431">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span></summary>
        <value><span data-ttu-id="765bf-432">Nombre del elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-432">The name of the element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-433">El uso más común de esta propiedad es al especificar un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nombre de elemento de marcado.</span><span class="sxs-lookup"><span data-stu-id="765bf-433">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="765bf-434">Básicamente, esta propiedad proporciona una propiedad de conveniencia de nivel de marco WPF para establecer el [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-434">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="765bf-435">Obtener un <xref:System.Windows.FrameworkContentElement.Name%2A> desde código no es común, porque si ya tiene la referencia adecuada en el código, simplemente puede llamar a métodos y propiedades en el elemento de referencia y por lo general no es necesario el <xref:System.Windows.FrameworkContentElement.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-435">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="765bf-436">Una excepción es si la cadena tiene algún significado sobrecargado, por ejemplo si es útil mostrar el nombre en [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-436">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="765bf-437">Establecer un <xref:System.Windows.FrameworkContentElement.Name%2A> desde el código si la versión original <xref:System.Windows.FrameworkContentElement.Name%2A> era conjunto a partir de marcado no se recomienda también y cambiar la propiedad no cambiará la referencia de objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-437">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="765bf-438">Estas referencias de objeto se crean solo cuando se crean explícitamente los ámbitos de nombres subyacentes durante [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] cargando.</span><span class="sxs-lookup"><span data-stu-id="765bf-438">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="765bf-439">Debe llamar específicamente a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> para realizar un cambio efectivo en el <xref:System.Windows.FrameworkContentElement.Name%2A> propiedad de un elemento ya cargado.</span><span class="sxs-lookup"><span data-stu-id="765bf-439">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="765bf-440">Un notables caso de que el valor <xref:System.Windows.FrameworkContentElement.Name%2A> desde el código es importante es para la nomenclatura de los elementos que guiones gráficos will ejecutan.</span><span class="sxs-lookup"><span data-stu-id="765bf-440">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="765bf-441">Para poder registrar un nombre, también tendrá que crear una instancia y asignar un <xref:System.Windows.NameScope> instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-441">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="765bf-442">Vea la sección de ejemplo o [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-442">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="765bf-443">Establecer <xref:System.Windows.FrameworkContentElement.Name%2A> de código tiene aplicaciones limitadas, pero buscar un elemento por su nombre es más común, especialmente si se emplea un modelo de navegación donde se recargan las páginas en la aplicación y el código de tiempo de ejecución no es necesariamente el código subyacente de la que página correspondiente.</span><span class="sxs-lookup"><span data-stu-id="765bf-443">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="765bf-444">El método de utilidad <xref:System.Windows.FrameworkContentElement.FindName%2A>, que está disponible desde cualquier <xref:System.Windows.FrameworkContentElement>, puede buscar cualquier elemento por <xref:System.Windows.FrameworkContentElement.Name%2A> de forma recursiva del árbol lógico de ese elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-444">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="765bf-445">O bien puede usar el <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> método estático de <xref:System.Windows.LogicalTreeHelper>, que también toma la <xref:System.Windows.FrameworkContentElement.Name%2A> cadena como argumento.</span><span class="sxs-lookup"><span data-stu-id="765bf-445">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="765bf-446">Elementos raíz de uso frecuente (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> por ejemplo) implementan la interfaz <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="765bf-446">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="765bf-447">Se esperan las implementaciones de esta interfaz para exigir que los nombres de ser inequívoco dentro de su ámbito.</span><span class="sxs-lookup"><span data-stu-id="765bf-447">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-448">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-448">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-449">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-449">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="765bf-450">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-450">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-451">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Name" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-451">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-452">Proporciona datos sobre el evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-452">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="765bf-453">Se invoca cada vez que el evento enrutado <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> llega a esta clase en su ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-453">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="765bf-454">Implemente este método a fin de agregar el control de clases para este evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-454">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-455">Este método no tiene ninguna implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="765bf-455">This method has no default implementation.</span></span> <span data-ttu-id="765bf-456">Todavía debe llamar a la implementación base en caso de una clase intermedia en la herencia ha implementado este método.</span><span class="sxs-lookup"><span data-stu-id="765bf-456">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="765bf-457">El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en \* métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-457">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="765bf-458">En este caso, el evento correspondiente es un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-458">In this case the matching event is a routed event.</span></span> <span data-ttu-id="765bf-459">El modelo de implementación de los métodos On \* es diferente para los eventos enrutados porque se ha desencadenado el evento enrutado por un elemento secundario, no necesariamente el elemento que va a invocar los controladores.</span><span class="sxs-lookup"><span data-stu-id="765bf-459">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="765bf-460">Por lo tanto, la implementación tendrá que tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos).</span><span class="sxs-lookup"><span data-stu-id="765bf-460">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="765bf-461">Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-461">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="765bf-462">Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-462">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-463">Datos del evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-463">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="765bf-464">Se invoca cada vez que el evento enrutado <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> llega a esta clase en su ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-464">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="765bf-465">Implemente este método a fin de agregar el control de clases para este evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-465">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-466">Este método no tiene ninguna implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="765bf-466">This method has no default implementation.</span></span> <span data-ttu-id="765bf-467">Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.</span><span class="sxs-lookup"><span data-stu-id="765bf-467">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="765bf-468">El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en \* métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-468">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="765bf-469">En este caso, el evento correspondiente es un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-469">In this case the matching event is a routed event.</span></span> <span data-ttu-id="765bf-470">El modelo de implementación de los métodos On \* es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación tendrá que tomar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos).</span><span class="sxs-lookup"><span data-stu-id="765bf-470">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="765bf-471">Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-471">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="765bf-472">Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-472">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-473">Datos del evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-473">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="765bf-474">Controlador de clases para el evento <see cref="E:System.Windows.ContentElement.GotFocus" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-474">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-475">Este controlador de clase establece el comportamiento de foco adecuado en este elemento si se originó el evento de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-475">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="765bf-476">Si el origen del evento fuera otro elemento en el árbol, el controlador no hace nada.</span><span class="sxs-lookup"><span data-stu-id="765bf-476">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="765bf-477">Invalide este método para cambiar el comportamiento de enfoque en el elemento predeterminado.</span><span class="sxs-lookup"><span data-stu-id="765bf-477">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-478">Datos del evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-478">Event data for the event.</span></span></param>
        <summary><span data-ttu-id="765bf-479">Genera el evento <see cref="E:System.Windows.FrameworkContentElement.Initialized" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-479">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span></span> <span data-ttu-id="765bf-480">Este método se invoca siempre que <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> se establece en <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-480">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-481">La implementación predeterminada de este método virtual genera el evento como se describe anteriormente en este tema.</span><span class="sxs-lookup"><span data-stu-id="765bf-481">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="765bf-482">Las invalidaciones deben llamar base () para conservar este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="765bf-482">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="765bf-483">Tenga en cuenta que el <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> propiedad es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="765bf-483">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="765bf-484">Por lo tanto, no se puede establecer para forzar el comportamiento de inicialización de este modo.</span><span class="sxs-lookup"><span data-stu-id="765bf-484">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="765bf-485">Valor de inicialización está pensado para realizarse únicamente por la [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span><span class="sxs-lookup"><span data-stu-id="765bf-485">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-486">Datos del evento que describen la propiedad que cambió, incluidos los valores antiguos y nuevos.</span><span class="sxs-lookup"><span data-stu-id="765bf-486">The event data that describes the property that changed, including the old and new values.</span></span></param>
        <summary><span data-ttu-id="765bf-487">Se invoca cuando se actualiza el valor efectivo de alguna propiedad de dependencia en este <see cref="T:System.Windows.FrameworkContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-487">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span></span> <span data-ttu-id="765bf-488">Propiedad de dependencia concreta que cambió se notifica en el parámetro de argumentos.</span><span class="sxs-lookup"><span data-stu-id="765bf-488">The specific dependency property that changed is reported in the arguments parameter.</span></span> <span data-ttu-id="765bf-489">Invalida <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-489">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-490">Este método no está pensado para detectar generalmente los cambios de propiedad o invalidaciones.</span><span class="sxs-lookup"><span data-stu-id="765bf-490">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="765bf-491">En su lugar se está diseñado para las modificaciones del modelo de invalidación general si se conoce cierta información sobre las clasificaciones de anchas de las propiedades.</span><span class="sxs-lookup"><span data-stu-id="765bf-491">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="765bf-492">Este método se invoca posiblemente muchas veces durante la vida de un objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-492">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="765bf-493">Por lo tanto, puede lograr un mejor rendimiento si invalida los metadatos de las propiedades específicas y, a continuación, adjuntar <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones para las propiedades individuales.</span><span class="sxs-lookup"><span data-stu-id="765bf-493">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="765bf-494">Sin embargo, podría utilizar este método si un <xref:System.Windows.FrameworkContentElement> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.</span><span class="sxs-lookup"><span data-stu-id="765bf-494">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="765bf-495">Tenga en cuenta que hay una con el mismo nombre `OnPropertyChanged` método con una firma diferente (es el tipo de parámetro <xref:System.ComponentModel.PropertyChangedEventArgs>) que pueden aparecer en una serie de clases.</span><span class="sxs-lookup"><span data-stu-id="765bf-495">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="765bf-496">Que `OnPropertyChanged` se usa para las notificaciones del objeto de datos, y forma parte del contrato para <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class="sxs-lookup"><span data-stu-id="765bf-496">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="765bf-497">Llame siempre a la implementación base, como la primera operación en la implementación.</span><span class="sxs-lookup"><span data-stu-id="765bf-497">Always call the base implementation, as the first operation in your implementation.</span></span> <span data-ttu-id="765bf-498">Si no lo hace mucho, se deshabilitará todo el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades, lo que hace que los valores incorrectos que se notificarán.</span><span class="sxs-lookup"><span data-stu-id="765bf-498">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle"><span data-ttu-id="765bf-499">El estilo anterior.</span><span class="sxs-lookup"><span data-stu-id="765bf-499">The old style.</span></span></param>
        <param name="newStyle"><span data-ttu-id="765bf-500">El nuevo estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-500">The new style.</span></span></param>
        <summary><span data-ttu-id="765bf-501">Se invoca cuando cambia el estilo que está en uso en este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-501">Invoked when the style that is in use on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-502">Este método tiene una implementación predeterminada que establece un marcador interno, teniendo en cuenta la condición de estilo que ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="765bf-502">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="765bf-503">Llame siempre a la implementación base, en caso contrario, no se puede aplicar estilos.</span><span class="sxs-lookup"><span data-stu-id="765bf-503">Always call the base implementation, otherwise styles cannot be applied.</span></span> <span data-ttu-id="765bf-504">Podrían incluir escenarios para invalidar este método si la clase derivada tiene un selector de estilo especializado o almacena en caché los valores de estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-504">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span></span> <span data-ttu-id="765bf-505">Cambios de tema podrían invocar este método.</span><span class="sxs-lookup"><span data-stu-id="765bf-505">Theme changes will potentially invoke this method.</span></span></para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-506">Proporciona datos sobre el evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-506">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="765bf-507">Se invoca cada vez que el evento enrutado <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> llega a esta clase en su ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-507">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="765bf-508">Implemente este método a fin de agregar el control de clases para este evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-508">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-509">Este método no tiene ninguna implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="765bf-509">This method has no default implementation.</span></span> <span data-ttu-id="765bf-510">Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.</span><span class="sxs-lookup"><span data-stu-id="765bf-510">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="765bf-511">El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en \* métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-511">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="765bf-512">En este caso, el evento correspondiente es un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-512">In this case the matching event is a routed event.</span></span> <span data-ttu-id="765bf-513">El modelo de implementación de los métodos On \* es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación tendrá que tomar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos).</span><span class="sxs-lookup"><span data-stu-id="765bf-513">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="765bf-514">Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-514">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="765bf-515">Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-515">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="765bf-516">Proporciona datos sobre el evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-516">Provides data about the event.</span></span></param>
        <summary><span data-ttu-id="765bf-517">Se invoca cada vez que el evento enrutado <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> llega a esta clase en su ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-517">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span></span> <span data-ttu-id="765bf-518">Implemente este método a fin de agregar el control de clases para este evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-518">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-519">Este método no tiene ninguna implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="765bf-519">This method has no default implementation.</span></span> <span data-ttu-id="765bf-520">Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.</span><span class="sxs-lookup"><span data-stu-id="765bf-520">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="765bf-521">El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en \* métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</span><span class="sxs-lookup"><span data-stu-id="765bf-521">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="765bf-522">En este caso, el evento correspondiente es un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="765bf-523">El modelo de implementación de los métodos On \* es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación deberá desconectar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos).</span><span class="sxs-lookup"><span data-stu-id="765bf-523">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="765bf-524">Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-524">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="765bf-525">Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.</span><span class="sxs-lookup"><span data-stu-id="765bf-525">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-526">Obtiene o establece un valor que indica si este elemento incorpora las propiedades de estilo de los estilos de tema.</span><span class="sxs-lookup"><span data-stu-id="765bf-526">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span></span></summary>
        <value><span data-ttu-id="765bf-527"><see langword="true" /> si este elemento no utiliza las propiedades de estilo de tema; todas las propiedades que originan un estilo provienen de los estilos de aplicación locales y las propiedades de estilo de tema no se aplican.</span><span class="sxs-lookup"><span data-stu-id="765bf-527"><see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span></span> <span data-ttu-id="765bf-528"><see langword="false" /> si primero se aplican los estilos de aplicación y, a continuación, se aplican los estilos de tema para las propiedades que no se establecieron específicamente en estilos de aplicación.</span><span class="sxs-lookup"><span data-stu-id="765bf-528"><see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-529">El uso más común de esta propiedad es un uso indirecto dentro del establecedor de un estilo que se suministra un estilo con temas.</span><span class="sxs-lookup"><span data-stu-id="765bf-529">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-530">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-531">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-531">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="765bf-532">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-532">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-533">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-533">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-534">Obtiene el elemento primario del árbol lógico de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-534">Gets the parent in the logical tree for this element.</span></span></summary>
        <value><span data-ttu-id="765bf-535">Elemento primario lógico de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-535">The logical parent for this element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-536">Tenga en cuenta que el elemento primario lógico de un elemento puede cambiar según la funcionalidad de la aplicación y mantener el valor de esta propiedad no se reflejará dicho cambio.</span><span class="sxs-lookup"><span data-stu-id="765bf-536">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="765bf-537">Normalmente, debe obtener el valor inmediatamente antes de necesitarla.</span><span class="sxs-lookup"><span data-stu-id="765bf-537">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="765bf-538">Consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) para obtener más información sobre cómo atravesar árboles lógicos y los escenarios donde es apropiado este enfoque hacia la detección del elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-538">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="765bf-539">El sistema de propiedades vuelve a calcular potencialmente todos los valores de propiedad de un elemento cuando cambia de elemento primario, porque algunas propiedades heredan los valores a través del árbol lógico.</span><span class="sxs-lookup"><span data-stu-id="765bf-539">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="765bf-540">El <xref:System.Windows.FrameworkContentElement.DataContext%2A> que se aplica para los enlaces también pueden cambiar cuando los elementos cambian de elemento primario.</span><span class="sxs-lookup"><span data-stu-id="765bf-540">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="765bf-541">Cambiar primario de un elemento solo se realiza normalmente mediante la manipulación de colecciones, mediante el uso de dedicado agregar o quitar métodos, o a través de propiedades de contenido de elementos.</span><span class="sxs-lookup"><span data-stu-id="765bf-541">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="765bf-542">El escenario más típico para usar el <xref:System.Windows.FrameworkContentElement.Parent%2A> propiedad consiste en obtener una referencia y, a continuación, obtener diversos <xref:System.Windows.FrameworkContentElement> los valores de propiedad del elemento primario.</span><span class="sxs-lookup"><span data-stu-id="765bf-542">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="765bf-543">Para las plantillas, el <xref:System.Windows.FrameworkContentElement.Parent%2A> de la plantilla finalmente estará `null`.</span><span class="sxs-lookup"><span data-stu-id="765bf-543">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="765bf-544">Para obtener más allá de este punto y ampliar en el árbol lógico donde realmente se aplica la plantilla, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-544">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-545">El ejemplo siguiente se comprueba para ver si el <xref:System.Windows.FrameworkContentElement.Parent%2A> de un <xref:System.Windows.Documents.TextPointer> es de un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="765bf-545">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="765bf-546">Dirección para la que se debe determinar un cambio de foco probable.</span><span class="sxs-lookup"><span data-stu-id="765bf-546">The direction for which a prospective focus change should be determined.</span></span></param>
        <summary><span data-ttu-id="765bf-547">Determina el elemento siguiente que recibiría el foco relativo a este elemento para una dirección de movimiento de foco proporcionada, pero realmente no mueve el foco.</span><span class="sxs-lookup"><span data-stu-id="765bf-547">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span></span> <span data-ttu-id="765bf-548">Este método está sellado y no se puede invalidar.</span><span class="sxs-lookup"><span data-stu-id="765bf-548">This method is sealed and cannot be overridden.</span></span></summary>
        <returns><span data-ttu-id="765bf-549">Elemento siguiente al que el foco se movería si se atravesara el foco realmente.</span><span class="sxs-lookup"><span data-stu-id="765bf-549">The next element that focus would move to if focus were actually traversed.</span></span> <span data-ttu-id="765bf-550">Puede devolver <see langword="null" /> si el foco no se puede mover en relación con este elemento para la dirección proporcionada.</span><span class="sxs-lookup"><span data-stu-id="765bf-550">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> es el método relacionado que realmente mueve el foco.</span><span class="sxs-lookup"><span data-stu-id="765bf-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="765bf-552">Especificó una de las direcciones siguientes en <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-552">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span></span> <span data-ttu-id="765bf-553">Estas direcciones no son válidas para <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (pero son válidas para <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span><span class="sxs-lookup"><span data-stu-id="765bf-553">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="765bf-554">Nombre que se debe usar para la asignación de objeto y nombre especificada.</span><span class="sxs-lookup"><span data-stu-id="765bf-554">Name to use for the specified name-object mapping.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="765bf-555">Objeto para la asignación.</span><span class="sxs-lookup"><span data-stu-id="765bf-555">Object for the mapping.</span></span></param>
        <summary><span data-ttu-id="765bf-556">Proporciona un descriptor de acceso que simplifica el acceso al método de registro <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-556">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-557">Este método es un método de conveniencia para llamar a <xref:System.Windows.NameScope.RegisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-557">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="765bf-558">La implementación comprobará los elementos primarios sucesivos hasta que encuentra aplicable <xref:System.Windows.NameScope> implementación, que se encuentra al buscar un elemento que implementa <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="765bf-558">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="765bf-559">Para obtener más información sobre los ámbitos de nombres, vea [ámbitos de nombres de XAML de WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-559">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="765bf-560">Una llamada a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> es necesario para enlazar correctamente guiones gráficos de animación para aplicaciones cuando se crean en el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-560">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="765bf-561">Esto es porque una de las claves de propiedades, guión gráfico <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utiliza una búsqueda de nombre de tiempo de ejecución en lugar de ser capaz de hacer referencia a un elemento de destino.</span><span class="sxs-lookup"><span data-stu-id="765bf-561">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="765bf-562">Esto es cierto incluso si ese elemento sea accesible por referencia desde el código.</span><span class="sxs-lookup"><span data-stu-id="765bf-562">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="765bf-563">Para obtener más información sobre por qué necesita registrar los nombres para los destinos de guión gráfico, vea [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-563">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="765bf-564">Las animaciones para los elementos de contenido son menos frecuentes que las animaciones en los controles, el [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) se concentra en escenarios de control.</span><span class="sxs-lookup"><span data-stu-id="765bf-564">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child"><span data-ttu-id="765bf-565">Elemento que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="765bf-565">The element to remove.</span></span></param>
        <summary><span data-ttu-id="765bf-566">Quita el elemento especificado del árbol lógico de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-566">Removes the specified element from the logical tree for this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-567">Esto [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] es principalmente relevante para la clase que deriva de escenarios, al agregar compatibilidad con las colecciones secundarias.</span><span class="sxs-lookup"><span data-stu-id="765bf-567">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="765bf-568">La mayoría <xref:System.Windows.FrameworkContentElement> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <xref:System.Windows.Documents.Span.Inlines%2A> en el <xref:System.Windows.Documents.Span> clase; <xref:System.Windows.Documents.Section.Blocks%2A> en el <xref:System.Windows.Documents.Section> clase).</span><span class="sxs-lookup"><span data-stu-id="765bf-568">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="765bf-569">Derivar de tales clases normalmente puede evitar la necesidad de manipular directamente el árbol lógico.</span><span class="sxs-lookup"><span data-stu-id="765bf-569">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-570">Obtiene o establece el diccionario de recursos actuales definidos localmente.</span><span class="sxs-lookup"><span data-stu-id="765bf-570">Gets or sets the current locally-defined resource dictionary.</span></span></summary>
        <value><span data-ttu-id="765bf-571">Recursos actuales definidos localmente.</span><span class="sxs-lookup"><span data-stu-id="765bf-571">The current locally-defined resources.</span></span> <span data-ttu-id="765bf-572">Éste es un diccionario de recursos, donde se tiene acceso a los recursos dentro del diccionario por clave.</span><span class="sxs-lookup"><span data-stu-id="765bf-572">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-573">Los diccionarios de recursos que se pueden definir por completo o parcialmente en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] normalmente se crean como un elemento de propiedad y suelen estar en el elemento raíz de cualquier página individual o de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="765bf-573">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="765bf-574">Colocar el diccionario de recursos en este nivel hace que sea más fácil encontrar desde los elementos secundarios individuales en la página (o desde cualquier página, en el caso de la aplicación).</span><span class="sxs-lookup"><span data-stu-id="765bf-574">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="765bf-575">En la mayoría de los escenarios de aplicación, se recomienda que los estilos se definen como elementos de objeto dentro de un diccionario de recursos, o se definen como recursos externos para que el recurso de estilo completo puede ser independiente (este enfoque ayuda a diseñador independiente responsabilidades de responsabilidades del programador separando los archivos físicos que tienen que modificarse).</span><span class="sxs-lookup"><span data-stu-id="765bf-575">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="765bf-576">Tenga en cuenta que esta propiedad devuelve solo el diccionario de recursos que se declara directamente dentro de ese elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-576">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="765bf-577">Esto es diferente que el proceso de búsqueda de recursos real, donde un elemento secundario puede tener acceso a cualquiera de los recursos definidos en cada elemento primario, buscando hacia arriba de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="765bf-577">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="765bf-578">También puede hacer referencia a código desde dentro de la colección de recursos, pero tenga en cuenta que los recursos crean en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definitivamente no será accesible hasta después de <xref:System.Windows.FrameworkContentElement.Loaded> generado por el elemento que se declara el diccionario.</span><span class="sxs-lookup"><span data-stu-id="765bf-578">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="765bf-579">De hecho, los recursos se analizan de forma asincrónica y ni siquiera el <xref:System.Windows.FrameworkContentElement.Loaded> eventos es una garantía de que puede hacer referencia a un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] recurso definido.</span><span class="sxs-lookup"><span data-stu-id="765bf-579">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="765bf-580">Por esta razón se debe generalmente sólo tener acceso [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] define los recursos como parte de código en tiempo de ejecución, o a través de otras [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] técnicas como los estilos o las referencias de extensión de recursos para los valores de atributo.</span><span class="sxs-lookup"><span data-stu-id="765bf-580">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="765bf-581">Cuando tenga acceso a los recursos a través del código, es esencialmente equivalente a una referencia realizada desde [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-581">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="765bf-582">Subyacente <xref:System.Windows.ResourceDictionary> es compatible con los métodos necesarios para agregar, quitar o consultar recursos desde dentro de la colección mediante el uso de código.</span><span class="sxs-lookup"><span data-stu-id="765bf-582">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="765bf-583">El <xref:System.Windows.FrameworkContentElement.Resources%2A> propiedad es configurable para admitir el escenario de reemplazar completamente la colección de recursos de un elemento que se va a ser un nuevo o diferente <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-583">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="765bf-584">Tenga en cuenta que el [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis que se muestra no incluyen un elemento para el <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-584">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="765bf-585">Este es un ejemplo de sintaxis de colección implícito; se puede omitir una etiqueta que representa el elemento de la colección.</span><span class="sxs-lookup"><span data-stu-id="765bf-585">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="765bf-586">En su lugar, se especifican los elementos que se agregan como elementos a la colección.</span><span class="sxs-lookup"><span data-stu-id="765bf-586">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="765bf-587">Para obtener más información acerca de las colecciones implícitas y [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consulte [XAML detalles de la sintaxis](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-587">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="765bf-588">Un caso donde un <xref:System.Windows.ResourceDictionary> todavía se especifica explícitamente como un elemento es si va a introducir un diccionario combinado, en cuyo caso normalmente hay ningún elemento secundario para que <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-588">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="765bf-589">Para obtener más información, consulte [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-589">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="765bf-590">Uso de elementos de propiedad XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-590">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-591">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-591">XAML Values</span></span>  
 <span data-ttu-id="765bf-592">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="765bf-592">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="765bf-593">Uno o varios elementos de objeto, cada uno de los cuales define un recurso.</span><span class="sxs-lookup"><span data-stu-id="765bf-593">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="765bf-594">Cada elemento de propiedad de recurso dentro de cada <xref:System.Windows.ResourceDictionary> debe tener un valor único para el [Directiva x: Key](~/docs/framework/xaml-services/x-key-directive.md), que actúa como clave única cuando se recuperan valores de la <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-594">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-595">El siguiente ejemplo se establece un <xref:System.Windows.FrameworkContentElement.Resources%2A> colección en un <xref:System.Windows.Documents.FlowDocument> elemento raíz.</span><span class="sxs-lookup"><span data-stu-id="765bf-595">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="765bf-596"><xref:System.Windows.Documents.FlowDocument> es una opción habitual porque es uno de los pocos <xref:System.Windows.FrameworkContentElement> clases que tengan sentido como un elemento raíz y los recursos se almacenan normalmente en la raíz de la página o en niveles superiores incluso, tales como se muestra en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="765bf-596"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="765bf-597">Asocia un enlace a este elemento para la propiedad de dependencia especificada.</span><span class="sxs-lookup"><span data-stu-id="765bf-597">Attaches a binding to this element for the specified dependency property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="765bf-598">Identifica la propiedad enlazada.</span><span class="sxs-lookup"><span data-stu-id="765bf-598">Identifies the bound property.</span></span></param>
        <param name="path"><span data-ttu-id="765bf-599">Nombre de la propiedad de origen o de la ruta de acceso a la propiedad que se va a usar para el enlace.</span><span class="sxs-lookup"><span data-stu-id="765bf-599">The source property name or the path to the property used for the binding.</span></span></param>
        <summary><span data-ttu-id="765bf-600">Asocia un enlace a este elemento, basado en el nombre de propiedad de origen proporcionado como calificación de la ruta de acceso al origen de datos.</span><span class="sxs-lookup"><span data-stu-id="765bf-600">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span></span></summary>
        <returns><span data-ttu-id="765bf-601">Registra las condiciones del enlace.</span><span class="sxs-lookup"><span data-stu-id="765bf-601">Records the conditions of the binding.</span></span> <span data-ttu-id="765bf-602">Este valor devuelto puede ser útil para la comprobación de errores.</span><span class="sxs-lookup"><span data-stu-id="765bf-602">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-603">Este método es un método de conveniencia para llamar a <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que pasa la instancia actual como el <xref:System.Windows.DependencyObject>y crea un nuevo <xref:System.Windows.Data.Binding> según proporcionado `path` parámetro.</span><span class="sxs-lookup"><span data-stu-id="765bf-603">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="765bf-604">Esta firma es más conveniente si va a establecer un enlace simple de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="765bf-604">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="765bf-605">Si necesita especificar ninguna propiedad de enlace a las condiciones no predeterminado, o desea usar un <xref:System.Windows.Data.MultiBinding> o <xref:System.Windows.Data.PriorityBinding>, debe usar el <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> firma.</span><span class="sxs-lookup"><span data-stu-id="765bf-605">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-606">En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo objeto de datos personalizado, Establece el objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>y establecer la ruta de acceso de enlace a una propiedad dentro de él.</span><span class="sxs-lookup"><span data-stu-id="765bf-606">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="765bf-607">Identifica la propiedad enlazada.</span><span class="sxs-lookup"><span data-stu-id="765bf-607">Identifies the bound property.</span></span></param>
        <param name="binding"><span data-ttu-id="765bf-608">Representa un enlace de datos.</span><span class="sxs-lookup"><span data-stu-id="765bf-608">Represents a data binding.</span></span></param>
        <summary><span data-ttu-id="765bf-609">Asocia un enlace a este elemento, basado en el objeto de enlace ofrecido.</span><span class="sxs-lookup"><span data-stu-id="765bf-609">Attaches a binding to this element, based on the provided binding object.</span></span></summary>
        <returns><span data-ttu-id="765bf-610">Registra las condiciones del enlace.</span><span class="sxs-lookup"><span data-stu-id="765bf-610">Records the conditions of the binding.</span></span> <span data-ttu-id="765bf-611">Este valor devuelto puede ser útil para la comprobación de errores.</span><span class="sxs-lookup"><span data-stu-id="765bf-611">This return value can be useful for error checking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-612">Este método es un método de conveniencia para llamar a <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que pasa la instancia actual como el <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="765bf-612">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-613">En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo <xref:System.Windows.Data.Binding> y establezca el origen en recién compilado `DateTime` objeto.</span><span class="sxs-lookup"><span data-stu-id="765bf-613">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="765bf-614">Propiedad a la que está enlazado el recurso.</span><span class="sxs-lookup"><span data-stu-id="765bf-614">The property to which the resource is bound.</span></span></param>
        <param name="name"><span data-ttu-id="765bf-615">Nombre del recurso.</span><span class="sxs-lookup"><span data-stu-id="765bf-615">The name of the resource.</span></span></param>
        <summary><span data-ttu-id="765bf-616">Busca un recurso con el nombre especificado y establece en él una referencia de recurso para la propiedad especificada.</span><span class="sxs-lookup"><span data-stu-id="765bf-616">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-617">Una referencia de recurso es similar al uso de un [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) en el marcado.</span><span class="sxs-lookup"><span data-stu-id="765bf-617">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="765bf-618">La referencia de recurso crea una expresión interna que proporciona el valor de la propiedad especificada en tiempo de ejecución diferido.</span><span class="sxs-lookup"><span data-stu-id="765bf-618">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="765bf-619">La expresión se reevalúa cada vez que el diccionario de recursos indica un valor ha cambiado a través de eventos internos, o cada vez que se cambia de elemento primario del elemento actual (un cambio primario cambiaría la ruta de acceso de búsqueda de diccionario).</span><span class="sxs-lookup"><span data-stu-id="765bf-619">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-620">Devuelve un valor que indica si los procesos de serialización deben serializar el contenido de la propiedad <see cref="P:System.Windows.FrameworkContentElement.Resources" /> en las instancias de esta clase.</span><span class="sxs-lookup"><span data-stu-id="765bf-620">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="765bf-621">Es <see langword="true" /> si el valor de propiedad <see cref="P:System.Windows.FrameworkContentElement.Resources" /> debe serializarse; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-621"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-622">Esto devolverá `true` , siempre hay al menos un recurso con clave local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-622">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-623">Devuelve un valor que indica si los procesos de serialización deben serializar el contenido de la propiedad <see cref="P:System.Windows.FrameworkContentElement.Style" /> en las instancias de esta clase.</span><span class="sxs-lookup"><span data-stu-id="765bf-623">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="765bf-624">Es <see langword="true" /> si el valor de propiedad <see cref="P:System.Windows.FrameworkContentElement.Style" /> debe serializarse; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-624"><see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-625">Esto devolverá `true` si el <xref:System.Windows.Style> se establece localmente.</span><span class="sxs-lookup"><span data-stu-id="765bf-625">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-626">Se produce cuando cambia cualquier origen de datos asociado que participa en un enlace en este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-626">Occurs when any associated data source participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-627">Este evento emerge la <xref:System.Windows.Data.Binding.SourceUpdated> evento generado por cualquier <xref:System.Windows.Data.Binding> asociado a este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-627">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-628">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-628">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-629">Obtiene o establece el estilo que se va a usar por este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-629">Gets or sets the style to be used by this element.</span></span></summary>
        <value><span data-ttu-id="765bf-630">Estilo aplicado, no predeterminado para el elemento, si está presente.</span><span class="sxs-lookup"><span data-stu-id="765bf-630">The applied, nondefault style for the element, if present.</span></span> <span data-ttu-id="765bf-631">En caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-631">Otherwise, <see langword="null" />.</span></span> <span data-ttu-id="765bf-632">El valor predeterminado para un objeto <see cref="T:System.Windows.FrameworkContentElement" /> construido de forma predeterminada es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-632">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-633">El estilo actual a menudo se proporciona un estilo predeterminado de temas, o de estilos, por lo general se aplican a los objetos de ese tipo por los recursos en el nivel de página o aplicación (un estilo implícito).</span><span class="sxs-lookup"><span data-stu-id="765bf-633">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="765bf-634">Esta propiedad no predeterminada establece o devuelve estilos (tema), sino devuelve el estilo implícito o explícito.</span><span class="sxs-lookup"><span data-stu-id="765bf-634">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="765bf-635">En el caso de los estilos implícitos o explícitos, no importa si el estilo se puede obtener acceso como un recurso o no definido localmente.</span><span class="sxs-lookup"><span data-stu-id="765bf-635">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="765bf-636">Establecer los estilos tiene algunas restricciones.</span><span class="sxs-lookup"><span data-stu-id="765bf-636">Setting the styles has some restrictions.</span></span> <span data-ttu-id="765bf-637">Puede restablecer toda la <xref:System.Windows.FrameworkContentElement.Style%2A> propiedad a un nuevo <xref:System.Windows.Style> en cualquier momento, lo que forzará una recomposición del diseño.</span><span class="sxs-lookup"><span data-stu-id="765bf-637">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="765bf-638">Sin embargo, tan pronto como ese estilo se coloca en uso por un elemento cargado, el <xref:System.Windows.Style> debe considerarse sellado.</span><span class="sxs-lookup"><span data-stu-id="765bf-638">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="765bf-639">Intento de realizar un cambio en cualquier propiedad individual de un estilo en uso (como cualquier elemento dentro de la colección de <xref:System.Windows.Style.Setters%2A>) hace que se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="765bf-639">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="765bf-640">Un estilo que se define en el marcado se considera que están en uso en cuanto se carga desde un diccionario de recursos (para los recursos) o se carga la página que está dentro de (para los estilos en línea).</span><span class="sxs-lookup"><span data-stu-id="765bf-640">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="765bf-641"><xref:System.Windows.FrameworkContentElement.Style%2A> es una propiedad de dependencia con prioridad especial.</span><span class="sxs-lookup"><span data-stu-id="765bf-641"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="765bf-642">Establecida localmente estilo suele funciona con la prioridad más alta en el sistema de propiedades.</span><span class="sxs-lookup"><span data-stu-id="765bf-642">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="765bf-643">Si la <xref:System.Windows.FrameworkContentElement.Style%2A> es null en este momento, durante la carga el sistema de propiedades busca los estilos implícitos como recursos definidos que especifican ese tipo.</span><span class="sxs-lookup"><span data-stu-id="765bf-643">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="765bf-644">Si el estilo todavía es nulo después de este paso, a continuación, el estilo procede del estilo predeterminado (tema), pero no se devuelve el estilo predeterminado en el <xref:System.Windows.FrameworkContentElement.Style%2A> valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-644">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="765bf-645">Consulte [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-645">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-646">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-646">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-647">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-647">XAML Values</span></span>  
 <span data-ttu-id="765bf-648">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="765bf-648">*resourceExtension*</span></span>  
 <span data-ttu-id="765bf-649">Uno de los siguientes:, o.</span><span class="sxs-lookup"><span data-stu-id="765bf-649">One of the following: , or .</span></span> <span data-ttu-id="765bf-650">Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-650">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="765bf-651">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="765bf-651">*styleResourceKey*</span></span>  
 <span data-ttu-id="765bf-652">La clave que identifica el estilo que se solicita.</span><span class="sxs-lookup"><span data-stu-id="765bf-652">The key that identifies the style being requested.</span></span> <span data-ttu-id="765bf-653">La clave hace referencia a un recurso existente en un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="765bf-653">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="765bf-654">Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="765bf-654">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="765bf-655">Consulte [plantillas y estilos alineados](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-655">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="765bf-656">Una referencia de enlace mediante o <xref:System.Windows.Data.Binding> también es posible, pero es poco común.</span><span class="sxs-lookup"><span data-stu-id="765bf-656">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-657">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-657">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-658">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-658">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="765bf-659">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-659">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-660">El siguiente ejemplo se establece un <xref:System.Windows.FrameworkContentElement.Resources%2A> colección en un <xref:System.Windows.Documents.FlowDocument> elemento raíz y, a continuación, hace referencia a él como un recurso como un estilo específico para un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="765bf-660">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-661">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Style" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-661">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName"><span data-ttu-id="765bf-662">Nombre de la propiedad de ambiente solicitada.</span><span class="sxs-lookup"><span data-stu-id="765bf-662">The name of the requested ambient property.</span></span></param>
        <summary><span data-ttu-id="765bf-663">Para obtener una descripción de este miembro, vea el método <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-663">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span></span></summary>
        <returns><span data-ttu-id="765bf-664">Es <see langword="true" /> si <paramref name="propertyName" /> está disponible; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-664"><see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-665">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="765bf-665">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="765bf-666">Solo se puede utilizar cuando la instancia de <xref:System.Windows.FrameworkContentElement> se convierte en una interfaz <xref:System.Windows.Markup.IQueryAmbient>.</span><span class="sxs-lookup"><span data-stu-id="765bf-666">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-667">Obtiene o establece un valor de objeto arbitrario que se puede usar para almacenar información personalizada sobre este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-667">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span></span></summary>
        <value><span data-ttu-id="765bf-668">Valor deseado.</span><span class="sxs-lookup"><span data-stu-id="765bf-668">The intended value.</span></span> <span data-ttu-id="765bf-669">Esta propiedad no tiene ningún valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="765bf-669">This property has no default value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-670">Esta propiedad es análoga a las propiedades de etiqueta en otros modelos de programación de Microsoft, como Visual Basic para aplicaciones o Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="765bf-670">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="765bf-671">Se está diseñado para proporcionar un lugar para almacenar información personalizada básica sobre cualquier elemento sin obligar a los programadores de aplicaciones para crear una subclase preexistente.</span><span class="sxs-lookup"><span data-stu-id="765bf-671">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-672">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-672">XAML Values</span></span>  
 <span data-ttu-id="765bf-673">Dado que esta propiedad toma un objeto, deberá usar el uso del elemento de propiedad para establecer el <xref:System.Windows.FrameworkContentElement.Tag%2A> propiedad en XAML para algo distinto de un objeto con un convertidor de tipos conocido e integrado, como una cadena.</span><span class="sxs-lookup"><span data-stu-id="765bf-673">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="765bf-674">Los objetos utilizados en este modo no están normalmente dentro de los espacios de nombres estándar de WPF y, por tanto, pueden requerir la asignación de espacio de nombres al espacio de nombres externo con el fin se introdujo como elementos XAML.</span><span class="sxs-lookup"><span data-stu-id="765bf-674">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-675">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-675">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-676">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-676">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="765bf-677">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-677">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-678">None</span><span class="sxs-lookup"><span data-stu-id="765bf-678">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-679">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-679">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-680">Se produce cuando cambia cualquier propiedad de destino asociada que participa en un enlace de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-680">Occurs when any associated target property participating in a binding on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-681">Este evento emerge la <xref:System.Windows.Data.Binding.TargetUpdated> evento generado por cualquier <xref:System.Windows.Data.Binding> asociado a este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-681">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="765bf-682">Normalmente, esto significa que el enlace en cuestión es un enlace bidireccional, y que la propiedad de dependencia enlazada afirma una invalidación del valor de propiedad anterior por ninguna validación o esquema de almacenamiento en caché que admite la propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-682">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="765bf-683">Los argumentos de evento de este evento le informará que enlaza la propiedad cambió.</span><span class="sxs-lookup"><span data-stu-id="765bf-683">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-684">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-684">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-685">Obtiene una referencia a la plantilla primaria de este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-685">Gets a reference to the template parent of this element.</span></span> <span data-ttu-id="765bf-686">Esta propiedad no es relevante si el elemento no se creó mediante una plantilla.</span><span class="sxs-lookup"><span data-stu-id="765bf-686">This property is not relevant if the element was not created through a template.</span></span></summary>
        <value><span data-ttu-id="765bf-687">El elemento cuyo <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> provocó que se creó este elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-687">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span></span> <span data-ttu-id="765bf-688">Este valor suele <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-688">This value is frequently <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-689">Las plantillas son realmente objetos compartidos, donde el contenido de la plantilla se crea una sola vez.</span><span class="sxs-lookup"><span data-stu-id="765bf-689">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="765bf-690">Por lo tanto, si obtiene una referencia de objeto a un elemento que proviene de una plantilla, es posible que el árbol lógico aparente no llega a la raíz de la página.</span><span class="sxs-lookup"><span data-stu-id="765bf-690">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="765bf-691">Para poder conectarse a dicha referencia de plantilla al árbol lógico de la página, debe obtener el <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valor y continuar explorando el árbol de elementos como desee.</span><span class="sxs-lookup"><span data-stu-id="765bf-691">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="765bf-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> a menudo será `null` para objetos comunes, porque si ha obtenido una referencia de objeto fuera de una página en la aplicación a través de medios típicos, ese elemento probablemente no se creó desde una plantilla.</span><span class="sxs-lookup"><span data-stu-id="765bf-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="765bf-693">Casos donde <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> podría no ser `null` incluyen operaciones como evento de prueba de posicionamiento, para ciertos eventos de entrada de bajo nivel de control, o para trabajar con los enumeradores, que pueden haber devuelto elementos que provienen de las plantillas.</span><span class="sxs-lookup"><span data-stu-id="765bf-693">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-694">Obtiene o establece el objeto de información sobre herramientas que se muestra para este elemento en la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-694">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="765bf-695">Objeto de información sobre herramientas.</span><span class="sxs-lookup"><span data-stu-id="765bf-695">The tooltip object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-696">Si el valor de esta propiedad es de tipo <xref:System.Windows.Controls.ToolTip>, a continuación, que es la información sobre herramientas que se usará en el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="765bf-696">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="765bf-697">Si el valor es de cualquier otro tipo, a continuación, ese valor se usará como el *contenido* para un <xref:System.Windows.Controls.ToolTip> proporcionado (generada) por el sistema.</span><span class="sxs-lookup"><span data-stu-id="765bf-697">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="765bf-698">Para obtener más información, vea <xref:System.Windows.Controls.ToolTipService>.</span><span class="sxs-lookup"><span data-stu-id="765bf-698">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="765bf-699">La clase de servicio proporciona las propiedades adjuntas que pueden usarse para personalizar aún más una información sobre herramientas.</span><span class="sxs-lookup"><span data-stu-id="765bf-699">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="765bf-700">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-700">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="765bf-701">Uso de elementos de propiedad XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-701">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="765bf-702">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="765bf-702">XAML Values</span></span>  
 <span data-ttu-id="765bf-703">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="765bf-703">*toolTipContent*</span></span>  
 <span data-ttu-id="765bf-704">Una cadena que se convierte en texto para mostrar el <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span><span class="sxs-lookup"><span data-stu-id="765bf-704">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="765bf-705">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="765bf-705">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="765bf-706">Algún objeto, proporcionado en el formulario de elemento de objeto, que debe usarse como el contenido de la <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="765bf-706">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="765bf-707">Normalmente, esto sería un <xref:System.Windows.FrameworkElement> o algún otro elemento que crea la composición de diseño para el <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, finalmente, que contiene el contenido de texto dentro de la composición.</span><span class="sxs-lookup"><span data-stu-id="765bf-707">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="765bf-708">En este uso, el <xref:System.Windows.Controls.ToolTip> elemento se crea implícitamente desde el objeto analizado [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]y el *toolTipObjectContent* contenido está establecido como su <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="765bf-708">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="765bf-709"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="765bf-709"><`ToolTip` .../></span></span>  
 <span data-ttu-id="765bf-710">Vea <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="765bf-710">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="765bf-711">Información sobre propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="765bf-711">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-712">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-712">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="765bf-713">Establecen las propiedades de metadatos en `true`</span><span class="sxs-lookup"><span data-stu-id="765bf-713">Metadata properties set to `true`</span></span>|<span data-ttu-id="765bf-714">None</span><span class="sxs-lookup"><span data-stu-id="765bf-714">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="765bf-715">En el ejemplo siguiente se establece el valor de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propiedad directamente en una cadena.</span><span class="sxs-lookup"><span data-stu-id="765bf-715">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-716">Se produce inmediatamente antes de que se cierre cualquier información sobre herramientas en el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-716">Occurs just before any tooltip on the element is closed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-717">Para suprimir el cierre de la información sobre herramientas, los controladores del evento deben marcará como controlado.</span><span class="sxs-lookup"><span data-stu-id="765bf-717">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="765bf-718">Este evento no puede ser un <xref:System.Windows.EventTrigger> en un estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-718">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="765bf-719">Esto es porque el campo de identificador de este evento vuelve a usa una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-719">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-720">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-721">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-721">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="765bf-722">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-722">Routing strategy</span></span>|<span data-ttu-id="765bf-723">Directa</span><span class="sxs-lookup"><span data-stu-id="765bf-723">Direct</span></span>|  
|<span data-ttu-id="765bf-724">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-724">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-725">Identifica la <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-725">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-726">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-726">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-727">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-727">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-728">Se produce cuando se abre cualquier información sobre herramientas en el elemento.</span><span class="sxs-lookup"><span data-stu-id="765bf-728">Occurs when any tooltip on the element is opened.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-729">Para abrir manualmente la información sobre herramientas, los controladores de los eventos deben marcar el evento pertinente como controlado.</span><span class="sxs-lookup"><span data-stu-id="765bf-729">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="765bf-730">En caso contrario, el valor de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propiedad se usará para abrir automáticamente un menú contextual.</span><span class="sxs-lookup"><span data-stu-id="765bf-730">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="765bf-731">Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propiedad y, a continuación, abra el nuevo <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="765bf-731">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="765bf-732">Tenga en cuenta que no se producirá este evento si <xref:System.Windows.FrameworkContentElement.ToolTip%2A> es una referencia nula o de otro modo no establecido.</span><span class="sxs-lookup"><span data-stu-id="765bf-732">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="765bf-733">Este evento no puede ser un <xref:System.Windows.EventTrigger> en un estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-733">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="765bf-734">Esto es porque el campo de identificador de este evento vuelve a usa una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-734">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-735">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-735">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-736">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-736">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="765bf-737">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-737">Routing strategy</span></span>|<span data-ttu-id="765bf-738">Directa</span><span class="sxs-lookup"><span data-stu-id="765bf-738">Direct</span></span>|  
|<span data-ttu-id="765bf-739">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-739">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-740">Identifica la <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-740">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-741">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-741">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-742">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-742">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-743">Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-743">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey"><span data-ttu-id="765bf-744">Identificador de clave del recurso que se debe encontrar.</span><span class="sxs-lookup"><span data-stu-id="765bf-744">Key identifier of the resource to be found.</span></span></param>
        <summary><span data-ttu-id="765bf-745">Busca un recurso con la clave especificada y lo devuelve si lo encuentra.</span><span class="sxs-lookup"><span data-stu-id="765bf-745">Searches for a resource with the specified key, and returns that resource if found.</span></span></summary>
        <returns><span data-ttu-id="765bf-746">Recurso encontrado.</span><span class="sxs-lookup"><span data-stu-id="765bf-746">The found resource.</span></span> <span data-ttu-id="765bf-747">Si no se encuentra ningún recurso, se devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-747">If no resource was found, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-748">Si no se encuentra el recurso en el elemento que realiza la llamada, se busca en el árbol primario mediante el árbol lógico, de la misma manera que el árbol se buscan si se solicitara una referencia de recurso dinámico por clave en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="765bf-748">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="765bf-749">Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.</span><span class="sxs-lookup"><span data-stu-id="765bf-749">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="765bf-750">El <xref:System.Windows.FrameworkContentElement.FindResource%2A> método tiene un comportamiento similar, salvo que generará una excepción en el caso de no encontrar un recurso con la clave proporcionada.</span><span class="sxs-lookup"><span data-stu-id="765bf-750">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="765bf-751">El ejemplo siguiente busca un recurso, tal como se define en el marcado y aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="765bf-751">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-752">Se produce cuando el elemento se quita desde un árbol de elementos cargados.</span><span class="sxs-lookup"><span data-stu-id="765bf-752">Occurs when the element is removed from an element tree of loaded elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-753">Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan.</span><span class="sxs-lookup"><span data-stu-id="765bf-753">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="765bf-754">Dirigir los eventos enrutados admiten otro comportamiento del evento enrutado: admiten una colección de controladores accesible y puede usarse como un <xref:System.Windows.EventTrigger> en un estilo.</span><span class="sxs-lookup"><span data-stu-id="765bf-754">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="765bf-755">Información sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="765bf-755">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="765bf-756">Campo de identificador</span><span class="sxs-lookup"><span data-stu-id="765bf-756">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="765bf-757">Estrategia de enrutamiento</span><span class="sxs-lookup"><span data-stu-id="765bf-757">Routing strategy</span></span>|<span data-ttu-id="765bf-758">Directa</span><span class="sxs-lookup"><span data-stu-id="765bf-758">Direct</span></span>|  
|<span data-ttu-id="765bf-759">delegado</span><span class="sxs-lookup"><span data-stu-id="765bf-759">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="765bf-760">Identifica la <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="765bf-760">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-761">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="765bf-761">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="765bf-762">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.</span><span class="sxs-lookup"><span data-stu-id="765bf-762">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="765bf-763">Nombre del par de objeto y nombre que se debe quitar del ámbito actual.</span><span class="sxs-lookup"><span data-stu-id="765bf-763">Name of the name-object pair to remove from the current scope.</span></span></param>
        <summary><span data-ttu-id="765bf-764">Simplifica el acceso al método de anulación de registro de <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="765bf-764">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="765bf-765">Solo deberá anular el registro de nombres si piensa volver a registrar otro elemento con el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="765bf-765">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="765bf-766">Vuelve a aplicar el estilo predeterminado al <see cref="T:System.Windows.FrameworkContentElement" /> actual.</span><span class="sxs-lookup"><span data-stu-id="765bf-766">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>