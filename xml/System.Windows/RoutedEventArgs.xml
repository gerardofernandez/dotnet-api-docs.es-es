<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48756042" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="d527d-101">Contiene datos de eventos e información de estado asociados a un evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="d527d-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-102">Diferentes <xref:System.Windows.RoutedEventArgs> puede utilizarse con una sola <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d527d-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="d527d-103">Esta clase es responsable de empaquetar los datos del evento para un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, proporcionando información de estado de evento adicional y se usa el sistema de eventos para invocar el controlador asociado con el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="d527d-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d527d-104">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d527d-105">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-106">Cuando se usa este constructor sin parámetros, propiedades públicas del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:</span><span class="sxs-lookup"><span data-stu-id="d527d-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d527d-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d527d-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`</span><span class="sxs-lookup"><span data-stu-id="d527d-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d527d-109"><xref:System.Windows.RoutedEventArgs.Source%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d527d-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d527d-111">Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo significa que el <xref:System.Windows.RoutedEventArgs> datos no realiza ningún intento para especificar el origen.</span><span class="sxs-lookup"><span data-stu-id="d527d-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="d527d-112">Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.</span><span class="sxs-lookup"><span data-stu-id="d527d-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="d527d-113">Identificador de evento enrutado para esta instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="d527d-114">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />, utilizando el identificador de evento enrutado proporcionado.</span><span class="sxs-lookup"><span data-stu-id="d527d-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-115">Cuando se usa este constructor sobrecargado, no se especifica las propiedades del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:</span><span class="sxs-lookup"><span data-stu-id="d527d-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d527d-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`</span><span class="sxs-lookup"><span data-stu-id="d527d-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d527d-117"><xref:System.Windows.RoutedEventArgs.Source%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="d527d-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d527d-119">Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo quiere decir esto <xref:System.Windows.RoutedEventArgs> no hace ningún intento para especificar el origen.</span><span class="sxs-lookup"><span data-stu-id="d527d-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="d527d-120">Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.</span><span class="sxs-lookup"><span data-stu-id="d527d-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d527d-121">En el ejemplo siguiente se crea un nuevo <xref:System.Windows.RoutedEventArgs> para su uso en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d527d-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="d527d-122">Identificador de evento enrutado para esta instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="d527d-123">Origen alternativo que se notificará cuando se controla el evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="d527d-124">Esto rellena previamente la propiedad <see cref="P:System.Windows.RoutedEventArgs.Source" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="d527d-125">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />, utilizando el identificador de evento enrutado proporcionado y dando la oportunidad de declarar un origen diferente para el evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-126">Cuando se usa este constructor sobrecargado, no se especifica las propiedades del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:</span><span class="sxs-lookup"><span data-stu-id="d527d-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="d527d-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`</span><span class="sxs-lookup"><span data-stu-id="d527d-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="d527d-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="d527d-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="d527d-129">Valores NULL para <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> se rellenan según el elemento que provocó el evento y se pasa mediante el enrutamiento, pero leerá `null` antes de invocación.</span><span class="sxs-lookup"><span data-stu-id="d527d-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="d527d-130">Utilizar esta firma al pasar <xref:System.Windows.RoutedEventArgs> a métodos virtuales como <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, donde los argumentos se usan para llamar a <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.</span><span class="sxs-lookup"><span data-stu-id="d527d-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d527d-131">Obtiene o establece un valor que indica el estado actual del control de eventos para un evento enrutado cuando recorre la ruta.</span><span class="sxs-lookup"><span data-stu-id="d527d-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="d527d-132">Si se establece, se establece en <see langword="true" /> si el evento se debe marcar como controlado; en caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="d527d-133">Si se lee este valor, <see langword="true" /> indica que un controlador de clase o algún controlador de instancia a lo largo de la ruta, ya ha marcado este evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="d527d-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="d527d-134"><see langword="false" /> indica que ese controlador no ha marcado el evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="d527d-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
<span data-ttu-id="d527d-135">El valor predeterminado es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-136">Marcar el evento como controlado limita la visibilidad del evento enrutado en agentes de escucha a lo largo de la ruta del evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="d527d-137">El evento seguir atravesando el resto de la ruta, pero sólo los controladores agregan específicamente con `HandledEventsToo` `true` en el <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> se invocará la llamada al método de respuesta.</span><span class="sxs-lookup"><span data-stu-id="d527d-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="d527d-138">Predeterminada de controladores en los agentes de escucha de instancia (como los que se expresan en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) no se invocará.</span><span class="sxs-lookup"><span data-stu-id="d527d-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="d527d-139">Controlar eventos marcados controlados no es un escenario común.</span><span class="sxs-lookup"><span data-stu-id="d527d-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="d527d-140">Si el autor de un control definir sus propios eventos, las decisiones que tome sobre eventos control en el nivel de clase afectará a los usuarios de su control, así como los usuarios de los controles derivados y potencialmente otros elementos que están contenidos en su control o que contienen el control.</span><span class="sxs-lookup"><span data-stu-id="d527d-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="d527d-141">Para más información, vea [Marcar eventos enrutados como controlados y control de clases](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span><span class="sxs-lookup"><span data-stu-id="d527d-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="d527d-142">En circunstancias muy poco habituales es adecuado controlar los eventos donde <xref:System.Windows.RoutedEventArgs.Handled%2A> está marcado como `true`y modificar los argumentos de evento cambiando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `false`.</span><span class="sxs-lookup"><span data-stu-id="d527d-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="d527d-143">Esto puede ser necesario en determinadas áreas de los eventos de entrada de controles, como control de clave de <xref:System.Windows.UIElement.KeyDown> frente a <xref:System.Windows.UIElement.TextInput> donde bajo nivel y los eventos de entrada de alto niveles que compiten por el control y cada uno está intentando trabajar con una estrategia de enrutamiento distintos.</span><span class="sxs-lookup"><span data-stu-id="d527d-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d527d-144">El ejemplo siguiente implementa un controlador de eventos que marca el evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="d527d-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="d527d-145">Implementación del controlador/delegado genérico que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="d527d-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="d527d-146">El destino en el que se debe invocar el controlador proporcionado.</span><span class="sxs-lookup"><span data-stu-id="d527d-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="d527d-147">Cuando se invalida en una clase derivada, proporciona una manera de invocar controladores de eventos de una forma específica del tipo, lo que puede aumentar la eficacia en la implementación base.</span><span class="sxs-lookup"><span data-stu-id="d527d-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-148">La implementación base incorpora una reflexión para determinar el controlador correcto para todos los casos donde el controlador no es literalmente <xref:System.Windows.RoutedEventHandler>, y este paso de reflexión tiene algunas consecuencias de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d527d-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="d527d-149">Las invocaciones se pueden hacer más eficaces, no se base en la reflexión.</span><span class="sxs-lookup"><span data-stu-id="d527d-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="d527d-150">Este es el escenario que motiva este método está disponible para cualquier clase de argumentos de evento enrutado que elija invalidarlo.</span><span class="sxs-lookup"><span data-stu-id="d527d-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="d527d-151">Las implementaciones no deben llamar a la base para este método, porque su implementación ya debe ser responsable de invocar los controladores de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="d527d-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d527d-152">El siguiente es un pseudocódigo que ilustra un patrón básico que puede usarse para la implementación.</span><span class="sxs-lookup"><span data-stu-id="d527d-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="d527d-153">En este caso, `MyRoutedEventHandler` es una subclase de <xref:System.Windows.RoutedEventHandler>.</span><span class="sxs-lookup"><span data-stu-id="d527d-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d527d-154">Este método está pensado para ser invalidado por las clases de datos de evento derivados para proporcionar una invocación más eficaz de sus delegados.</span><span class="sxs-lookup"><span data-stu-id="d527d-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="d527d-155">La implementación debería convertir proporcionado <paramref name="genericHandler" /> específico del tipo de delegado y, a continuación, invocar ese controlador.</span><span class="sxs-lookup"><span data-stu-id="d527d-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
<span data-ttu-id="d527d-156">La implementación predeterminada intentará invocar el controlador proporcionado, intentando convertirlo como <see cref="T:System.Windows.RoutedEventHandler" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="d527d-157">Si bien <paramref name="genericHandler" /> o <paramref name="genericTarget" /> se proporciona como <see langword="null" />, se generan excepciones.</span><span class="sxs-lookup"><span data-stu-id="d527d-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="d527d-158">Nuevo valor en el que se establece <see cref="P:System.Windows.RoutedEventArgs.Source" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="d527d-159">Cuando se invalida en una clase derivada, proporciona un punto de entrada de devolución de llamada de notificación cada vez que cambia el valor de propiedad <see cref="P:System.Windows.RoutedEventArgs.Source" /> de una instancia.</span><span class="sxs-lookup"><span data-stu-id="d527d-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d527d-160">Cambiar el origen de un evento notificado mediante programación posiblemente puede exigir la actualización de los datos específicos del tipo dentro del evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="d527d-161">Por este motivo, el <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> método está protegido virtual y está pensado para ser invalidado por las subclases de <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
<span data-ttu-id="d527d-162">Este método no tiene ninguna implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="d527d-162">This method has no default implementation.</span></span></para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d527d-163">Obtiene el origen inicial de los informes determinado por pruebas de acceso puro, antes de que una clase primaria realice posibles ajustes de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="d527d-164">Origen de notificación original, antes de cualquier posible ajuste de <see cref="P:System.Windows.RoutedEventArgs.Source" /> realizado por el control de clases, que se puede hacer para aplanar árboles de elementos compuestos.</span><span class="sxs-lookup"><span data-stu-id="d527d-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-165">Esta propiedad adquiere su valor una vez, antes de la clase de controladores de eventos o cualquier instancia se invocan y nunca se ajusta más allá de este punto.</span><span class="sxs-lookup"><span data-stu-id="d527d-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="d527d-166">La información de origen original es de solo lectura a los controladores de clase o implementaciones de la clase, tal como se notifica en los datos del evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="d527d-167">Donde se puede ajustar el origen de los casos comunes incluyen elementos de contenido dentro de un modelo de contenido para un control (el contenido de un elemento de lista, por ejemplo, notificará el elemento de lista como la <xref:System.Windows.RoutedEventArgs.Source%2A> y el elemento real dentro del elemento de lista será el <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="d527d-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="d527d-168">Ajuste de origen por varios elementos y los modelos de contenido varía en función de la clase.</span><span class="sxs-lookup"><span data-stu-id="d527d-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="d527d-169">Cada clase que se ajusta a los orígenes de eventos intenta anticipar qué origen es el más útil informar de más escenarios de entrada y los escenarios para los que la clase está diseñada y, a continuación, Establece que el origen de como el <xref:System.Windows.RoutedEventArgs.Source%2A>.</span><span class="sxs-lookup"><span data-stu-id="d527d-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="d527d-170">Si este origen no es aquel que tiene relevancia para el control del evento, vuelva a comprobar <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> en su lugar para ver si notifica un origen diferente que sea más adecuado.</span><span class="sxs-lookup"><span data-stu-id="d527d-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="d527d-171">Para obtener más detalles sobre los eventos de entrada, consulte [información general sobre entrada](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="d527d-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d527d-172">Obtiene o establece el <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> asociado a esta instancia de <see cref="T:System.Windows.RoutedEventArgs" />.</span><span class="sxs-lookup"><span data-stu-id="d527d-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="d527d-173">Identificador del evento que se ha invocado.</span><span class="sxs-lookup"><span data-stu-id="d527d-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-174">No se puede establecer este valor en un <xref:System.Windows.RoutedEventArgs> que ya se ha enrutado (por ejemplo, si ha obtenido los argumentos a través de un controlador).</span><span class="sxs-lookup"><span data-stu-id="d527d-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="d527d-175">Intenta hacer esto, se generará una excepción.</span><span class="sxs-lookup"><span data-stu-id="d527d-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="d527d-176">Solo se puede establecer en una instancia que aún no se ha usado para generar una invocación del evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="d527d-177">El valor de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> no puede ser `null` en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="d527d-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d527d-178">El ejemplo siguiente se crea nuevos datos de eventos enrutados con un constructor inicial y, a continuación, Establece el <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propiedad como una operación posterior.</span><span class="sxs-lookup"><span data-stu-id="d527d-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="d527d-179">Debe tener <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> establecido antes de provocar el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="d527d-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d527d-180">Se ha intentado cambiar el valor <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> mientras se enruta el evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d527d-181">Obtiene o establece una referencia al objeto que generó el evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="d527d-182">El objeto que ha generado el evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d527d-183">Para cualquier propagación enruta el evento que se haya desplazado realmente la ruta más allá del elemento que lo generó, y para cualquier tipo de túnel enruta los eventos que no tiene todavía hasta el elemento que lo generó, el valor de la tunelización <xref:System.Windows.RoutedEventArgs.Source%2A> será diferente del valor de la `sender` parámetro de la clase de argumentos de evento.</span><span class="sxs-lookup"><span data-stu-id="d527d-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="d527d-184">Cuál de los dos elementos implicados en el evento son de la mayor importancia en cualquier controlador determinado (<xref:System.Windows.RoutedEventArgs.Source%2A>, el elemento que lo provocó o `sender`, el elemento que se está controlando actualmente) depende de la lógica de aplicación que es el controlador direccionamiento.</span><span class="sxs-lookup"><span data-stu-id="d527d-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="d527d-185">Al establecer esta propiedad normalmente solo se realiza al invalidar o implementar otras [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] que ajustar los orígenes de eventos, como cuando un evento de control de clases.</span><span class="sxs-lookup"><span data-stu-id="d527d-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="d527d-186">No se recomienda restablecer orígenes de eventos aparente de los controladores de instancia, especialmente cuando el controlador no marca el evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="d527d-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="d527d-187">Si restablece <xref:System.Windows.RoutedEventArgs.Source%2A> para informar de un origen de eventos diferentes, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> seguirá al informe de origen como primera generado por el que se origina <xref:System.Windows.UIElement.RaiseEvent%2A> llamar.</span><span class="sxs-lookup"><span data-stu-id="d527d-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>