<Type Name="NameScope" FullName="System.Windows.NameScope">
  <TypeSignature Language="C#" Value="public class NameScope : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,object&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;, System.Windows.Markup.INameScopeDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NameScope extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, object&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable, class System.Windows.Markup.INameScope, class System.Windows.Markup.INameScopeDictionary" />
  <TypeSignature Language="DocId" Value="T:System.Windows.NameScope" />
  <TypeSignature Language="VB.NET" Value="Public Class NameScope&#xA;Implements ICollection(Of KeyValuePair(Of String, Object)), IDictionary(Of String, Object), IEnumerable(Of KeyValuePair(Of String, Object)), INameScopeDictionary" />
  <TypeSignature Language="C++ CLI" Value="public ref class NameScope : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;, System::Windows::Markup::INameScopeDictionary" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScopeDictionary</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a7dba-101">Implementa compatibilidad básica de WPF con los métodos de <see cref="T:System.Windows.Markup.INameScope" /> que almacenan o recuperan las asignaciones de nombres y objetos de un ámbito de nombres XAML concreto.</span><span class="sxs-lookup"><span data-stu-id="a7dba-101">Implements base WPF support for the <see cref="T:System.Windows.Markup.INameScope" /> methods that store or retrieve name-object mappings into a particular XAML namescope.</span></span> <span data-ttu-id="a7dba-102">Agrega compatibilidad con propiedades adjuntas para que sea más fácil obtener o establecer nombres de ámbito de nombres XAML dinámicamente en el nivel del elemento.</span><span class="sxs-lookup"><span data-stu-id="a7dba-102">Adds attached property support to make it simpler to get or set XAML namescope names dynamically at the element level..</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-103">Esta clase implementa compatibilidad integrada de ámbito de nombres XAML para el tratamiento de WPF de XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-103">This class implements built-in XAML namescope support for WPF treatment of XAML.</span></span> <span data-ttu-id="a7dba-104"><xref:System.Windows.NameScope> Ayuda en la creación de ámbitos de nombres XAML inicial basándose en el análisis de XAML, por ejemplo, al crear instancias de estilos y plantillas.</span><span class="sxs-lookup"><span data-stu-id="a7dba-104"><xref:System.Windows.NameScope> assists in creation of initial XAML namescopes based on parsing XAML, such as when instantiating styles and templates.</span></span> <span data-ttu-id="a7dba-105">También admite la creación de ámbitos de nombres XAML en los procesos que se producen fuera de la carga normal de XAML de elementos de la implementación de procesador XAML de WPF.</span><span class="sxs-lookup"><span data-stu-id="a7dba-105">It also supports creation of XAML namescopes by processes that occur outside of normal XAML loading of elements by the WPF XAML processor implementation.</span></span>  
  
 <span data-ttu-id="a7dba-106"><xref:System.Windows.NameScope> es generalmente se dedica más a proporcionar infraestructura que para los escenarios de código de usuario comunes que implican trabajar con un ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-106"><xref:System.Windows.NameScope> is generally more devoted to supplying infrastructure than for common user code scenarios that involve working with a XAML namescope.</span></span> <span data-ttu-id="a7dba-107">Para la mayoría de los escenarios, la <xref:System.Windows.FrameworkElement.FindName%2A> métodos expuestos en <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> son métodos más adecuados para llamar a para buscar elementos por nombre definido por el XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-107">For most scenarios, the <xref:System.Windows.FrameworkElement.FindName%2A> methods exposed on <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> are more appropriate methods to call to search for elements by XAML-defined name.</span></span> <span data-ttu-id="a7dba-108">El <xref:System.Windows.FrameworkElement.Name%2A> propiedades expuestas por <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> son propiedades más adecuadas para usar para establecer el nombre inicial como atributos de marcado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-108">The <xref:System.Windows.FrameworkElement.Name%2A> properties exposed by <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> are more appropriate properties to use to set the initial name as markup attributes.</span></span>  
  
 <span data-ttu-id="a7dba-109">Los diversos métodos de <xref:System.Windows.NameScope> se usan elementos base y otras clases que mantengan ámbitos de nombres XAML con el fin de admitir <xref:System.Windows.Markup.INameScope.RegisterName%2A> y <xref:System.Windows.Markup.INameScope.FindName%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7dba-109">The various methods of <xref:System.Windows.NameScope> are used by base elements and other classes that maintain XAML namescopes in order to support <xref:System.Windows.Markup.INameScope.RegisterName%2A> and <xref:System.Windows.Markup.INameScope.FindName%2A>.</span></span> <span data-ttu-id="a7dba-110">Por lo general se usa la API en la <xref:System.Windows.NameScope> clase solo si va a reemplazar o aumentar el comportamiento del elemento base sobre cómo procesan ámbitos de nombres XAML para los elementos de la raíz de una página XAML y como parte de plantillas (que utilizan un ámbito de nombres XAML independiente del resto de la página).</span><span class="sxs-lookup"><span data-stu-id="a7dba-110">You generally use the API in the <xref:System.Windows.NameScope> class only if you are replacing or augmenting the base element behavior for how they process XAML namescopes for root elements of a XAML page, and as part of templates (which use a separate XAML namescope from the rest of the page).</span></span>  
  
 <span data-ttu-id="a7dba-111">En [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.Windows.NameScope> proporciona implementaciones de interfaz de colección, que puede tener acceso a las colecciones de nombres que se incluyen en un ámbito de nombres XAML, incluida la adición a él a través de llamadas a un <xref:System.Windows.NameScope.Add%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a7dba-111">In [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.Windows.NameScope> provides collection interface implementations such that you can access the collections of names that are held by a XAML namescope, including adding to it through calls to an <xref:System.Windows.NameScope.Add%2A> method.</span></span>  
  
 <span data-ttu-id="a7dba-112">Para obtener más información sobre los conceptos de ámbito de nombres XAML, vea [ámbitos de nombres de XAML de WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="a7dba-112">For more information on XAML namescope concepts, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="a7dba-113">Nombres en un ámbito de nombres XAML deben utilizar una gramática determinada que restringe las cadenas que se puede usar para las entradas de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="a7dba-113">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="a7dba-114">Vea [XamlName (gramática)](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="a7dba-114">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.INameScope" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NameScope();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7dba-115">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-115">Initializes a new instance of the <see cref="T:System.Windows.NameScope" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7dba-116">Agrega un elemento a la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-116">Adds an item to the collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="a7dba-117"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clave es <see cref="T:System.String" />, el valor es <see cref="T:System.Object" />) que representa la asignación de nombres que se va a agregar al ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-117">A <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />) that represents the name mapping to add to the XAML namescope.</span></span></param>
        <summary><span data-ttu-id="a7dba-118">Agrega un elemento a la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-118">Adds an item to the collection.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7dba-119">Uno o ambos componentes de <paramref name="item" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-119">Either or both components of <paramref name="item" /> are <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Add(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a7dba-120">Clave de cadena, que es el nombre de la asignación del ámbito de nombres XAML que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-120">The string key, which is the name of the XAML namescope mapping to add.</span></span></param>
        <param name="value"><span data-ttu-id="a7dba-121">Valor de objeto, que es la referencia al objeto de la asignación del ámbito de nombres XAML que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-121">The object value, which is the object reference of the XAML namescope mapping to add.</span></span></param>
        <summary><span data-ttu-id="a7dba-122">Agrega un elemento a la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-122">Adds an item to the collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-123">Este método ajusta básicamente <xref:System.Windows.NameScope.Add%2A> por lo que no es necesario que implican la <xref:System.Collections.Generic.KeyValuePair%602> tipo en su uso.</span><span class="sxs-lookup"><span data-stu-id="a7dba-123">This method basically wraps <xref:System.Windows.NameScope.Add%2A> so that it is not necessary to involve the <xref:System.Collections.Generic.KeyValuePair%602> type in your usage.</span></span>  
  
 <span data-ttu-id="a7dba-124">Nombres en un ámbito de nombres XAML deben utilizar una gramática determinada que restringe las cadenas que se puede usar para las entradas de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="a7dba-124">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="a7dba-125">Vea [XamlName (gramática)](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="a7dba-125">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-126">El valor de <paramref name="key" /> o <paramref name="value" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-126"><paramref name="key" /> or <paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7dba-127">Quita todos los elementos de la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-127">Removes all items from the collection.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, Object)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="a7dba-128">Elemento que se va a buscar en la colección, especificado como <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clave es <see cref="T:System.String" />, el valor es <see cref="T:System.Object" />).</span><span class="sxs-lookup"><span data-stu-id="a7dba-128">The item to find in the collection, specified as a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />).</span></span></param>
        <summary><span data-ttu-id="a7dba-129">Determina si la colección contiene el elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-129">Determines whether the collection contains a specified item.</span></span></summary>
        <returns>
          <span data-ttu-id="a7dba-130">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.KeyValuePair`2" /> especificado identifica una asignación existente en <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-130"><see langword="true" /> if the specified <see cref="T:System.Collections.Generic.KeyValuePair`2" /> identifies an existing mapping in this <see cref="T:System.Windows.NameScope" /> .</span></span> <span data-ttu-id="a7dba-131">Es <see langword="false" /> si el parámetro <see cref="T:System.Collections.Generic.KeyValuePair`2" /> especificado no existe en la clase <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-131"><see langword="false" /> if the specified <see cref="T:System.Collections.Generic.KeyValuePair`2" /> does not exist in the current <see cref="T:System.Windows.NameScope" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-132">Por lo general solo está interesado en si un nombre ya se ha definido en el ámbito de nombres XAML y se asigna a qué valor de referencia de objeto es irrelevante.</span><span class="sxs-lookup"><span data-stu-id="a7dba-132">Generally you are only interested in whether a name is already defined in the XAML namescope, and what object reference value it is mapped to is immaterial.</span></span> <span data-ttu-id="a7dba-133">En este escenario, puede llamar a <xref:System.Windows.NameScope.ContainsKey%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-133">For this scenario, you can call <xref:System.Windows.NameScope.ContainsKey%2A> instead.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a7dba-134"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-134"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a7dba-135">Clave de cadena que se va a buscar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-135">The string key to find.</span></span></param>
        <summary><span data-ttu-id="a7dba-136">Devuelve un valor que indica si el nombre proporcionado ya existe en esta clase <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-136">Returns whether a provided name already exists in this <see cref="T:System.Windows.NameScope" />.</span></span></summary>
        <returns>
          <span data-ttu-id="a7dba-137">Es <see langword="true" /> si el parámetro <paramref name="key" /> especificado identifica un nombre para una asignación existente en <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-137"><see langword="true" /> if the specified <paramref name="key" /> identifies a name for an existing mapping in this <see cref="T:System.Windows.NameScope" />.</span></span> <span data-ttu-id="a7dba-138">Es <see langword="false" /> si el parámetro <paramref name="key" /> especificado no existe en la clase <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-138"><see langword="false" /> if the specified <paramref name="key" /> does not exist in the current <see cref="T:System.Windows.NameScope" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-139">Nombres en un ámbito de nombres XAML deben utilizar una gramática determinada que restringe las cadenas que se puede usar para las entradas de <xref:System.Windows.NameScope> API.</span><span class="sxs-lookup"><span data-stu-id="a7dba-139">Names in a XAML namescope must use a particular grammar that restricts the strings you might use for inputs of <xref:System.Windows.NameScope> API.</span></span> <span data-ttu-id="a7dba-140">Vea [XamlName (gramática)](~/docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="a7dba-140">See [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-141"><paramref name="key" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-141"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;string,object&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of String, Object)(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a7dba-142">Matriz unidimensional que es el destino de los elementos copiados de la colección. La indización de la matriz debe ser de base cero.</span><span class="sxs-lookup"><span data-stu-id="a7dba-142">The one-dimensional array that is the destination of the elements copied from the collection The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="a7dba-143">Índice de base cero de <c>array</c> donde comienza la copia.</span><span class="sxs-lookup"><span data-stu-id="a7dba-143">The zero-based index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="a7dba-144">Copia los elementos de la colección en una matriz a partir de un índice de matriz concreto.</span><span class="sxs-lookup"><span data-stu-id="a7dba-144">Copies the elements of the collection to an array, starting at a particular array index.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7dba-145">Devuelve el número de elementos de la colección de nombres asignados de esta clase <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-145">Returns the number of items in the collection of mapped names in this <see cref="T:System.Windows.NameScope" />.</span></span></summary>
        <value><span data-ttu-id="a7dba-146">Número de elementos de la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-146">The number of items in the collection.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.FindName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a7dba-147">Parte del nombre de una asignación existente para recuperar la parte correspondiente al objeto.</span><span class="sxs-lookup"><span data-stu-id="a7dba-147">Name portion of an existing mapping to retrieve the object portion for.</span></span></param>
        <summary><span data-ttu-id="a7dba-148">Devuelve el objeto correspondiente del ámbito de nombres XAML mantenido por esta clase <see cref="T:System.Windows.NameScope" />, basándose en la cadena de nombre proporcionado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-148">Returns the corresponding object in the XAML namescope maintained by this <see cref="T:System.Windows.NameScope" />, based on a provided name string.</span></span></summary>
        <returns><span data-ttu-id="a7dba-149">Objeto solicitado que está asignado a <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-149">The requested object that is mapped with <paramref name="name" />.</span></span> <span data-ttu-id="a7dba-150">Puede devolver <see langword="null" /> si el valor del parámetro <paramref name="name" /> es <see langword="null" /> o una cadena vacía, o bien, si no se encontró ningún objeto coincidente.</span><span class="sxs-lookup"><span data-stu-id="a7dba-150">Can return <see langword="null" /> if <paramref name="name" /> was provided as <see langword="null" /> or empty string, or if no matching object was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-151">Varios elementos de base (<xref:System.Windows.FrameworkElement>, <xref:System.Windows.FrameworkElement>) también exponen un `FindName` método con una funcionalidad idéntica.</span><span class="sxs-lookup"><span data-stu-id="a7dba-151">Several base elements (<xref:System.Windows.FrameworkElement>, <xref:System.Windows.FrameworkElement>) also expose a `FindName` method with identical functionality.</span></span> <span data-ttu-id="a7dba-152">Las versiones de elemento base realizan una búsqueda de ámbito de nombres XAML en el árbol lógico convencional, trabajando hacia el elemento raíz.</span><span class="sxs-lookup"><span data-stu-id="a7dba-152">The base element versions perform a XAML namescope search within the conventional logical tree, working towards the root element.</span></span> <span data-ttu-id="a7dba-153">Una vez que se determina el ámbito de nombres XAML, se consulta ese ámbito de nombres XAML para el nombre solicitado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-153">Once the XAML namescope is determined, that XAML namescope is queried for the requested name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindName(System.String)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNameScope">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.INameScope GetNameScope (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.INameScope GetNameScope(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.GetNameScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::INameScope ^ GetNameScope(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject"><span data-ttu-id="a7dba-154">Objeto del que se va a obtener el ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-154">The object to get the XAML namescope from.</span></span></param>
        <summary><span data-ttu-id="a7dba-155">Proporciona el descriptor de acceso get de la propiedad adjunta <see cref="P:System.Windows.NameScope.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-155">Provides the attached property get accessor for the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span></span></summary>
        <returns><span data-ttu-id="a7dba-156">Ámbito de nombres XAML, como una instancia de <see cref="T:System.Windows.Markup.INameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-156">A XAML namescope, as an <see cref="T:System.Windows.Markup.INameScope" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-157">El propósito de este método es implementar la `get` descriptor de acceso para el uso de <xref:System.Windows.NameScope.NameScope%2A> como una propiedad adjunta en XAML y proporcionar el descriptor de acceso para realizar la operación equivalente en el código.</span><span class="sxs-lookup"><span data-stu-id="a7dba-157">The purpose of this method is both to implement the `get` accessor for using <xref:System.Windows.NameScope.NameScope%2A> as an attached property in XAML usage, and to provide the accessor for performing the equivalent operation in code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-158"><paramref name="dependencyObject" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-158"><paramref name="dependencyObject" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7dba-159">Obtiene un valor que indica si la colección es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="a7dba-159">Gets a value indicating whether the collection is read-only.</span></span></summary>
        <value><span data-ttu-id="a7dba-160">Siempre devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-160">Always returns <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a7dba-161">Nombre de cadena de la asignación de nombres XAML que se va a obtener o establecer.</span><span class="sxs-lookup"><span data-stu-id="a7dba-161">The string name for the XAML name mapping to get or set.</span></span></param>
        <summary><span data-ttu-id="a7dba-162">Obtiene o establece el elemento con la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="a7dba-162">Gets or sets the item with the specified key.</span></span></summary>
        <value><span data-ttu-id="a7dba-163">Valor del objeto asignado por el nombre XAML que se ha proporcionado como <paramref name="key" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-163">The value of the object mapped by the XAML name provided as <paramref name="key" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-164"><paramref name="key" /> se proporciona como <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-164"><paramref name="key" /> is provided as <see langword="null" />.</span></span>  
  
 <span data-ttu-id="a7dba-165">O bien</span><span class="sxs-lookup"><span data-stu-id="a7dba-165">-or-</span></span>  
  
 <span data-ttu-id="a7dba-166"><paramref name="value" /> se proporciona como <see langword="null" /> para una operación de establecimiento.</span><span class="sxs-lookup"><span data-stu-id="a7dba-166"><paramref name="value" /> is provided as <see langword="null" /> for a set operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7dba-167">Obtiene una colección de las claves del diccionario de <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-167">Gets a collection of the keys in the <see cref="T:System.Windows.NameScope" /> dictionary.</span></span></summary>
        <value><span data-ttu-id="a7dba-168">Colección de las claves del diccionario de <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-168">A collection of the keys in the <see cref="T:System.Windows.NameScope" /> dictionary.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameScope">
      <MemberSignature Language="C#" Value="see GetNameScope, and SetNameScope" />
      <MemberSignature Language="ILAsm" Value="see GetNameScope, and SetNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.NameScope" />
      <MemberSignature Language="VB.NET" Value="see GetNameScope, and SetNameScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NameScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.NameScope.NameScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7dba-169">Identifica la propiedad adjunta <see cref="P:System.Windows.NameScope.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-169">Identifies the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a7dba-170">Nombre que se usará para asignar el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-170">The name to use for mapping the given object.</span></span></param>
        <param name="scopedElement"><span data-ttu-id="a7dba-171">Objeto que se va a asignar al nombre proporcionado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-171">The object to be mapped to the provided name.</span></span></param>
        <summary><span data-ttu-id="a7dba-172">Registra un nuevo par de nombre y objeto en el ámbito de nombres XAML actual.</span><span class="sxs-lookup"><span data-stu-id="a7dba-172">Registers a new name-object pair into the current XAML namescope.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-173"><paramref name="name" /> o <paramref name="scopedElement" /> se proporcionó como <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-173"><paramref name="name" /> or <paramref name="scopedElement" /> was provided as <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a7dba-174"><paramref name="name" /> es una cadena vacía</span><span class="sxs-lookup"><span data-stu-id="a7dba-174"><paramref name="name" /> was provided as empty string</span></span>  
  
 <span data-ttu-id="a7dba-175">\- o -</span><span class="sxs-lookup"><span data-stu-id="a7dba-175">\- or -</span></span>  
  
 <span data-ttu-id="a7dba-176">Se ha rechazado el valor de <paramref name="name" /> proporcionado porque contenía caracteres no válidos para nombres XAML</span><span class="sxs-lookup"><span data-stu-id="a7dba-176"><paramref name="name" /> provided was rejected by the parser, because it contained characters that are invalid for a XAML name</span></span>  
  
 <span data-ttu-id="a7dba-177">\- o -</span><span class="sxs-lookup"><span data-stu-id="a7dba-177">\- or -</span></span>  
  
 <span data-ttu-id="a7dba-178">El valor de <paramref name="name" /> proporcionado daría lugar al registro de nombres duplicados.</span><span class="sxs-lookup"><span data-stu-id="a7dba-178"><paramref name="name" /> provided would result in a duplicate name registration.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7dba-179">Quita el objeto especificado de la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-179">Removes the specific object from the collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Collections.Generic.KeyValuePair&lt;string,object&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As KeyValuePair(Of String, Object)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt; item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="a7dba-180">Objeto que se va a quitar de la colección, especificado como una estructura <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (la clave es <see cref="T:System.String" />, el valor es <see cref="T:System.Object" />).</span><span class="sxs-lookup"><span data-stu-id="a7dba-180">The object to remove from the collection, specified as a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> (key is <see cref="T:System.String" />, value is <see cref="T:System.Object" />).</span></span></param>
        <summary><span data-ttu-id="a7dba-181">Quita el objeto especificado de la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-181">Removes the specific object from the collection.</span></span></summary>
        <returns>
          <span data-ttu-id="a7dba-182">Es <see langword="true" /> si el elemento se eliminó correctamente de la colección; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-182"><see langword="true" /> if item was successfully removed from the collection, otherwise <see langword="false" />.</span></span> <span data-ttu-id="a7dba-183">También devuelve <see langword="false" /> si no se encontró el elemento en la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-183">Also returns <see langword="false" /> if the item was not found in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-184">Dado que <xref:System.Windows.NameScope> es un diccionario no hay ningún concepto de primera aparición; cualquier <xref:System.Collections.Generic.KeyValuePair%602> es único garantizado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-184">Because <xref:System.Windows.NameScope> is a dictionary there is no concept of first occurrence; any given <xref:System.Collections.Generic.KeyValuePair%602> is guaranteed unique.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::String ^ key);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a7dba-185">Clave de cadena, que es el nombre de la asignación del ámbito de nombres XAML que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-185">The string key, which is the name of the XAML namescope mapping to remove.</span></span></param>
        <summary><span data-ttu-id="a7dba-186">Quita de la colección una asignación del nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-186">Removes a mapping for a specified name from the collection.</span></span></summary>
        <returns>
          <span data-ttu-id="a7dba-187">Es <see langword="true" /> si el elemento se eliminó correctamente de la colección; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-187"><see langword="true" /> if item was successfully removed from the collection, otherwise <see langword="false" />.</span></span> <span data-ttu-id="a7dba-188">También devuelve <see langword="false" /> si no se encontró el elemento en la colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-188">Also returns <see langword="false" /> if the item was not found in the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-189">Este método ajusta básicamente <xref:System.Windows.NameScope.UnregisterName%2A>, devolver `false` en casos en que de lo contrario, habrían producido excepciones en <xref:System.Windows.NameScope.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7dba-189">This method basically wraps <xref:System.Windows.NameScope.UnregisterName%2A>, returning `false` in cases that otherwise would have raised exceptions in <xref:System.Windows.NameScope.UnregisterName%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNameScope">
      <MemberSignature Language="C#" Value="public static void SetNameScope (System.Windows.DependencyObject dependencyObject, System.Windows.Markup.INameScope value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetNameScope(class System.Windows.DependencyObject dependencyObject, class System.Windows.Markup.INameScope value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.SetNameScope(System.Windows.DependencyObject,System.Windows.Markup.INameScope)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetNameScope(System::Windows::DependencyObject ^ dependencyObject, System::Windows::Markup::INameScope ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Markup.INameScope" />
      </Parameters>
      <Docs>
        <param name="dependencyObject"><span data-ttu-id="a7dba-190">Objeto del que se va a cambiar el ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-190">Object to change XAML namescope for.</span></span></param>
        <param name="value"><span data-ttu-id="a7dba-191">Nuevo ámbito de nombres XAML, que usa una conversión de interfaz.</span><span class="sxs-lookup"><span data-stu-id="a7dba-191">The new XAML namescope, using an interface cast.</span></span></param>
        <summary><span data-ttu-id="a7dba-192">Proporciona el descriptor de acceso set de la propiedad adjunta <see cref="P:System.Windows.NameScope.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-192">Provides the attached property set accessor for the <see cref="P:System.Windows.NameScope.NameScope" /> attached property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-193">El propósito de este método es para que actúe como el `set` descriptor de acceso para el uso de <xref:System.Windows.NameScope.NameScope%2A> como una propiedad adjunta en XAML y proporcionar el descriptor de acceso para realizar la operación equivalente en el código.</span><span class="sxs-lookup"><span data-stu-id="a7dba-193">The purpose of this method is both to act as the `set` accessor for using <xref:System.Windows.NameScope.NameScope%2A> as an attached property in XAML usage, and to provide the accessor for performing the equivalent operation in code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-194"><paramref name="dependencyObject" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-194"><paramref name="dependencyObject" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7dba-195">Devuelve un enumerador que recorre en iteración una colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-195">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="a7dba-196">Enumerador que recorre en iteración una colección.</span><span class="sxs-lookup"><span data-stu-id="a7dba-196">An enumerator that iterates through a collection.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (string key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(string key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.TryGetValue(System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a7dba-197">Clave del valor que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="a7dba-197">The key of the value to get.</span></span></param>
        <param name="value"><span data-ttu-id="a7dba-198">Cuando este método termina de ejecutarse, contiene el valor asociado a la clave especificada si se encuentra la clave; de lo contrario, devuelve un objeto null.</span><span class="sxs-lookup"><span data-stu-id="a7dba-198">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, a null object.</span></span> <span data-ttu-id="a7dba-199">Este parámetro se pasa sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-199">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="a7dba-200">Obtiene el valor asociado a la clave especificada.</span><span class="sxs-lookup"><span data-stu-id="a7dba-200">Gets the value associated with the specified key.</span></span></summary>
        <returns><span data-ttu-id="a7dba-201">Es true si <see cref="T:System.Windows.NameScope" /> contiene una asignación para el nombre proporcionado como <paramref name="key" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-201">true if the <see cref="T:System.Windows.NameScope" /> contains a mapping for the name provided as <paramref name="key" />.</span></span> <span data-ttu-id="a7dba-202">De lo contrario, es false.</span><span class="sxs-lookup"><span data-stu-id="a7dba-202">Otherwise, false.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.NameScope.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.INameScope.UnregisterName(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="a7dba-203">El nombre de la asignación que se debe quitar.</span><span class="sxs-lookup"><span data-stu-id="a7dba-203">The name of the mapping to remove.</span></span></param>
        <summary><span data-ttu-id="a7dba-204">Quita una asignación del objeto de nombre del ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="a7dba-204">Removes a name-object mapping from the XAML namescope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7dba-205">Antes de llamar a este método, puede usar <xref:System.Windows.NameScope.FindName%2A> para determinar si existe una asignación de nombre y objeto específica.</span><span class="sxs-lookup"><span data-stu-id="a7dba-205">Before calling this method, you can use <xref:System.Windows.NameScope.FindName%2A> to determine whether a specific name-object mapping exists.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a7dba-206"><paramref name="name" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="a7dba-206"><paramref name="name" /> was provided as empty string.</span></span>  
  
 <span data-ttu-id="a7dba-207">\- o -</span><span class="sxs-lookup"><span data-stu-id="a7dba-207">\- or -</span></span>  
  
 <span data-ttu-id="a7dba-208">No se registró el valor de <paramref name="name" /> proporcionado.</span><span class="sxs-lookup"><span data-stu-id="a7dba-208"><paramref name="name" /> provided had not been registered.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a7dba-209"><paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-209"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.INameScope" />
        <altmember cref="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;object&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;object&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.NameScope.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::Object ^&gt; ^ Values { System::Collections::Generic::ICollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a7dba-210">Obtiene una colección de los valores del diccionario de <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-210">Gets a collection of the values in the <see cref="T:System.Windows.NameScope" /> dictionary.</span></span></summary>
        <value><span data-ttu-id="a7dba-211">Colección de los valores del diccionario de <see cref="T:System.Windows.NameScope" />.</span><span class="sxs-lookup"><span data-stu-id="a7dba-211">A collection of the values in the <see cref="T:System.Windows.NameScope" /> dictionary.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>