<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24edbfc6ddc2b9854cb84a3649fc8e7689f8b408" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48607839" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsula una aplicación para Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> es una clase que encapsula [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] funcionalidad específica de la aplicación, incluidos los siguientes:  
  
-   **Duración de la aplicación**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Ventana de ámbito de la aplicación, la propiedad y la administración de recursos**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Parámetro de línea de comandos y salir de código procesamiento**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Navegación**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implementa el patrón singleton para proporcionar acceso compartido a su ventana, propiedad y servicios del ámbito de recursos. Por lo tanto, solo una instancia de la <xref:System.Windows.Application> clase se puede crear por <xref:System.AppDomain>.  
  
 Puede implementar un <xref:System.Windows.Application> mediante marcado, marcado y código subyacente o código. Si <xref:System.Windows.Application> se implementa con el marcado, si el marcado o marcado y código subyacente, el archivo de marcado debe estar configurado como un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` elemento.  
  
> [!NOTE]
>  Una aplicación independiente no requiere un <xref:System.Windows.Application> objeto; es posible implementar un personalizado `static` método de punto de entrada (`Main`) que abre una ventana sin necesidad de crear una instancia de <xref:System.Windows.Application>. Sin embargo, [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] requieren un <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo es una aplicación estándar define sólo mediante marcado:  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 El ejemplo siguiente se muestra cómo una aplicación estándar se define utilizando sólo código:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 El ejemplo siguiente muestra cómo una aplicación estándar está definido mediante una combinación de marcado y código subyacente.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>El público <see langword="static" /> (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. Además, el <see cref="M:System.Windows.Application.FindResource(System.Object)" /> y <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> métodos y la <see cref="P:System.Windows.Application.Properties" /> y <see cref="P:System.Windows.Application.Resources" /> propiedades son seguros para subprocesos.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo una instancia de la <xref:System.Windows.Application> clase se puede crear por <xref:System.AppDomain>, para garantizar el acceso compartido a un único conjunto de datos de ventana, propiedad y recursos del ámbito de la aplicación. Por lo tanto, el constructor predeterminado de la <xref:System.Windows.Application> clase detecta si la instancia que se está inicializarla es la primera instancia de un <xref:System.AppDomain>; si no, es un <xref:System.InvalidOperationException> se produce.  
  
 El <xref:System.Windows.Application> objeto actual <xref:System.AppDomain> se expone desde estático <xref:System.Windows.Application.Current%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se crea más de una instancia de la clase <see cref="T:System.Windows.Application" /> por <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una aplicación se convierte en la aplicación en primer plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se activa una aplicación de Windows Presentation Foundation que tiene una o varias ventanas abiertas (se convierte en la aplicación en primer plano) cuando una de las ventanas se activa por primera vez desde que se inició la aplicación o cuando una de las ventanas se activa mientras la aplicación está inactiva: en concreto, la activación se produce cuando:  
  
-   Una aplicación abre su primera ventana.  
  
-   Un usuario cambia a la aplicación mediante el uso de ALT+TAB, o mediante el Administrador de tareas.  
  
-   Un usuario hace clic con el botón de barra de tareas para una de las ventanas en una aplicación.  
  
 Pueden controlar las aplicaciones que necesitan detectar cuándo se activan el <xref:System.Windows.Application.Activated> eventos.  
  
 Después de activa una aplicación en primer lugar, puede estar desactivado y reactivado muchas veces durante su vigencia. Si el estado o comportamiento de una aplicación depende de su estado de activación, puede controlar ambos <xref:System.Windows.Application.Activated> y <xref:System.Windows.Application.Deactivated> de eventos para determinar qué activación de estado.  
  
 Una vez que una aplicación se vuelve activa, <xref:System.Windows.Application.Activated> no se genera otra vez hasta que la aplicación se desactiva, independientemente de cuántas windows dentro de una aplicación se activan mientras la aplicación está activa.  
  
 <xref:System.Windows.Application.Activated> no se desencadena para [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo detectar cuándo una aplicación independiente se activa y desactiva.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Windows.Application" /> para el <see cref="T:System.AppDomain" /> actual.</summary>
        <value>Objeto <see cref="T:System.Windows.Application" /> para el <see cref="T:System.AppDomain" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> es un por-<xref:System.AppDomain> tipo singleton que implementa estático <xref:System.Windows.Application.Current%2A> propiedad para proporcionar acceso compartido a la <xref:System.Windows.Application> instancia actual <xref:System.AppDomain>. Este diseño garantiza que ese estado administrado por <xref:System.Windows.Application>, incluidos los recursos compartidos y el estado, que está disponible en una única ubicación compartida.  
  
 Esta propiedad es segura para subprocesos y está disponible desde cualquier subproceso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una aplicación deja de estar en primer plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación de Windows Presentation Foundation que tiene una o varias ventanas abiertas desactiva (deja de ser la aplicación en primer plano) cuando un usuario hace lo siguiente:  
  
-   Cambia a otra aplicación mediante el uso de ALT+TAB, o mediante el Administrador de tareas.  
  
-   Hace clic con el botón de barra de tareas para una ventana en otra aplicación.  
  
 Las aplicaciones que necesitan para detectar la desactivación puede controlar la <xref:System.Windows.Application.Deactivated> eventos.  
  
 Después de activa una aplicación en primer lugar, puede estar desactivado y reactivado muchas veces durante su vigencia. Si el estado o comportamiento de una aplicación depende de su estado de activación, puede controlar ambos <xref:System.Windows.Application.Deactivated> y <xref:System.Windows.Application.Activated> de eventos para determinar el estado en que lo.  
  
 <xref:System.Windows.Application.Deactivated> no se desencadena para [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo detectar cuándo se desactiva y se activa una aplicación independiente.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una aplicación inicia una excepción que no se controla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, Windows Presentation Foundation detecta las excepciones no controladas, notifica a los usuarios de la excepción de un cuadro de diálogo (desde el que puede notificar la excepción) y una aplicación se cierra automáticamente.  
  
 Sin embargo, si una aplicación necesita realizar el procesamiento de excepciones no controladas personalizado desde una ubicación centralizada, debe controlar <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> se produce por un <xref:System.Windows.Application> para cada excepción controlada por código que se ejecuta en el subproceso de interfaz de usuario principal.  
  
 Si una excepción no se controla en ya sea un fondo de subproceso de interfaz de usuario (un subproceso con su propio <xref:System.Windows.Threading.Dispatcher>) o un subproceso de trabajo en segundo plano (un subproceso sin un <xref:System.Windows.Threading.Dispatcher>), la excepción no se reenvía al subproceso de interfaz de usuario principal. Por lo tanto, <xref:System.Windows.Application.DispatcherUnhandledException> no se genera. En estas circunstancias, necesita escribir código para hacer lo siguiente:  
  
1.  Controlar excepciones en el subproceso en segundo plano.  
  
2.  Enviar esas excepciones en el subproceso de interfaz de usuario principal.  
  
3.  Reiniciar en el subproceso de interfaz de usuario principal sin tener que les permite controlar <xref:System.Windows.Application.DispatcherUnhandledException> a generarse.  
  
 Para obtener más información, consulte el [modelo de subprocesos](~/docs/framework/wpf/advanced/threading-model.md) información general.  
  
 El <xref:System.Windows.Application.DispatcherUnhandledException> controlador de eventos se pasa un <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argumento que contiene información contextual sobre la excepción, incluidos:  
  
-   La excepción (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   El <xref:System.Windows.Threading.Dispatcher> desde que se originó (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Puede usar esta información para determinar si una excepción es recuperable o no. Una excepción recuperable podría ser un <xref:System.IO.FileNotFoundException>, por ejemplo, mientras que una excepción irrecuperable podría ser un <xref:System.StackOverflowException>, por ejemplo.  
  
 Cuando se procesa una excepción no controlada de <xref:System.Windows.Application.DispatcherUnhandledException>, y no desea [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] para seguir procesándolo, deberá establecer el <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> propiedad `true`.  
  
 A diferencia de los otros eventos que <xref:System.Windows.Application> provoca, <xref:System.Windows.Application.DispatcherUnhandledException> no tienen una coincidencia protegido implementación virtual (OnDispatcherUnhandledException). Por lo tanto, las clases que derivan de <xref:System.Windows.Application> siempre se debe registrar un controlador de eventos con <xref:System.Windows.Application.DispatcherUnhandledException> para procesar las excepciones no controladas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo procesar las excepciones no controladas controlando el <xref:System.Windows.Application.DispatcherUnhandledException> eventos.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce justo antes de que se cierre una aplicación y no se puede cancelar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede cerrar una aplicación para cada uno de los siguientes motivos:  
  
-   El <xref:System.Windows.Application.Shutdown%2A> método de la <xref:System.Windows.Application> se denomina objeto, ya sea explícitamente o determinado por la <xref:System.Windows.Application.ShutdownMode%2A> propiedad.  
  
-   El usuario finaliza la sesión o apagar.  
  
 Puede detectar cuando se produce el cierre de la aplicación controlando el <xref:System.Windows.Application.Exit> eventos y realizar cualquier procesamiento adicional según sea necesario.  
  
 También puede controlar <xref:System.Windows.Application.Exit> para examinar o cambiar el código de salida de la aplicación cuando ya no necesite llamar a <xref:System.Windows.Application.Shutdown%2A> explícitamente. El código de salida se expone desde el <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propiedad de la <xref:System.Windows.ExitEventArgs> argumento que se pasa a la <xref:System.Windows.Application.Exit> controlador de eventos. Cuando la aplicación deja de ejecutarse, el código de salida se pasa al sistema operativo para su posterior procesamiento.  
  
 Si la aplicación maneja el <xref:System.Windows.Application.SessionEnding> eventos y posteriormente lo cancela, <xref:System.Windows.Application.Exit> no se genera y la aplicación continúa ejecutándose de acuerdo con el modo de apagado.  
  
 El código de salida se puede establecer desde un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], aunque el valor se omite.  
  
 Para [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> se produce en las siguientes circunstancias:  
  
-   Un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] se navega fuera de ella.  
  
-   En [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], cuando la pestaña que hospeda el [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] está cerrado.  
  
-   Cuando se cierra el explorador.  
  
 En todos los casos, el valor de la <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propiedad se omite.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo:  
  
-   Controlar la <xref:System.Windows.Application.Exit> eventos.  
  
-   Inspeccione y actualice el <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propiedad de la <xref:System.Windows.ExitEventArgs>.  
  
-   Escribir una entrada en el registro de una aplicación en un almacenamiento aislado.  
  
-   Conservar el estado de la aplicación en el almacenamiento aislado.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nombre del recurso que se va a buscar.</param>
        <summary>Busca un recurso de [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], como <see cref="T:System.Windows.Style" /> o <see cref="T:System.Windows.Media.Brush" />, con la clave especificada, y produce una excepción si no se encuentra el recurso solicitado (vea [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Objeto de recurso solicitado. Si no se encuentra el recurso solicitado, se produce la excepción <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> buscará primero en los recursos del ámbito de la aplicación para el recurso especificado. Recursos del ámbito de aplicación administrados por <xref:System.Windows.Application>y se exponen desde los <xref:System.Windows.Application.Resources%2A> propiedad. Si no se encuentra el recurso especificado en el conjunto de recursos del ámbito de la aplicación, <xref:System.Windows.Application.FindResource%2A> luego siguiente busca los recursos del sistema. Los recursos del sistema son recursos de shell definidos por el usuario e incluyen configuraciones de shell, fuentes y colores. Estos se exponen desde los <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, y <xref:System.Windows.SystemParameters> tipos, respectivamente, como propiedades estáticas. Para usar <xref:System.Windows.Application.FindResource%2A> para obtenerlos, estos tipos exponen también propiedades de clave de recurso que están diseñadas para pasarse a <xref:System.Windows.Application.FindResource%2A>; por ejemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Dado que <xref:System.Windows.Application.FindResource%2A> devuelve un objeto, debe convertir el valor devuelto al tipo adecuado si se encuentra el recurso.  
  
> [!IMPORTANT]
>  Si se llama a este método para una clave que no se encuentra, se produce una excepción. Si no desea controlar las excepciones resultantes de llamar a <xref:System.Windows.Application.FindResource%2A>, llame a <xref:System.Windows.Application.TryFindResource%2A> en su lugar; <xref:System.Windows.Application.TryFindResource%2A> devuelve un `null` referencia cuando no se encuentra un recurso solicitado y no produce una excepción.  
  
 Este método es seguro para subprocesos y se puede llamar desde cualquier subproceso.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.Windows.Application.FindResource%2A> para encontrar un recurso y controlar <xref:System.Windows.ResourceReferenceKeyNotFoundException> si no se encuentra el recurso.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">No se encuentra el recurso.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un navegador de la aplicación comienza a navegar hacia un fragmento de contenido, cuando la navegación se produce inmediatamente si el fragmento deseado está en el contenido actual, o bien, una vez cargado el contenido [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] de origen si el fragmento deseado está en otro contenido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">
          <see cref="T:System.Uri" /> relativo que se asigna a un recurso separado.</param>
        <summary>Devuelve una secuencia de recursos para un archivo de datos de contenido ubicado en el <see cref="T:System.Uri" /> especificado. Vea [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (Archivos de datos, contenido y recursos de aplicaciones para WPF).</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" /> que contiene un archivo de datos de contenido ubicado en el <see cref="T:System.Uri" /> especificado. Si no se encuentra el recurso separado, se devuelve el valor null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Uri" /> que se pasa al método <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> es null.</exception>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Uri" /> que se pasa al método <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> es un <see cref="T:System.Uri" /> absoluto.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> que especifica la ubicación para la que se creó una cookie.</param>
        <summary>Recupera una cookie para la ubicación especificada por <see cref="T:System.Uri" />.</summary>
        <returns>Valor de tipo <see cref="T:System.String" /> si la cookie existe; de lo contrario, se produce una excepción <see cref="T:System.ComponentModel.Win32Exception" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Recupera una cookie para el elemento especificado <xref:System.Uri>. Si no se puede recuperar la cookie, un <xref:System.ComponentModel.Win32Exception> se produce. Deberá escribir el código para analizar la cadena de la cookie en una lista de pares nombre/valor.  
  
 Para obtener información general de las cookies en [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], consulte [información general sobre navegación](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">La función <see langword="InternetGetCookie" /> (a la que llama el método <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) provoca un evento de [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] si surge un problema cuando se intenta recuperar la cookie especificada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener la cookie de basados en archivos <see cref="T:System.Uri" />. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para obtener la cookie de un no basados en archivos <see cref="T:System.Uri" />. Enumeración asociada: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">
          <see cref="T:System.Uri" /> que se asigna a un recurso separado en el sitio de origen.</param>
        <summary>Devuelve una secuencia de recursos para un archivo de datos de sitio de origen ubicado en el <see cref="T:System.Uri" /> especificado. Vea [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (Archivos de datos, contenido y recursos de aplicaciones para WPF).</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" /> que contiene una secuencia de recursos para un archivo de datos de sitio de origen ubicado en el <see cref="T:System.Uri" /> especificado. Si no se encuentra el recurso separado, se devuelve el valor <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Uri" /> que se pasa al método <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> es null.</exception>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Uri" /> que se pasa a <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> no es relativo, o bien, es absoluto pero no tiene el formato <c>pack://siteoforigin:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">
          <see cref="T:System.Uri" /> que se asigna a un recurso incrustado.</param>
        <summary>Devuelve una secuencia de recursos para un archivo de datos de recursos ubicado en el <see cref="T:System.Uri" /> especificado. Vea [WPF Application Resource, Content, and Data Files](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) (Archivos de datos, contenido y recursos de aplicaciones para WPF).</summary>
        <returns>
          <see cref="T:System.Windows.Resources.StreamResourceInfo" /> que contiene una secuencia de recursos para un archivo de datos de recursos ubicado en el <see cref="T:System.Uri" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El <see cref="T:System.Uri" /> que se pasa al método <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> es null.</exception>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Uri" /> que se pasa a <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> no es relativo, o bien, es absoluto pero no tiene el formato <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">El <see cref="T:System.Uri" /> que se pasa a <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> no se encuentra.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha cargado y analizado el contenido al que ha navegado un navegador de la aplicación y se ha iniciado su representación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Escuchas de eventos en el contenido de navegar, como el <xref:System.Windows.FrameworkElement.Loaded> eventos en <xref:System.Windows.Controls.Page> antes de acceder a las propiedades del contenido navegar.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carga un archivo [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ubicado en el [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] archivo puede ser un archivo de código de aplicación (configurado como un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento de página) o un archivo de datos de aplicación (un archivo de recursos, el archivo de contenido o el sitio de origen; vea [WPF Application Resource, contenido y los archivos de datos](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">
          <see cref="T:System.Uri" /> que se asigna a un archivo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relativo.</param>
        <summary>Carga un archivo [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ubicado en el [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] especificado y lo convierte en una instancia del objeto especificado por el elemento raíz del archivo [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <returns>Instancia del elemento raíz especificada por el archivo XAML cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe convertir explícitamente el valor devuelto para el mismo tipo que el elemento raíz de la [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] archivo.  
  
 El [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] archivo puede ser un archivo de código de aplicación (configurado como un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento de página) o un archivo de datos de aplicación (un archivo de recursos, el archivo de contenido o el sitio de origen; vea [WPF Application Resource, contenido y los archivos de datos](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> es una [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] absoluta.</exception>
        <exception cref="T:System.Exception">El archivo no es un archivo [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Un objeto del mismo tipo que el elemento raíz del archivo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <param name="resourceLocator">
          <see cref="T:System.Uri" /> que se asigna a un archivo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relativo.</param>
        <summary>Carga un archivo [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] que se encuentra en el [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] especificado y lo convierte en una instancia del objeto especificado por el elemento raíz del archivo [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] archivo puede ser un archivo de código de aplicación (configurado como un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] elemento de página) o un archivo de datos de aplicación (un archivo de recursos, el archivo de contenido o el sitio de origen; vea [WPF Application Resource, contenido y los archivos de datos](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Este método no es seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> es una [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] absoluta.</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> es de un tipo que no coincide con el elemento raíz del archivo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ventana principal de la aplicación.</summary>
        <value>
          <see cref="T:System.Windows.Window" /> que se designa como la ventana principal de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> se establece automáticamente con una referencia al primer <xref:System.Windows.Window> objeto que se creará una instancia en el <xref:System.AppDomain>.  
  
 Puede especificar una ventana principal diferente estableciendo <xref:System.Windows.Application.MainWindow%2A> asignar otro <xref:System.Windows.Application.Windows%2A> de objeto para el <xref:System.Windows.Application.MainWindow%2A> propiedad.  
  
 Si el <xref:System.Windows.Application.ShutdownMode%2A> propiedad de la <xref:System.Windows.Application> objeto se establece en <xref:System.Windows.ShutdownMode.OnMainWindowClose>, cierre la ventana principal hace que la aplicación para que se cierre.  
  
 Es posible establecer el <xref:System.Windows.Application.MainWindow%2A> propiedad desde [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], si la ventana principal de la aplicación no es la ventana que se produce al establecer el <xref:System.Windows.Application.StartupUri%2A> propiedad en [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Las dos limitaciones de la [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] enfoque son:  
  
-   Puede especificar un [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-solo <xref:System.Windows.Window> o un [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-solo <xref:System.Windows.Navigation.NavigationWindow> como la ventana principal.  
  
-   Debe establecer el <xref:System.Windows.UIElement.Visibility%2A> propiedad de la ventana especifique, en caso contrario, no se muestra.  
  
 La referencia al primer <xref:System.Windows.Window> también se agrega el objeto que se creará una instancia como el primer elemento para el <xref:System.Windows.Application.Windows%2A> colección. Si <xref:System.Windows.Application.MainWindow%2A> posteriormente se establece con una referencia a otro <xref:System.Windows.Window>, cambiará la posición del elemento con la referencia a la ventana principal, mientras que el orden de los elementos de <xref:System.Windows.Application.Windows%2A> sigue siendo el mismo. Por lo tanto, siempre use <xref:System.Windows.Application.MainWindow%2A> para hacer referencia a la ventana principal en lugar del primer elemento en <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Si la ventana principal es un <xref:System.Windows.Navigation.NavigationWindow>, y necesita acceso específico a <xref:System.Windows.Navigation.NavigationWindow> miembros, tendrá que convertir el valor de <xref:System.Windows.Application.MainWindow%2A> a <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Esta propiedad solo está disponible desde el subproceso que creó el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo buscar la ventana principal de la aplicación.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 El ejemplo siguiente muestra cómo establecer <xref:System.Windows.Application.MainWindow%2A> mediante [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 El ejemplo siguiente muestra cómo crear una instancia de la <xref:System.Windows.Application.MainWindow%2A> en el código durante el inicio de la aplicación.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" /> se establece desde una aplicación hospedada en un explorador, como las [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha encontrado el contenido al que navega un navegador de la aplicación, aunque no haya terminado de cargarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un navegador de la aplicación solicita una nueva navegación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se genera un error mientras que un navegador de la aplicación navega al contenido solicitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce periódicamente durante una descarga administrada por un navegador de la aplicación para proporcionar información sobre el progreso de la navegación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se llama al método <see langword="StopLoading" /> de un navegador en la aplicación, o bien, cuando un navegador solicita una nueva navegación mientras hay una navegación en curso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navegador sea un <xref:System.Windows.Navigation.NavigationWindow> o <xref:System.Windows.Controls.Frame>.  
  
 Vea <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> genera el evento <xref:System.Windows.Application.Activated>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnActivated%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnActivated%2A> en la clase base si <xref:System.Windows.Application.Activated> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> genera el evento <xref:System.Windows.Application.Deactivated>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnDeactivated%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnDeactivated%2A> en la clase base si <xref:System.Windows.Application.Deactivated> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.ExitEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Exit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> genera el evento <xref:System.Windows.Application.Exit>.  
  
 Un tipo que derive de <xref:System.Windows.Application> puede invalidar el <xref:System.Windows.Application.OnExit%2A> método. El método invalidado debe llamar a <xref:System.Windows.Application.OnExit%2A> en la clase base si <xref:System.Windows.Application.Exit> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.FragmentNavigation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> genera el evento <xref:System.Windows.Application.FragmentNavigation>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnFragmentNavigation%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnFragmentNavigation%2A> en la clase base si <xref:System.Windows.Application.FragmentNavigation> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.LoadCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> genera el evento <xref:System.Windows.Application.LoadCompleted>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnLoadCompleted%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnLoadCompleted%2A> en la clase base si <xref:System.Windows.Application.LoadCompleted> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Navigated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> genera el evento <xref:System.Windows.Application.Navigated>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnNavigated%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnNavigated%2A> en la clase base si <xref:System.Windows.Application.Navigated> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Navigating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> genera el evento <xref:System.Windows.Application.Navigating>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnNavigating%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnNavigating%2A> en la clase base si <xref:System.Windows.Application.Navigating> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.NavigationFailed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> genera el evento <xref:System.Windows.Application.NavigationFailed>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnNavigationFailed%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnNavigationFailed%2A> en la clase base si <xref:System.Windows.Application.NavigationFailed> debe generarse.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.NavigationProgress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> genera el evento <xref:System.Windows.Application.NavigationProgress>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnNavigationProgress%2A>. El método invalidado explícitamente debe llamar a <xref:System.Windows.Application.OnNavigationProgress%2A> en la clase base si <xref:System.Windows.Application.NavigationProgress> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.NavigationStopped" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> genera el evento <xref:System.Windows.Application.NavigationStopped>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnNavigationStopped%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnNavigationStopped%2A> en la clase base si <xref:System.Windows.Application.NavigationStopped> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.SessionEnding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> genera el evento <xref:System.Windows.Application.SessionEnding>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnSessionEnding%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnSessionEnding%2A> en la clase base si <xref:System.Windows.Application.SessionEnding> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Windows.StartupEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Application.Startup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> genera el evento <xref:System.Windows.Application.Startup>.  
  
 Un tipo que derive de <xref:System.Windows.Application> pueden invalidar <xref:System.Windows.Application.OnStartup%2A>. El método invalidado debe llamar a <xref:System.Windows.Application.OnStartup%2A> en la clase base si la <xref:System.Windows.Application.Startup> evento debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de las propiedades del ámbito de la aplicación.</summary>
        <value>
          <see cref="T:System.Collections.IDictionary" /> que contiene las propiedades del ámbito de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> expone un diccionario a través de <xref:System.Windows.Application.Properties%2A> que puede usar para almacenar las propiedades del ámbito de la aplicación. Esto le permite compartir el estado entre todo el código en un <xref:System.AppDomain> de forma segura para subprocesos, sin necesidad de escribir su propio código de estado.  
  
 Las propiedades se almacenan en <xref:System.Windows.Application.Properties%2A> debe convertirse en el tipo devuelto adecuado.  
  
 El <xref:System.Windows.Application.Properties%2A> propiedad es seguro para subprocesos y está disponible desde cualquier subproceso.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo crear y usar una propiedad de ámbito de la aplicación mediante <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Reflection.Assembly" /> que proporciona los [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] de paquete de los recursos de una aplicación de [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</summary>
        <value>Referencia al objeto <see cref="T:System.Reflection.Assembly" /> que proporciona los [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] de paquete de los recursos de una aplicación de [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] recursos se resuelven en tiempo de ejecución con respecto al ensamblado de entrada, que se identifica mediante el valor devuelto desde el <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método.  
  
 El ensamblado de entrada es el ensamblado devuelto por <xref:System.Reflection.Assembly.GetEntryAssembly%2A> y podrían ser las siguientes:  
  
-   El ensamblado ejecutable en el dominio de aplicación predeterminado.  
  
-   El primer ensamblado que se ejecutará al llamar a <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 En los casos siguientes, sin embargo, un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ensamblado no puede obtener una referencia al ensamblado de entrada:  
  
-   Los hosts de aplicación (nativo) no administrada el [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ensamblado.  
  
-   Los hosts de aplicación administrada del [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ensamblado cargándolos en un nuevo dominio de aplicación con un método que no sea <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 En ambos casos, <xref:System.Reflection.Assembly.GetEntryAssembly%2A> devuelve `null`y el [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] recursos del ensamblado no se puede resolver. En estos casos, <xref:System.Windows.Application.ResourceAssembly%2A> puede establecerse sólo una vez, con una referencia al ensamblado que debe usarse para resolver recursos.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> solo puede establecerse una vez porque es improbable que el ensamblado de recursos cambiará después de la [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ensamblado se carga.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> no se puede establecer cuando un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ensamblado puede detectar el ensamblado de entrada, es decir, cuando <xref:System.Reflection.Assembly.GetEntryAssembly%2A> devuelve una referencia a un ensamblado en lugar de `null`.  
  
 Esta propiedad es segura para subprocesos y está disponible desde cualquier subproceso.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> se introdujo en .NET Framework versión 3.5.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Una aplicación de [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] tiene un ensamblado de entrada o ya se ha establecido <see cref="P:System.Windows.Application.ResourceAssembly" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una colección de recursos del ámbito de la aplicación, como estilos y pinceles.</summary>
        <value>Objeto <see cref="T:System.Windows.ResourceDictionary" /> que contiene cero o más recursos del ámbito de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Application.Resources%2A> propiedad se puede usar para compartir recursos entre las ventanas y los elementos de una aplicación. Además, el <xref:System.Windows.Application.Resources%2A> propiedad se incluye en la ruta de acceso de búsqueda de recursos, que se recorre en el orden siguiente:  
  
1.  Elementos  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  Sistema  
  
 Por lo tanto, [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] elementos se pueden enlazar a los recursos del ámbito de la aplicación. Además, si cambian los recursos, el sistema de recursos garantiza que ese elemento de propiedades que están enlazadas a esos recursos se actualizan automáticamente para reflejar el cambio.  
  
 Recursos del ámbito de aplicación proporcionan una manera sencilla para admitir un tema coherente en toda la aplicación. Puede crear fácilmente un tema en [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] utilizando la `Application.Resources` etiqueta. Sin embargo, si la aplicación admite varios temas, que pueden contener un gran número de elementos de tema, podría ser más fácil administrarlos mediante uno <xref:System.Windows.ResourceDictionary> instancia para cada tema. De este modo, se puede aplicar un nuevo tema estableciendo la propiedad de los recursos correspondientes <xref:System.Windows.ResourceDictionary>.  
  
 Existen dos consideraciones al usar <xref:System.Windows.Application.Resources%2A>. Primero, el diccionario *clave* es un objeto, por lo que deberá usar exactamente la misma instancia del objeto al establecer y obtener un valor de propiedad (tenga en cuenta que la clave distingue mayúsculas de minúsculas cuando se usa una cadena). Segundo, el diccionario *valor* es un objeto, por lo que deberá convertir el valor al tipo deseado al obtener un valor de propiedad.  
  
 <xref:System.Windows.Application.Resources%2A> es seguro para subprocesos y está disponible desde cualquier subproceso.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo usar [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] junto con los recursos del ámbito de la aplicación para crear una apariencia visual coherente.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 El ejemplo siguiente muestra cómo establecer un recurso de aplicación en el código y XAML.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 El ejemplo siguiente muestra cómo obtener un recurso de aplicación en el código.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia una aplicación para Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia una aplicación para Windows Presentation Foundation.</summary>
        <returns>Código de salida <see cref="T:System.Int32" /> que se devuelve al sistema cuando la aplicación se cierra. De forma predeterminada, el valor del código de salida es 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> se llama para iniciar un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] aplicación. Si define su <xref:System.Windows.Application> mediante marcado o marcado y código subyacente, <xref:System.Windows.Application.Run%2A> se llamará implícitamente. Sin embargo, si define su <xref:System.Windows.Application> mediante código, necesitará llamar explícitamente a <xref:System.Windows.Application.Run%2A>.  
  
 Cuando <xref:System.Windows.Application.Run%2A> se llama, <xref:System.Windows.Application> adjunta un nuevo <xref:System.Windows.Threading.Dispatcher> instancia para el subproceso de interfaz de usuario. A continuación, el <xref:System.Windows.Threading.Dispatcher> del objeto <xref:System.Windows.Threading.Dispatcher.Run%2A> se llama el método, que inicia un suministro de mensajes para procesar los mensajes de windows. Por último, el <xref:System.Windows.Threading.Dispatcher> de objeto llama el <xref:System.Windows.Application> del objeto la <xref:System.Windows.Application.OnStartup%2A> método para generar el <xref:System.Windows.Application.Startup> eventos. Por lo tanto, el modelo de ejecución de la aplicación ha sido establecido por el tiempo que controla <xref:System.Windows.Application.Startup>, momento en que la aplicación se considera que se esté ejecutando.  
  
 Una aplicación deja de ejecutarse cuando <xref:System.Windows.Application.Shutdown%2A> se denomina; el valor de la <xref:System.Windows.Application.ShutdownMode%2A> propiedad determina cuándo <xref:System.Windows.Application.Shutdown%2A> se llama y, si lleva a cabo automáticamente, o deberá explícitamente llamarlo.  
  
 <xref:System.Windows.Application.Run%2A> se puede llamar solo desde el subproceso que crea el <xref:System.Windows.Application> objeto. Además, <xref:System.Windows.Application.Run%2A> no pueden llamarse desde un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 El ejemplo siguiente muestra una aplicación que utiliza un personalizado <xref:System.Windows.Application> y, por tanto, debe llamar explícitamente <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método <see cref="M:System.Windows.Application.Run" /> desde una aplicación hospedada en el explorador (por ejemplo, una [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">
          <see cref="T:System.Windows.Window" /> que se abre automáticamente cuando se inicia una aplicación.</param>
        <summary>Inicie una aplicación de Windows Presentation Foundation y abre la ventana especificada.</summary>
        <returns>Código de salida <see cref="T:System.Int32" /> que se devuelve al sistema cuando la aplicación se cierra. De forma predeterminada, el valor del código de salida es 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se extiende el <xref:System.Windows.Application.Run%2A> método para abrir la ventana especificada después de una aplicación empieza a ejecutarse.  
  
 Si define un código <xref:System.Windows.Application> que abre una ventana cuando empieza a ejecutarse, llamar explícitamente a <xref:System.Windows.Application.Run%2A>.  
  
 Si crea su <xref:System.Windows.Application> mediante marcado o marcado y código subyacente, puede abrir automáticamente una ventana durante el uso de cualquiera de las técnicas siguientes:  
  
-   Mediante declaración, estableciendo <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Mediante programación, controlando <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una aplicación con un método de punto de entrada estático creado manualmente que crea una instancia de <xref:System.Windows.Application>, antes de llamar a <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método <see cref="M:System.Windows.Application.Run" /> desde una aplicación hospedada en el explorador (por ejemplo, una [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario finaliza la sesión de Windows cerrando sesión o apagando el sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, una aplicación se cierre cuando finalice la sesión de Windows, que se produce cuando un usuario cierra la sesión o se cierra. Cuando esto sucede, Windows solicita cada aplicación abierto cierre. Sin embargo, es posible que una aplicación puede no estar lista para apagar cuando esto ocurre. Por ejemplo, una aplicación puede tener datos que está en un estado incoherente, o en medio de una operación de larga ejecución. En estas situaciones, puede ser deseable para evitar que la sesión de finalización y puede ser más conveniente permitir a los usuarios la opción de decidir si desea permitir que la sesión finalice o no.  
  
 Puede detectar cuándo finaliza una sesión controlando el <xref:System.Windows.Application.SessionEnding> eventos. Si una aplicación necesita evitar que la sesión de finalización, el <xref:System.Windows.SessionEndingCancelEventArgs> argumento que se pasa al controlador de eventos expone el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> que se establece en `true` (el valor predeterminado es `false`).  
  
 Si <xref:System.Windows.Application.SessionEnding> está controlada o se controla sin que se cancele, <xref:System.Windows.Application.Shutdown%2A> se llama y el <xref:System.Windows.Application.Exit> provoca el evento.  
  
 Para obtener más información sobre por qué la sesión está finalizando, una aplicación puede inspeccionar <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, que es uno de los <xref:System.Windows.ReasonSessionEnding> valores (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> y <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> no se genera por las aplicaciones de consola.  
  
 <xref:System.Windows.Application.SessionEnding> se produce solo en el subproceso que crea el <xref:System.Windows.Application> objeto.  
  
 <xref:System.Windows.Application.SessionEnding> no se genera para las aplicaciones de explorador XAML (XBAP).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar el <xref:System.Windows.Application.SessionEnding> evento y permitir que el usuario para cancelarla.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" /> que especifica la ubicación para la que se va a crear la cookie.</param>
        <param name="value">
          <see cref="T:System.String" /> que contiene los datos de la cookie.</param>
        <summary>Crea una cookie para la ubicación especificada por <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una cookie es un dato arbitrario que se pueden almacenar por una aplicación en el equipo cliente durante las sesiones de aplicación (las cookies de sesión) o a través de sesiones de la aplicación (cookies persistentes). Puede crear ambos tipos de cookies mediante una llamada a <xref:System.Windows.Application.SetCookie%2A>.  
  
 Datos de la cookie normalmente adoptan la forma de un par nombre/valor en el formato siguiente:  
  
 `Name=Value`  
  
 Pasar una cadena de este formato para <xref:System.Windows.Application.SetCookie%2A>, junto con el <xref:System.Uri> de la ubicación para el que se debe establecer la cookie (normalmente, el dominio de aplicación).  
  
 Si una cookie es una cookie de sesión o una cookie persistente depende de si la cookie de cadena que se pasa a <xref:System.Windows.Application.SetCookie%2A> incluye una fecha de expiración. La cadena de una cookie de sesión no incluye una fecha de expiración. Hace la cadena de una cookie persistente y debe tener el formato siguiente:  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Las cookies persistentes se almacenan en el actual [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] carpeta de archivos temporales de Internet de la instalación hasta que caduquen, en cuyo caso se eliminan. Puede eliminar una cookie persistente de la aplicación estableciendo su fecha de expiración en un valor de fecha y hora que se encuentra en el pasado.  
  
 Para obtener información general de las cookies en [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], consulte [información general sobre navegación](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">La función <see langword="InternetSetCookie" /> (a la que llama el método <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) provoca un error [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] si surge un problema cuando se intenta crear la cookie especificada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener la cookie de basados en archivos <see cref="T:System.Uri" />. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para obtener la cookie de un no basados en archivos <see cref="T:System.Uri" />. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cierra una aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra una aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Windows.Application.Shutdown%2A> se denomina una aplicación deja de ejecutarse. Puede controlar la <xref:System.Windows.Application.Exit> eventos para detectar cuando una aplicación está a punto de detener la ejecución, para realizar cualquier procesamiento adecuado.  
  
 <xref:System.Windows.Application.Shutdown%2A> se llama implícitamente a Windows Presentation Foundation en las situaciones siguientes:  
  
-   Cuando <xref:System.Windows.Application.ShutdownMode%2A> está establecido en <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Cuando el <xref:System.Windows.Application.ShutdownMode%2A> está establecido en <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Cuando un usuario finaliza una sesión y la <xref:System.Windows.Application.SessionEnding> eventos se no controlado o administra sin la cancelación.  
  
 Una llamada a <xref:System.Windows.Application.Shutdown%2A> explícitamente, la aplicación se cierra correctamente, independientemente de la <xref:System.Windows.Application.ShutdownMode%2A> configuración. Sin embargo, si <xref:System.Windows.Application.ShutdownMode%2A> está establecido en <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, debe llamar a <xref:System.Windows.Application.Shutdown%2A> para cerrar una aplicación.  
  
> [!IMPORTANT]
>  Cuando <xref:System.Windows.Application.Shutdown%2A> es llama, la aplicación se cerrará con independencia de si el <xref:System.Windows.Window.Closing> se cancela el evento de las ventanas abiertas.  
  
 Puede llamar a este método solo desde el subproceso que creó el <xref:System.Windows.Application> objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">permiso usar todas las ventanas y eventos de entrada de usuario sin restricciones. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Código de salida de tipo entero para una aplicación. El valor predeterminado del código de salida es 0.</param>
        <summary>Cierra la aplicación que devuelve al sistema operativo el código de salida especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede controlar la <xref:System.Windows.Application.Exit> eventos para establecer un código de salida. Sin embargo, si se llama explícitamente a <xref:System.Windows.Application.Shutdown%2A>, y controlar <xref:System.Windows.Application.Exit> solo para establecer un código de salida, puede llamar a <xref:System.Windows.Application.Shutdown%2A> en su lugar.  
  
 Puede llamar a este método solo desde el subproceso que creó el <xref:System.Windows.Application> objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">permiso usar todas las ventanas y eventos de entrada de usuario sin restricciones. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la condición que hace que se llame al método <see cref="M:System.Windows.Application.Shutdown" />.</summary>
        <value>Un valor de enumeración <see cref="T:System.Windows.ShutdownMode" />. El valor predeterminado es <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplicaciones de dejan de ejecutarse solo cuando el <xref:System.Windows.Application.Shutdown%2A> se llama al método de la aplicación. Cierre puede producirse de forma implícita o explícita, según lo especificado por el valor de la <xref:System.Windows.Application.ShutdownMode%2A> propiedad.  
  
 Si establece <xref:System.Windows.Application.ShutdownMode%2A> a <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) llama implícitamente <xref:System.Windows.Application.Shutdown%2A> cuando cierra la última ventana en una aplicación, incluso si las ventanas con instancias actualmente se establecen como la ventana principal (consulte <xref:System.Windows.Application.MainWindow%2A>).  
  
 Un <xref:System.Windows.Application.ShutdownMode%2A> de <xref:System.Windows.ShutdownMode.OnMainWindowClose> hace que WPF llamará implícitamente a <xref:System.Windows.Application.Shutdown%2A> cuando el <xref:System.Windows.Application.MainWindow%2A> cierra, incluso si otras ventanas abiertas.  
  
 La duración de algunas aplicaciones no puede depender de cuando la ventana principal o la última ventana se cierra o no puede depender windows en absoluto. Para estos escenarios se debe establecer el <xref:System.Windows.Application.ShutdownMode%2A> propiedad <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, lo que requiere una explícita <xref:System.Windows.Application.Shutdown%2A> llamada de método para detener la aplicación. En caso contrario, la aplicación continúa ejecutándose en segundo plano.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> se puede configurar mediante declaración desde [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] o mediante programación desde el código.  
  
 Esta propiedad solo está disponible desde el subproceso que creó el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo configurar <xref:System.Windows.Application.ShutdownMode%2A> para especificar que una aplicación debe cerrarse explícitamente.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se llama al método <see cref="M:System.Windows.Application.Run" /> del objeto <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación típica de Windows Presentation Foundation puede realizar diversas tareas de inicialización cuando se inicia, incluidas:  
  
-   Parámetros de línea de comandos de procesamiento.  
  
-   Abrir la ventana principal.  
  
-   Inicializar los recursos del ámbito de la aplicación.  
  
-   Inicializar las propiedades del ámbito de la aplicación.  
  
 Puede especificar mediante declaración la ventana principal y los recursos del ámbito de la aplicación mediante [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> y <xref:System.Windows.Application.Resources%2A>, respectivamente). A veces, sin embargo, los recursos o la ventana principal de la aplicación solo se puede determinar mediante programación en tiempo de ejecución. Además, las propiedades de ámbito de la aplicación y los parámetros de línea de comandos pueden utilizarse mediante programación. Se puede realizar la inicialización programática controlando el <xref:System.Windows.Application.Startup> evento, incluidos los siguientes:  
  
-   Adquirir y procesar los parámetros de línea de comandos, que están disponibles en el <xref:System.Windows.StartupEventArgs.Args%2A> propiedad de la <xref:System.Windows.StartupEventArgs> clase que se pasa a la <xref:System.Windows.Application.Startup> controlador de eventos.  
  
-   Inicializar los recursos del ámbito de la aplicación mediante el <xref:System.Windows.Application.Resources%2A> propiedad.  
  
-   Inicializar las propiedades de ámbito de la aplicación mediante el uso de la <xref:System.Windows.Application.Properties%2A> propiedad.  
  
-   Crear una instancia y mostrar ventanas uno (o más).  
  
> [!NOTE]
>  Parámetros de línea de comandos también se pueden adquirir mediante una llamada a estático <xref:System.Environment.GetCommandLineArgs%2A> método de la <xref:System.Environment> objeto. Sin embargo, <xref:System.Environment.GetCommandLineArgs%2A> requiere plena confianza para ejecutarse.  
  
 Si establece <xref:System.Windows.Application.StartupUri%2A> mediante [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], no está disponible desde la ventana principal que se crea el <xref:System.Windows.Application.MainWindow%2A> propiedad o el <xref:System.Windows.Application.Windows%2A> propiedad de la <xref:System.Windows.Application> objeto hasta después de la <xref:System.Windows.Application.Startup> se procesa el evento. Si necesita acceso a la ventana principal durante el inicio, deberá crear manualmente un nuevo objeto de ventana de la <xref:System.Windows.Application.Startup> controlador de eventos.  
  
> [!NOTE]
>  Si la aplicación usa <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> para especificar una directiva de credenciales, deberá establecer <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> después <xref:System.Windows.Application.Startup> relieve; en caso contrario, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] lo establece en una directiva interna predeterminada directamente después de la <xref:System.Windows.Application.Startup> ha generado el evento.  
  
 Los argumentos de línea de comandos que se pasan a la <xref:System.Windows.Application.Startup> controlador de eventos no son los mismos que los [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] consultar los parámetros de cadena que se pasan a un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo adquirir y procesar las opciones de línea de comandos desde una aplicación independiente. Si el **/StartMinimized** se proporcionó el parámetro de línea de comandos, la aplicación abre la ventana principal en un estado minimizado.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] no se puede recuperar y procesar los argumentos de línea de comandos porque se inician con [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] implementación (consulte [implementar una aplicación de WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). En cambio, pueden recuperar y procesar los parámetros de las cadenas de consulta de las direcciones URL que se usan para iniciarlas.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una IU que se muestra automáticamente al iniciar una aplicación.</summary>
        <value>Un <see cref="T:System.Uri" /> que hace referencia a la interfaz de usuario que se abre automáticamente cuando se inicia una aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar <xref:System.Windows.Application.StartupUri%2A> para cargar automáticamente un recurso de interfaz de usuario cuando se inicia una aplicación.  
  
 La tabla siguiente muestran los tipos de recursos de la interfaz de usuario que se pueden cargar el tipo de ventana que se abren y el tipo de aplicación que se pueden establecer estos recursos como el <xref:System.Windows.Application.StartupUri%2A>.  
  
|Tipo|Ventana|Tipo de aplicación|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Solo independiente|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Solo independiente|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Independientes y hospedadas en el explorador|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Independientes y hospedadas en el explorador|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Independientes y hospedadas en el explorador|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Independientes y hospedadas en el explorador|  
  
 Normalmente, se establece la <xref:System.Windows.Application.StartupUri%2A> forma declarativa en propiedad [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Sin embargo, puede establecer <xref:System.Windows.Application.StartupUri%2A> mediante programación, como un <xref:System.Windows.Application.Startup> controlador de eventos, lo que resulta útil si para las aplicaciones que solo se pueden cargar los recursos de la interfaz de usuario necesarios en tiempo de ejecución. Por ejemplo, una aplicación podría esperar hasta que el tiempo de ejecución para cargar sus recursos si el nombre del recurso de interfaz de usuario se almacena en un archivo de configuración.  
  
 Si se establece <xref:System.Windows.Application.StartupUri%2A> de forma declarativa o mediante programación, el recurso de interfaz de usuario correspondiente no está cargado hasta después de la <xref:System.Windows.Application.Startup> controla el evento. Por lo tanto, no tendrá acceso a la ventana resultante desde el <xref:System.Windows.Application.Windows%2A> propiedad o el <xref:System.Windows.Application.MainWindow%2A> propiedad al control <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <see cref="P:System.Windows.Application.StartupUri" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad de ambiente solicitada.</param>
        <summary>Consulta si la propiedad de ambiente especificada está disponible en el ámbito actual.</summary>
        <returns>Es <see langword="true" /> si la propiedad de ambiente solicitada está disponible; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Windows.Application> se convierte en una interfaz <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nombre del recurso que se va a buscar.</param>
        <summary>Busca el recurso especificado.</summary>
        <returns>Objeto de recurso solicitado. Si no se encuentra el recurso solicitado, se devuelve una referencia nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> buscará primero en los recursos del ámbito de la aplicación para el recurso especificado. Recursos del ámbito de aplicación administrados por <xref:System.Windows.Application>y se exponen desde los <xref:System.Windows.Application.Resources%2A> propiedad. Si no se encuentra el recurso especificado en el conjunto de recursos del ámbito de la aplicación, <xref:System.Windows.Application.TryFindResource%2A> luego siguiente busca los recursos del sistema. Los recursos del sistema son recursos de shell definidos por el usuario e incluyen configuraciones de shell, fuentes y colores. Estos se exponen desde los <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, y <xref:System.Windows.SystemParameters> tipos, respectivamente, como propiedades estáticas. Para usar <xref:System.Windows.Application.TryFindResource%2A> para obtenerlos, estos tipos exponen también propiedades de clave de recurso que están diseñadas para pasarse a <xref:System.Windows.Application.TryFindResource%2A>; por ejemplo, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Dado que <xref:System.Windows.Application.TryFindResource%2A> devuelve un objeto, debe convertir el valor devuelto al tipo adecuado si se encuentra el recurso.  
  
 Este método es seguro para subprocesos y se puede llamar desde cualquier subproceso.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.Windows.Application.TryFindResource%2A> para adquirir un recurso.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las ventanas con instancias de una aplicación.</summary>
        <value>
          <see cref="T:System.Windows.WindowCollection" /> que contiene las referencias a todos los objetos de ventana en el <see cref="T:System.AppDomain" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Window> referencia se agrega automáticamente a <xref:System.Windows.Application.Windows%2A> en cuanto se crea una instancia de una ventana en la [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] subproceso; de windows que se crean de forma no se agregan los subprocesos de trabajo. Un <xref:System.Windows.Window> referencia se quita automáticamente después de su <xref:System.Windows.Window.Closing> se ha controlado el evento y antes de su <xref:System.Windows.Window.Closed> provoca el evento.  
  
 De forma predeterminada, el primer elemento agregado a la <xref:System.Windows.Application.Windows%2A> propiedad pasa a ser la <xref:System.Windows.Application.MainWindow%2A>.  
  
 Esta propiedad solo está disponible desde el subproceso que creó el <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo enumerar los <xref:System.Windows.Application.Windows%2A> propiedad para crear un menú de Windows de nivel superior, que es común a [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] aplicaciones como [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], o como aplicaciones de interfaz de único documento (SDI) de varias instancias [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>