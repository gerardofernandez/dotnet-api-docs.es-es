<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214110" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="25580-101">Define un objeto que tiene un estado modificable y un estado de solo lectura (inmovilizado).</span><span class="sxs-lookup"><span data-stu-id="25580-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span></span> <span data-ttu-id="25580-102">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> proporcionan una notificación de cambios detallada, puede hacerse inmutables y pueden clonarse a sí mismas.</span><span class="sxs-lookup"><span data-stu-id="25580-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-103">La <xref:System.Windows.Freezable> clase proporciona características especiales que pueden ayudar a mejoran el rendimiento de la aplicación cuando se usan los objetos que son costosos de modificar o copiar.</span><span class="sxs-lookup"><span data-stu-id="25580-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="25580-104">Ejemplos de <xref:System.Windows.Freezable> objetos incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="25580-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="25580-105">Derivan de Freezable</span><span class="sxs-lookup"><span data-stu-id="25580-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="25580-106">Una clase que derive de <xref:System.Windows.Freezable> incluye las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="25580-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="25580-107">Estados especiales: un estado de sólo lectura (inmovilizado) y un estado de escritura.</span><span class="sxs-lookup"><span data-stu-id="25580-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="25580-108">Seguridad para subprocesos: inmovilizado <xref:System.Windows.Freezable> objeto se puede compartir entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="25580-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="25580-109">Detallada de la notificación de cambio: a diferencia de otras <xref:System.Windows.DependencyObject> objetos, un <xref:System.Windows.Freezable> objeto proporciona notificaciones de cambios cuando cambian los valores de la subpropiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="25580-110">Clonación fácil: la clase Freezable ya ha implementado varios métodos que generan clones perfectos.</span><span class="sxs-lookup"><span data-stu-id="25580-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="25580-111">Para obtener información sobre el uso y crear su propio <xref:System.Windows.Freezable> objetos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="25580-112">Todos los miembros públicos <see langword="static" /> miembros de este tipo son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="25580-112">Any public <see langword="static" /> members of this type are thread safe.</span></span> <span data-ttu-id="25580-113">No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="25580-113">Any instance members are not guaranteed to be thread safe.</span></span>  
  
<span data-ttu-id="25580-114">Cuando el <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> objeto puede tener acceso solo desde el subproceso donde se creó.</span><span class="sxs-lookup"><span data-stu-id="25580-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span></span> <span data-ttu-id="25580-115">Al intentar acceder a él desde otro subproceso se inicia un <see cref="T:System.InvalidOperationException" />.</span><span class="sxs-lookup"><span data-stu-id="25580-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span></span> <span data-ttu-id="25580-116">El <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> y <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> métodos proporcionan soporte técnico para el cálculo de referencias en el subproceso correcto.</span><span class="sxs-lookup"><span data-stu-id="25580-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span></span>  
  
<span data-ttu-id="25580-117">Cuando sus <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objetos son de subprocesamiento libre.</span><span class="sxs-lookup"><span data-stu-id="25580-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span></span>  <span data-ttu-id="25580-118">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-119">Inicializa una nueva instancia de una clase <see cref="T:System.Windows.Freezable" /> derivada.</span><span class="sxs-lookup"><span data-stu-id="25580-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-120">Éste es el constructor de accesibilidad protegida de una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="25580-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25580-121">Obtiene un valor que indica si el objeto se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-121">Gets a value that indicates whether the object can be made unmodifiable.</span></span></summary>
        <value><span data-ttu-id="25580-122"><see langword="true" /> si el objeto actual se puede convertir en no modificable o ya lo es; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="25580-122"><see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-123">Implementación de este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método con <paramref name="isChecking" /> establecido en <see langword="true" /> para determinar si un <see cref="T:System.Windows.Freezable" /> puede se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-123">This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span></span> <span data-ttu-id="25580-124">Para modificar el comportamiento de esta propiedad en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</span><span class="sxs-lookup"><span data-stu-id="25580-124">To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25580-125">Se produce cuando se modifican la clase <see cref="T:System.Windows.Freezable" /> o un objeto que la contiene.</span><span class="sxs-lookup"><span data-stu-id="25580-125">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-126">Si intenta agregar o quitar controladores de eventos cuando el objeto actual no es modificable (cuando la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true`), se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="25580-126">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-127">Crea un clon modificable del elemento <see cref="T:System.Windows.Freezable" /> y hace copias en profundidad de los valores del objeto.</span><span class="sxs-lookup"><span data-stu-id="25580-127">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span></span> <span data-ttu-id="25580-128">Cuando se copian las propiedades de dependencia del objeto, este método copia las expresiones (que puede que ya no se resuelvan), pero no copia las animaciones ni sus valores actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-128">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span></span></summary>
        <returns><span data-ttu-id="25580-129">Clon modificable del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="25580-129">A modifiable clone of the current object.</span></span> <span data-ttu-id="25580-130">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." />.</span><span class="sxs-lookup"><span data-stu-id="25580-130">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-131">El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados).</span><span class="sxs-lookup"><span data-stu-id="25580-131">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="25580-132">El clon es realmente una copia en profundidad del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="25580-132">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="25580-133">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="25580-133">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="25580-134">Acción</span><span class="sxs-lookup"><span data-stu-id="25580-134">Action</span></span>|<span data-ttu-id="25580-135">Comportamiento del método Clone</span><span class="sxs-lookup"><span data-stu-id="25580-135">Clone method behavior</span></span>|<span data-ttu-id="25580-136">Comportamiento del método CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="25580-136">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="25580-137">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="25580-137">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="25580-138">La expresión se copia, pero podría no resolverse.</span><span class="sxs-lookup"><span data-stu-id="25580-138">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="25580-139">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-139">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="25580-140">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="25580-140">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="25580-141">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="25580-141">Copying an animated dependency property</span></span>|<span data-ttu-id="25580-142">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-142">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="25580-143">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-143">Animations are not copied.</span></span>|<span data-ttu-id="25580-144">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="25580-144">The property's current animated value is copied.</span></span> <span data-ttu-id="25580-145">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-145">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="25580-146">Tenga en cuenta que no se copian las propiedades sin establecer.</span><span class="sxs-lookup"><span data-stu-id="25580-146">Note that unset properties are not copied.</span></span> <span data-ttu-id="25580-147">Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-147">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="25580-148">Mover un objeto inmovilizable entre subprocesos</span><span class="sxs-lookup"><span data-stu-id="25580-148">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="25580-149">Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="25580-149">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="25580-150">En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante una llamada a su <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-150">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="25580-151">Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y realice un local <xref:System.Windows.Freezable.Clone%2A> que puede tener acceso.</span><span class="sxs-lookup"><span data-stu-id="25580-151">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-152">Este método usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> para generar el clon.</span><span class="sxs-lookup"><span data-stu-id="25580-152">This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone.</span></span> <span data-ttu-id="25580-153">Para modificar el comportamiento de este método en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> método.</span><span class="sxs-lookup"><span data-stu-id="25580-153">To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="25580-154">Objeto que se va a clonar.</span><span class="sxs-lookup"><span data-stu-id="25580-154">The object to clone.</span></span></param>
        <summary><span data-ttu-id="25580-155">Convierte la instancia en un clon (copia en profundidad) de la clase <see cref="T:System.Windows.Freezable" /> especificada con valores de propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-155">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-156">Este método es invocado por el <xref:System.Windows.Freezable.Clone%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="25580-156">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="25580-157">Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.Clone%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="25580-157">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-158">Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método.</span><span class="sxs-lookup"><span data-stu-id="25580-158">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="25580-159">Razones para invalidar incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="25580-159">Reasons to override include the following:</span></span> 
<span data-ttu-id="25580-160">-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-160">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="25580-161">-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span><span class="sxs-lookup"><span data-stu-id="25580-161">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="25580-162">Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.</span><span class="sxs-lookup"><span data-stu-id="25580-162">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="25580-163">Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</span><span class="sxs-lookup"><span data-stu-id="25580-163">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="25580-164">Es fundamental que todas las implementaciones de llamar a la implementación base de este método.</span><span class="sxs-lookup"><span data-stu-id="25580-164">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="25580-165">Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="25580-165">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="25580-166">La implementación predeterminada crea copias en profundidad de todas las propiedades de escritura, establecidas localmente, incluidas las expresiones internas.</span><span class="sxs-lookup"><span data-stu-id="25580-166">The default implementation makes deep copies of all writable, locally set properties, including internal expressions.</span></span>  
  
<span data-ttu-id="25580-167">Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero no se resuelvan.</span><span class="sxs-lookup"><span data-stu-id="25580-167">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve.</span></span> <span data-ttu-id="25580-168">Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-168">For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="25580-169">Si el objeto tiene propiedades de dependencia animadas, se copia el valor base (no animados) de esas propiedades.</span><span class="sxs-lookup"><span data-stu-id="25580-169">If the object has animated dependency properties, the base (non-animated) value of those properties is copied.</span></span> <span data-ttu-id="25580-170">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-170">Animations are not copied.</span></span>  
  
<span data-ttu-id="25580-171">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-171">Note that unset properties are not copied, nor are read-only properties.</span></span> <span data-ttu-id="25580-172">Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-172">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
<span data-ttu-id="25580-173">En la lista siguiente se resume el comportamiento esperado para este método:</span><span class="sxs-lookup"><span data-stu-id="25580-173">The following list summarizes the expected behavior for this method:</span></span> 
<span data-ttu-id="25580-174">-La copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.</span><span class="sxs-lookup"><span data-stu-id="25580-174">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span></span>  
  
<span data-ttu-id="25580-175">-No se copian las propiedades anular y de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-175">-   Unset and read-only properties are not copied.</span></span>  
  
<span data-ttu-id="25580-176">-Las expresiones se copian.</span><span class="sxs-lookup"><span data-stu-id="25580-176">-   Expressions are copied.</span></span>  
  
<span data-ttu-id="25580-177">-Ninguno de estos subobjetos se inmoviliza al crearlos.</span><span class="sxs-lookup"><span data-stu-id="25580-177">-   None of these sub-objects are frozen on creation.</span></span>  
  
<span data-ttu-id="25580-178">-No se inmovilice la copia de sí mismo.</span><span class="sxs-lookup"><span data-stu-id="25580-178">-   The copy itself is not frozen.</span></span>  
  
<span data-ttu-id="25580-179">-Las animaciones no se copian.</span><span class="sxs-lookup"><span data-stu-id="25580-179">-   Animations are not copied.</span></span>  
  
<span data-ttu-id="25580-180">-Solo valores de base de propiedad son copiados, no animado los valores actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-180">-   Only property base values are copied, not current animated values.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-181">Crea un clon modificable (copia en profundidad) de <see cref="T:System.Windows.Freezable" /> con sus valores actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-181">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span></span></summary>
        <returns><span data-ttu-id="25580-182">Clon modificable del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="25580-182">A modifiable clone of the current object.</span></span> <span data-ttu-id="25580-183">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." />.</span><span class="sxs-lookup"><span data-stu-id="25580-183">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-184">El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados).</span><span class="sxs-lookup"><span data-stu-id="25580-184">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="25580-185">El clon es realmente una copia en profundidad del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="25580-185">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="25580-186">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="25580-186">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="25580-187">Acción</span><span class="sxs-lookup"><span data-stu-id="25580-187">Action</span></span>|<span data-ttu-id="25580-188">Comportamiento del método Clone</span><span class="sxs-lookup"><span data-stu-id="25580-188">Clone method behavior</span></span>|<span data-ttu-id="25580-189">Comportamiento del método CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="25580-189">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="25580-190">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="25580-190">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="25580-191">La expresión se copia, pero podría no resolverse.</span><span class="sxs-lookup"><span data-stu-id="25580-191">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="25580-192">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-192">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="25580-193">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="25580-193">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="25580-194">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="25580-194">Copying an animated dependency property</span></span>|<span data-ttu-id="25580-195">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-195">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="25580-196">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-196">Animations are not copied.</span></span>|<span data-ttu-id="25580-197">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="25580-197">The property's current animated value is copied.</span></span> <span data-ttu-id="25580-198">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-198">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="25580-199">Tenga en cuenta que no se copian las propiedades sin establecer.</span><span class="sxs-lookup"><span data-stu-id="25580-199">Note that unset properties are not copied.</span></span> <span data-ttu-id="25580-200">Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-200">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="25580-201">Mover un objeto inmovilizable entre subprocesos</span><span class="sxs-lookup"><span data-stu-id="25580-201">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="25580-202">Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="25580-202">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="25580-203">En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante el uso de su <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-203">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="25580-204">Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y crear un clon local que puede tener acceso.</span><span class="sxs-lookup"><span data-stu-id="25580-204">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-205">Este método usa la <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> método para generar el clon; <see cref="T:System.Windows.Freezable" /> implementadores que invalidarán <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> debe asegurarse de que no se inmoviliza la copia en la creación.</span><span class="sxs-lookup"><span data-stu-id="25580-205">This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="25580-206"><see cref="T:System.Windows.Freezable" /> que se va a clonar.</span><span class="sxs-lookup"><span data-stu-id="25580-206">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span></span></param>
        <summary><span data-ttu-id="25580-207">Convierte esta instancia en un clon modificable (copia en profundidad) del <see cref="T:System.Windows.Freezable" /> especificado mediante los valores de propiedad actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-207">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-208">Este método es invocado por el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="25580-208">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="25580-209">Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.CloneCurrentValue%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="25580-209">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-210">Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método.</span><span class="sxs-lookup"><span data-stu-id="25580-210">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="25580-211">Razones para invalidar incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="25580-211">Reasons to override include the following:</span></span> 
<span data-ttu-id="25580-212">-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-212">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="25580-213">-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span><span class="sxs-lookup"><span data-stu-id="25580-213">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="25580-214">Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.</span><span class="sxs-lookup"><span data-stu-id="25580-214">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="25580-215">Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.</span><span class="sxs-lookup"><span data-stu-id="25580-215">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="25580-216">Es fundamental que todas las implementaciones de llamar a la implementación base de este método.</span><span class="sxs-lookup"><span data-stu-id="25580-216">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="25580-217">Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="25580-217">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="25580-218">La implementación predeterminada crea copias en profundidad de todas las propiedades establecidas localmente, puede escribir.</span><span class="sxs-lookup"><span data-stu-id="25580-218">The default implementation makes deep copies of all writable, locally set properties.</span></span> <span data-ttu-id="25580-219">Si el objeto contiene las propiedades de dependencia con expresiones (por ejemplo, un enlace de datos), se copia el valor actual de la expresión pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="25580-219">If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.</span></span>  
  
<span data-ttu-id="25580-220">Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.</span><span class="sxs-lookup"><span data-stu-id="25580-220">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span></span>  
  
<span data-ttu-id="25580-221">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-221">Note that unset properties are not copied, nor are read-only properties.</span></span> <span data-ttu-id="25580-222">Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-222">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
<span data-ttu-id="25580-223">En la lista siguiente se resume el comportamiento esperado para este método.</span><span class="sxs-lookup"><span data-stu-id="25580-223">The following list summarizes the expected behavior for this method.</span></span>  
  
<span data-ttu-id="25580-224">-La copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.</span><span class="sxs-lookup"><span data-stu-id="25580-224">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span></span>  
  
<span data-ttu-id="25580-225">-No se copian las propiedades anular y de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-225">-   Unset and read-only properties are not copied.</span></span>  
  
<span data-ttu-id="25580-226">-Si una propiedad está animada, se copia su valor actual, pero la animación propiamente dicha no está.</span><span class="sxs-lookup"><span data-stu-id="25580-226">-   If a property is animated, its current value is copied, but the animation itself is not.</span></span>  
  
<span data-ttu-id="25580-227">-Ninguno de estos subobjetos se inmoviliza al crearlos.</span><span class="sxs-lookup"><span data-stu-id="25580-227">-   None of these sub-objects are frozen on creation.</span></span>  
  
<span data-ttu-id="25580-228">-No se inmovilice la copia de sí mismo.</span><span class="sxs-lookup"><span data-stu-id="25580-228">-   The copy itself is not frozen.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-229">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Freezable" />.</span><span class="sxs-lookup"><span data-stu-id="25580-229">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span></span></summary>
        <returns><span data-ttu-id="25580-230">La nueva instancia.</span><span class="sxs-lookup"><span data-stu-id="25580-230">The new instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-231">Se trata de un método protegido y las implementaciones específicas de objetos reales para el comportamiento dependen de la implementación de invalidación de la <xref:System.Windows.Freezable.CreateInstanceCore%2A> método, que llama internamente a este método.</span><span class="sxs-lookup"><span data-stu-id="25580-231">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-232">Cuando se implementa en una clase derivada, crea una nueva instancia de la clase <see cref="T:System.Windows.Freezable" /> derivada.</span><span class="sxs-lookup"><span data-stu-id="25580-232">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span></span></summary>
        <returns><span data-ttu-id="25580-233">La nueva instancia.</span><span class="sxs-lookup"><span data-stu-id="25580-233">The new instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-234">No llame a este método directamente (excepto cuando base la llamada en una implementación).</span><span class="sxs-lookup"><span data-stu-id="25580-234">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="25580-235">Este método se llama internamente en el <xref:System.Windows.Freezable.CreateInstance%2A> método cada vez que una nueva instancia de la <xref:System.Windows.Freezable> se crea.</span><span class="sxs-lookup"><span data-stu-id="25580-235">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="25580-236">El ejemplo siguiente muestra una implementación típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span><span class="sxs-lookup"><span data-stu-id="25580-236">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-237">Cada <see cref="T:System.Windows.Freezable" /> clase derivada debe implementar este método.</span><span class="sxs-lookup"><span data-stu-id="25580-237">Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method.</span></span> <span data-ttu-id="25580-238">Una implementación típica consiste simplemente en llamar al constructor predeterminado y devolver el resultado.</span><span class="sxs-lookup"><span data-stu-id="25580-238">A typical implementation is to simply call the default constructor and return the result.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="25580-239">Convierte un objeto <see cref="T:System.Windows.Freezable" /> en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />, prueba si un objeto <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-239">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-240">Convierte el objeto actual en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="25580-240">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-241">Para evitar la posibilidad de un <xref:System.InvalidOperationException> al llamar a este método, compruebe el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad para determinar si el <xref:System.Windows.Freezable> puede convertir en no modificable antes de llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="25580-241">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25580-242"><see cref="T:System.Windows.Freezable" /> no se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-242">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-243">Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-243">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span></span> <span data-ttu-id="25580-244">Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</span><span class="sxs-lookup"><span data-stu-id="25580-244">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable"><span data-ttu-id="25580-245">Objeto que se va a comprobar o a convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-245">The object to check or make unmodifiable.</span></span> <span data-ttu-id="25580-246">Si el valor de <paramref name="isChecking" /> es <see langword="true" />, se comprueba el objeto para determinar si se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-246">If <paramref name="isChecking" /> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span></span> <span data-ttu-id="25580-247">Si el valor de <paramref name="isChecking" /> es <see langword="false" />, el objeto se convierte en no modificable, si es posible.</span><span class="sxs-lookup"><span data-stu-id="25580-247">If <paramref name="isChecking" /> is <see langword="false" />, the object is made unmodifiable, if possible.</span></span></param>
        <param name="isChecking"><span data-ttu-id="25580-248">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</span><span class="sxs-lookup"><span data-stu-id="25580-248"><see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span></span></param>
        <summary><span data-ttu-id="25580-249">Si el valor del parámetro <paramref name="isChecking" /> es <see langword="true" />, este método indica si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-249">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span></span> <span data-ttu-id="25580-250">Si el valor del parámetro <paramref name="isChecking" /> es <see langword="false" />, este método intenta convertir la clase <see cref="T:System.Windows.Freezable" /> especificada en no modificable e indica si la operación se realiza correctamente.</span><span class="sxs-lookup"><span data-stu-id="25580-250">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="25580-251">Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-251">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span> <span data-ttu-id="25580-252">Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-252">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-253">No llame a este método, a menos que se va a derivar de <xref:System.Windows.Freezable> e invalidar la <xref:System.Windows.Freezable.FreezeCore%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-253">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="25580-254">Este método puede usarse en el <xref:System.Windows.Freezable.FreezeCore%2A> método inmovilizar los miembros de datos de clase son por sí mismos <xref:System.Windows.Freezable> objetos.</span><span class="sxs-lookup"><span data-stu-id="25580-254">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="25580-255">Lo bueno es volver a llamar a este método en un <xref:System.Windows.Freezable> objeto que ya está inmovilizado (no modificable).</span><span class="sxs-lookup"><span data-stu-id="25580-255">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25580-256">Cuando el valor de <paramref name="isChecking" /> es <see langword="false" />, el intento para convertir <paramref name="freezable" /> en no modificable no dio resultado; el estado del objeto es desconocido puede estar parcialmente inmovilizado.</span><span class="sxs-lookup"><span data-stu-id="25580-256">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-257">Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-257">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span></span> <span data-ttu-id="25580-258">Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</span><span class="sxs-lookup"><span data-stu-id="25580-258">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><span data-ttu-id="25580-259">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</span><span class="sxs-lookup"><span data-stu-id="25580-259"><see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span></span></param>
        <summary><span data-ttu-id="25580-260">Convierte el objeto <see cref="T:System.Windows.Freezable" /> en no modificable o prueba si se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-260">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span></span></summary>
        <returns><span data-ttu-id="25580-261">Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-261">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span> <span data-ttu-id="25580-262">Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</span><span class="sxs-lookup"><span data-stu-id="25580-262">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-263">No llame a este método directamente (excepto cuando base la llamada en una implementación).</span><span class="sxs-lookup"><span data-stu-id="25580-263">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="25580-264">Este método se llama internamente en el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad (con `isChecking` igual a `true`) y el <xref:System.Windows.Freezable.Freeze%2A> método (con `isChecking` igual a `false`).</span><span class="sxs-lookup"><span data-stu-id="25580-264">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-265">
            <see cref="T:System.Windows.Freezable" /> los implementadores deben invalidar este método cuando la clase contiene los datos que no se almacenan utilizando las propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-265">
            <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.</span></span>  
  
<span data-ttu-id="25580-266">Una implementación típica podría llamar a la base y luego llame al estático <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> método en todos los <see cref="T:System.Windows.Freezable" /> las propiedades que contiene la clase, devolver con tipo <see langword="true" /> sólo si todas las propiedades estén inmovilizadas (o se ha inmovilizado podría, en el caso de especificar <see langword="true" /> para <paramref name="isChecking" />).</span><span class="sxs-lookup"><span data-stu-id="25580-266">A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-267">Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" />, con los valores de propiedades base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-267">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span></span> <span data-ttu-id="25580-268">Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</span><span class="sxs-lookup"><span data-stu-id="25580-268">Because the copy is frozen, any frozen sub-objects are copied by reference.</span></span></summary>
        <returns><span data-ttu-id="25580-269">Copia inmovilizada de <see cref="T:System.Windows.Freezable" />.</span><span class="sxs-lookup"><span data-stu-id="25580-269">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="25580-270">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="25580-270">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-271">Debe comprobar la <xref:System.Windows.Freezable.CanFreeze%2A> propiedad antes de llamar a este método para comprobar que el <xref:System.Windows.Freezable> se puede inmovilizar.</span><span class="sxs-lookup"><span data-stu-id="25580-271">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="25580-272">Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.Clone%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-272">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="25580-273">El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.</span><span class="sxs-lookup"><span data-stu-id="25580-273">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="25580-274">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="25580-274">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="25580-275">Acción</span><span class="sxs-lookup"><span data-stu-id="25580-275">Action</span></span>|<span data-ttu-id="25580-276">Comportamiento del método GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="25580-276">GetAsFrozen method behavior</span></span>|<span data-ttu-id="25580-277">Comportamiento del método GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="25580-277">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="25580-278">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="25580-278">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="25580-279">El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-279">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="25580-280">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="25580-280">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="25580-281">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="25580-281">Copying an animated dependency property</span></span>|<span data-ttu-id="25580-282">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-282">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="25580-283">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-283">Animations are not copied.</span></span>|<span data-ttu-id="25580-284">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="25580-284">The property's current animated value is copied.</span></span> <span data-ttu-id="25580-285">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-285">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="25580-286">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-286">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="25580-287">Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.Clone%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-287">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25580-288">No se puede inmovilizar <see cref="T:System.Windows.Freezable" /> porque contiene expresiones o propiedades animadas.</span><span class="sxs-lookup"><span data-stu-id="25580-288">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-289">Este método usa virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</span><span class="sxs-lookup"><span data-stu-id="25580-289">This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="25580-290">Instancia que se va a copiar.</span><span class="sxs-lookup"><span data-stu-id="25580-290">The instance to copy.</span></span></param>
        <summary><span data-ttu-id="25580-291">Convierte la instancia en un clon inmovilizado de la clase <see cref="T:System.Windows.Freezable" /> especificada con los valores de propiedades base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-291">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-292">Este método es invocado por el <xref:System.Windows.Freezable.GetAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="25580-292">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="25580-293">Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetAsFrozen%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="25580-293">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-294">Si deriva de <see cref="T:System.Windows.Freezable" /> deberá reemplazar este método.</span><span class="sxs-lookup"><span data-stu-id="25580-294">If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method.</span></span> <span data-ttu-id="25580-295">Razones para invalidar incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="25580-295">Reasons to override include the following:</span></span> 
<span data-ttu-id="25580-296">-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-296">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="25580-297">-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span><span class="sxs-lookup"><span data-stu-id="25580-297">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="25580-298">Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.</span><span class="sxs-lookup"><span data-stu-id="25580-298">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="25580-299">Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.</span><span class="sxs-lookup"><span data-stu-id="25580-299">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="25580-300">Es fundamental que todas las implementaciones de llamar a la implementación base de este método.</span><span class="sxs-lookup"><span data-stu-id="25580-300">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="25580-301">Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="25580-301">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="25580-302">La implementación predeterminada crea copias en profundidad de cualquier Freezable no inmovilizados y superficiales copias de todos los demás grabable, localmente contiene las propiedades del conjunto.</span><span class="sxs-lookup"><span data-stu-id="25580-302">The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span></span> <span data-ttu-id="25580-303">Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-303">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="25580-304">Si el objeto tiene propiedades de dependencia animadas, se copian los valores base (no animados) de esas propiedades.</span><span class="sxs-lookup"><span data-stu-id="25580-304">If the object has animated dependency properties, the base (non-animated) values of those properties are copied.</span></span> <span data-ttu-id="25580-305">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-305">Animations are not copied.</span></span>  
  
<span data-ttu-id="25580-306">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-306">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
<span data-ttu-id="25580-307">Si invalida este método, debe llamar a la implementación base.</span><span class="sxs-lookup"><span data-stu-id="25580-307">If you do override this method, you must call the base implementation.</span></span>  
  
<span data-ttu-id="25580-308">No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.</span><span class="sxs-lookup"><span data-stu-id="25580-308">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span></span>  <span data-ttu-id="25580-309">El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="25580-309">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-310">Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" /> con los valores de propiedad actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-310">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span></span> <span data-ttu-id="25580-311">Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</span><span class="sxs-lookup"><span data-stu-id="25580-311">Because the copy is frozen, any frozen sub-objects are copied by reference.</span></span></summary>
        <returns><span data-ttu-id="25580-312">Copia inmovilizada de <see cref="T:System.Windows.Freezable" />.</span><span class="sxs-lookup"><span data-stu-id="25580-312">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="25580-313">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="25580-313">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-314">Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.CloneCurrentValue%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-314">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="25580-315">El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.</span><span class="sxs-lookup"><span data-stu-id="25580-315">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="25580-316">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="25580-316">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="25580-317">Acción</span><span class="sxs-lookup"><span data-stu-id="25580-317">Action</span></span>|<span data-ttu-id="25580-318">Comportamiento del método GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="25580-318">GetAsFrozen method behavior</span></span>|<span data-ttu-id="25580-319">Comportamiento del método GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="25580-319">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="25580-320">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="25580-320">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="25580-321">El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.</span><span class="sxs-lookup"><span data-stu-id="25580-321">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="25580-322">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="25580-322">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="25580-323">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="25580-323">Copying an animated dependency property</span></span>|<span data-ttu-id="25580-324">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="25580-324">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="25580-325">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-325">Animations are not copied.</span></span>|<span data-ttu-id="25580-326">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="25580-326">The property's current animated value is copied.</span></span> <span data-ttu-id="25580-327">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="25580-327">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="25580-328">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="25580-328">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="25580-329">Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="25580-329">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-330">Este método usa virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</span><span class="sxs-lookup"><span data-stu-id="25580-330">This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="25580-331">Clase <see cref="T:System.Windows.Freezable" /> que se va a copiar e inmovilizar.</span><span class="sxs-lookup"><span data-stu-id="25580-331">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span></span></param>
        <summary><span data-ttu-id="25580-332">Convierte la instancia actual en un clon inmovilizado del valor de <see cref="T:System.Windows.Freezable" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="25580-332">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="25580-333">Si el objeto tiene propiedades de dependencia animadas, se copian sus valores animados actuales.</span><span class="sxs-lookup"><span data-stu-id="25580-333">If the object has animated dependency properties, their current animated values are copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-334">Este método es invocado por el <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="25580-334">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="25580-335">Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="25580-335">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-336">Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método.</span><span class="sxs-lookup"><span data-stu-id="25580-336">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span></span> <span data-ttu-id="25580-337">Razones para invalidar incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="25580-337">Reasons to override include the following:</span></span> 
<span data-ttu-id="25580-338">-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-338">-   Your derived class has data that is not exposed via dependency properties.</span></span>  
  
<span data-ttu-id="25580-339">-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span><span class="sxs-lookup"><span data-stu-id="25580-339">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span></span> <span data-ttu-id="25580-340">Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.</span><span class="sxs-lookup"><span data-stu-id="25580-340">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span></span>  
  
<span data-ttu-id="25580-341">Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.</span><span class="sxs-lookup"><span data-stu-id="25580-341">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.</span></span>  
  
<span data-ttu-id="25580-342">Es fundamental que todas las implementaciones de llamar a la implementación base de este método.</span><span class="sxs-lookup"><span data-stu-id="25580-342">It is essential that all implementations call the base implementation of this method.</span></span> <span data-ttu-id="25580-343">Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="25580-343">Implementations should only perform work that is not performed by the default implementation.</span></span> <span data-ttu-id="25580-344">La implementación predeterminada crea un nuevo <see cref="T:System.Windows.Freezable" /> utilizando el <see cref="M:System.Windows.Freezable.CreateInstance" /> método y hace copias en profundidad de Freezable no inmovilizados y copia superficial de todos los demás grabable y propiedades que contiene establecido localmente.</span><span class="sxs-lookup"><span data-stu-id="25580-344">The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span></span> <span data-ttu-id="25580-345">Si el objeto tiene propiedades de dependencia enlazada a datos, los enlaces de datos se copian, pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="25580-345">If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span> <span data-ttu-id="25580-346">Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.</span><span class="sxs-lookup"><span data-stu-id="25580-346">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span></span>  
  
<span data-ttu-id="25580-347">Propiedades de dependencia de sólo lectura dentro de un <see cref="T:System.Windows.Freezable" /> no se copian por esta implementación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="25580-347">Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.</span></span>  
  
<span data-ttu-id="25580-348">Si invalida este método, debe llamar a la implementación base.</span><span class="sxs-lookup"><span data-stu-id="25580-348">If you do override this method, you must call the base implementation.</span></span>  
  
<span data-ttu-id="25580-349">No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.</span><span class="sxs-lookup"><span data-stu-id="25580-349">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span></span>  <span data-ttu-id="25580-350">El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="25580-350">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25580-351">Obtiene un valor que indica si el objeto se puede modificar actualmente.</span><span class="sxs-lookup"><span data-stu-id="25580-351">Gets a value that indicates whether the object is currently modifiable.</span></span></summary>
        <value><span data-ttu-id="25580-352"><see langword="true" /> si el objeto se inmoviliza y no se puede modificar; <see langword="false" /> si se puede modificar el objeto.</span><span class="sxs-lookup"><span data-stu-id="25580-352"><see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-353">Al intentar modificar un objeto cuando su <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true` produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="25580-353">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="25580-354">Esta propiedad es de solo lectura desde la perspectiva del modelo de objeto.</span><span class="sxs-lookup"><span data-stu-id="25580-354">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="25580-355">Parte de la documentación sobre <xref:System.Windows.Freezable> comportamientos se pueden mencionar "establece <xref:System.Windows.Freezable.IsFrozen%2A> a `true`" o lenguaje similar al hablar sobre el comportamiento de otros métodos de <xref:System.Windows.Freezable>, pero este comportamiento ocurre internamente en las instancias de clases Cuando los métodos de la instancia de manipulan las variables privadas que existen dentro de la clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="25580-355">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="25580-356">Para establecer el valor de esta propiedad, debe llamar a <xref:System.Windows.Freezable.Freeze%2A>.</span><span class="sxs-lookup"><span data-stu-id="25580-356">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="25580-357">Esto es efectivamente una operación única para cambiar la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad desde el valor predeterminado inicial `false` estado el `true` estado.</span><span class="sxs-lookup"><span data-stu-id="25580-357">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="25580-358">No hay ningún medio disponible para establecer el valor a `false`.</span><span class="sxs-lookup"><span data-stu-id="25580-358">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="25580-359">En su lugar, puede cambiar cualquier copia en profundidad realizada desde el original (consulte la <xref:System.Windows.Freezable.Clone%2A> método).</span><span class="sxs-lookup"><span data-stu-id="25580-359">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="25580-360">Esto es así por diseño y es cómo debe comportarse cualquier clase derivada cuando se aplica a los casos donde el <xref:System.Windows.Freezable> patrón es útil.</span><span class="sxs-lookup"><span data-stu-id="25580-360">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-361">Se llama cuando el objeto <see cref="T:System.Windows.Freezable" /> actual.</span><span class="sxs-lookup"><span data-stu-id="25580-361">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-362">Este método se llama cada vez que el <xref:System.Windows.Freezable.Changed> se produce el evento.</span><span class="sxs-lookup"><span data-stu-id="25580-362">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-363">Al implementar una clase que derive de <see cref="T:System.Windows.Freezable" />, puede invalidar este método para llevar a cabo las tareas.</span><span class="sxs-lookup"><span data-stu-id="25580-363">When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</span></span></para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="25580-364">Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos de tipo <see cref="T:System.Windows.DependencyObject" /> que se acaba de modificar.</span><span class="sxs-lookup"><span data-stu-id="25580-364">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="25580-365">Valor previo del miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="25580-365">The previous value of the data member.</span></span></param>
        <param name="newValue"><span data-ttu-id="25580-366">Valor actual del miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="25580-366">The current value of the data member.</span></span></param>
        <summary><span data-ttu-id="25580-367">Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos <see cref="T:System.Windows.DependencyObjectType" /> que se acaba de establecer.</span><span class="sxs-lookup"><span data-stu-id="25580-367">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-368">Este método debe llamarse <xref:System.Windows.Freezable> los herederos cada vez que un <xref:System.Windows.DependencyObject> miembro de datos que no se almacena como un <xref:System.Windows.DependencyProperty> está establecido.</span><span class="sxs-lookup"><span data-stu-id="25580-368">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="25580-369">Este método no deben llamarse para <xref:System.Windows.DependencyObject> miembros de datos que se almacenan con un <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="25580-369">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="25580-370">Valor previo del miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="25580-370">The previous value of the data member.</span></span></param>
        <param name="newValue"><span data-ttu-id="25580-371">Valor actual del miembro de datos.</span><span class="sxs-lookup"><span data-stu-id="25580-371">The current value of the data member.</span></span></param>
        <param name="property"><span data-ttu-id="25580-372">Propiedad que ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="25580-372">The property that changed.</span></span></param>
        <summary><span data-ttu-id="25580-373">Este miembro es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</span><span class="sxs-lookup"><span data-stu-id="25580-373">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="25580-374">Datos de evento que contienen información acerca de qué propiedad ha cambiado y de sus valores antiguos y nuevos.</span><span class="sxs-lookup"><span data-stu-id="25580-374">Event data that contains information about which property changed, and its old and new values.</span></span></param>
        <summary><span data-ttu-id="25580-375">Reemplaza la implementación <see cref="T:System.Windows.DependencyObject" /> de <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> para invocar también cualquier controlador <see cref="E:System.Windows.Freezable.Changed" /> en respuesta a una propiedad de dependencia cambiante de tipo <see cref="T:System.Windows.Freezable" />.</span><span class="sxs-lookup"><span data-stu-id="25580-375">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-376">Los datos de evento contienen información acerca de sólo el <xref:System.Windows.Freezable> propio.</span><span class="sxs-lookup"><span data-stu-id="25580-376">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="25580-377">Cualquier información de la subpropiedad debe obtenerse a través de la <xref:System.Windows.Freezable.Changed> controladores.</span><span class="sxs-lookup"><span data-stu-id="25580-377">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-378">Se asegura de que se tiene acceso a <see cref="T:System.Windows.Freezable" /> desde un subproceso válido.</span><span class="sxs-lookup"><span data-stu-id="25580-378">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span></span> <span data-ttu-id="25580-379">Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de las [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que lean miembros de datos que no son propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-379">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-380">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a la <see cref="M:System.Windows.Freezable.ReadPreamble" /> método antes de intentar tener acceso a los miembros que no son propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-380">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties.</span></span> <span data-ttu-id="25580-381">El <see cref="M:System.Windows.Freezable.WritePreamble" /> debe llamarse al método antes de que los miembros de este tipo se escriben en.</span><span class="sxs-lookup"><span data-stu-id="25580-381">The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.</span></span>  
  
<span data-ttu-id="25580-382">Este método eficazmente no hace nada más que llamar a <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</span><span class="sxs-lookup"><span data-stu-id="25580-382">This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-383">Genera el evento <see cref="E:System.Windows.Freezable.Changed" /> para <see cref="T:System.Windows.Freezable" /> e invoca su método <see cref="M:System.Windows.Freezable.OnChanged" />.</span><span class="sxs-lookup"><span data-stu-id="25580-383">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span></span> <span data-ttu-id="25580-384">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al final de cualquier API que modifique miembros de clase que no estén almacenados como propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-384">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-385">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a este método al final de cualquier API que modifique un miembro de clase que no se almacena como un <see cref="T:System.Windows.DependencyProperty" />.</span><span class="sxs-lookup"><span data-stu-id="25580-385">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25580-386">Comprueba que no se inmovilice <see cref="T:System.Windows.Freezable" /> y que se tiene acceso desde un contexto de subproceso válido.</span><span class="sxs-lookup"><span data-stu-id="25580-386">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span></span> <span data-ttu-id="25580-387">Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de cualquier [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que escriba en miembros de datos que no sean propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-387"><see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25580-388">Este método llama a <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> para comprobar el contexto del subproceso está accesible, y produce una excepción si el <xref:System.Windows.Freezable> instancia ya está inmovilizada.</span><span class="sxs-lookup"><span data-stu-id="25580-388">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25580-389">La instancia de <see cref="T:System.Windows.Freezable" /> se inmoviliza y no se puede escribir en sus miembros.</span><span class="sxs-lookup"><span data-stu-id="25580-389">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="25580-390">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a <see cref="M:System.Windows.Freezable.WritePreamble" /> antes de intentar escribir en los miembros que no son propiedades de dependencia.</span><span class="sxs-lookup"><span data-stu-id="25580-390">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties.</span></span> <span data-ttu-id="25580-391">Si se llama a <see cref="M:System.Windows.Freezable.WritePreamble" /> en un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], puede omitir una llamada a <see cref="M:System.Windows.Freezable.ReadPreamble" />.</span><span class="sxs-lookup"><span data-stu-id="25580-391">If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</span></span></para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>