<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1654c2b9408230e6affdc108b99fd2438bc2defd" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934202" /></Metadata><TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <TypeSignature Language="F#" Value="type RuntimeHelpers = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="70249-101">Proporciona un conjunto de propiedades y métodos estáticos que proporcionan funcionalidad para los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-101">Provides a set of static methods and properties that provide support for compilers.</span></span> <span data-ttu-id="70249-102">Esta clase no puede heredarse.</span><span class="sxs-lookup"><span data-stu-id="70249-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="70249-103">El ejemplo siguiente muestra cómo establecer identificadores de forma confiable mediante el uso de la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método.</span><span class="sxs-lookup"><span data-stu-id="70249-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="70249-104">Para establecer un identificador fiable a un identificador existente, debe asegurarse de que la asignación del identificador nativo y el registro posterior de dicho identificador en un <xref:System.Runtime.InteropServices.SafeHandle> objeto es atómico.</span><span class="sxs-lookup"><span data-stu-id="70249-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="70249-105">Cualquier error entre estas operaciones (por ejemplo, una anulación del subproceso o una excepción de memoria insuficiente) provocará la pérdida del identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="70249-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="70249-106">Puede usar el <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método para asegurarse de que el identificador no se pierdan.</span><span class="sxs-lookup"><span data-stu-id="70249-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member EnsureSufficientExecutionStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70249-107">Asegura que el espacio de pila restante es suficiente para ejecutar la función media de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="70249-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> Proporciona información sobre una pila artificialmente limitada que conserva el espacio suficiente para que se generará una excepción y que se realice la acción de recuperación.</span><span class="sxs-lookup"><span data-stu-id="70249-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="70249-109">El límite de pila artificiales se elige por common language runtime para asegurarse de que queda suficiente espacio para producir una excepción de forma segura.</span><span class="sxs-lookup"><span data-stu-id="70249-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="70249-110">Este método es útil en situaciones donde el desbordamiento de pila puede producirse como resultado de la recursividad ilimitada.</span><span class="sxs-lookup"><span data-stu-id="70249-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="70249-111">Está pensado para su uso en escenarios de servicios del compilador, aunque también se pueden usar con seguridad en otros escenarios de desarrollo.</span><span class="sxs-lookup"><span data-stu-id="70249-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="70249-112">Si el espacio de pila es suficiente, no se produce la excepción y todavía se pueden llamar a mayoría de los miembros y tipos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="70249-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="70249-113">Este método no es parte de la compatibilidad de ejecución restringida (CER) de la región y no debe confundirse con el <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException"><span data-ttu-id="70249-114">El espacio de pila disponible es insuficiente para ejecutar la función media de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="70249-114">The available stack space is insufficient to execute the average .NET Framework function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.Equals (o1, o2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o2" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o1"><span data-ttu-id="70249-115">Primer objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="70249-115">The first object to compare.</span></span></param>
        <param name="o2"><span data-ttu-id="70249-116">Segundo objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="70249-116">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="70249-117">Determina si las instancias de <see cref="T:System.Object" /> especificadas se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="70249-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="70249-118">Es <see langword="true" /> si el parámetro <paramref name="o1" /> es la misma instancia que el parámetro <paramref name="o2" />, si ambos parámetros tienen el valor <see langword="null" /> o si <c>o1.Equals(o2)</c> devuelve <see langword="true" />; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="70249-118"><see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-119">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70249-120">En el ejemplo siguiente se muestra cómo comparar dos objetos mediante el <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="70249-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="static member ExecuteCodeWithGuaranteedCleanup : System.Runtime.CompilerServices.RuntimeHelpers.TryCode * System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode * obj -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup (code, backoutCode, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userData" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="code"><span data-ttu-id="70249-121">Delegado del código que se va a probar.</span><span class="sxs-lookup"><span data-stu-id="70249-121">A delegate to the code to try.</span></span></param>
        <param name="backoutCode"><span data-ttu-id="70249-122">Delegado del código que se va a ejecutar si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="70249-122">A delegate to the code to run if an exception occurs.</span></span></param>
        <param name="userData"><span data-ttu-id="70249-123">Los datos que se van a pasar a los parámetros <paramref name="code" /> y <paramref name="backoutCode" />.</span><span class="sxs-lookup"><span data-stu-id="70249-123">The data to pass to <paramref name="code" /> and <paramref name="backoutCode" />.</span></span></param>
        <summary><span data-ttu-id="70249-124">Ejecuta código utilizando un <see cref="T:System.Delegate" /> a la vez que utiliza otro <see cref="T:System.Delegate" /> para ejecutar código adicional en caso de una excepción.</span><span class="sxs-lookup"><span data-stu-id="70249-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-125">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-126">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-126">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-127">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-127">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : obj -&gt; int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="70249-128">Objeto cuyo código hash se va a recuperar.</span><span class="sxs-lookup"><span data-stu-id="70249-128">An object to retrieve the hash code for.</span></span></param>
        <summary><span data-ttu-id="70249-129">Sirve como función hash para un objeto concreto, y es apropiado para su utilización en algoritmos hash y estructuras de datos que usan códigos hash, como las tablas hash.</span><span class="sxs-lookup"><span data-stu-id="70249-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="70249-130">Código hash para el objeto identificado por el parámetro <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="70249-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-131">El <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> siempre llama un método la <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método no virtual, incluso si el tipo del objeto ha invalidado el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="70249-132">Por lo tanto, uso <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> pueden diferir de la llamada `GetHashCode` directamente en el objeto con el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="70249-133">Aunque el <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> método devuelve los códigos hash idénticos para las referencias de objeto idéntico, no debe utilizar este método para comprobar la identidad del objeto, ya que este código hash no identifica una referencia de objeto.</span><span class="sxs-lookup"><span data-stu-id="70249-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="70249-134">Para probar para identificar el objeto (es decir, para comprobar que dos objetos de referencia al mismo objeto en memoria), llame a la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="70249-135">Tampoco debe utilizar <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> para comprobar si dos cadenas representan las referencias de objeto igual, porque se aplica el método Intern la cadena.</span><span class="sxs-lookup"><span data-stu-id="70249-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="70249-136">Para comprobar internamiento, llame a la <xref:System.String.IsInterned%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="70249-137">El <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> métodos difieren como sigue:</span><span class="sxs-lookup"><span data-stu-id="70249-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="70249-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Devuelve un código hash que se basa en la definición del objeto de igualdad.</span><span class="sxs-lookup"><span data-stu-id="70249-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="70249-139">Por ejemplo, dos cadenas con contenido idéntico devolverá el mismo valor para <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70249-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="70249-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Devuelve un código hash que indica la identidad del objeto.</span><span class="sxs-lookup"><span data-stu-id="70249-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="70249-141">Es decir, dos variables cuyo contenido es idéntico y que representan una cadena que se aplica el método Intern a cadenas (consulte la [internamiento](#interning) sección) o que representan una sola cadena en la memoria devolver idénticos códigos hash.</span><span class="sxs-lookup"><span data-stu-id="70249-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="70249-142">Tenga en cuenta que <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> siempre devuelve los códigos hash idénticos para las referencias a objetos iguales.</span><span class="sxs-lookup"><span data-stu-id="70249-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="70249-143">Sin embargo, lo contrario no es cierto: los códigos hash iguales no indican las referencias a objetos iguales.</span><span class="sxs-lookup"><span data-stu-id="70249-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="70249-144">Un valor de código hash en particular no es único para una referencia de objeto determinado; referencias a objetos diferentes pueden generar los códigos hash idénticos.</span><span class="sxs-lookup"><span data-stu-id="70249-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="70249-145">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="70249-146">Internamiento de cadenas</span><span class="sxs-lookup"><span data-stu-id="70249-146">String Interning</span></span>  
 <span data-ttu-id="70249-147">Common language runtime (CLR) mantiene un grupo interno de cadenas y almacena los literales en el grupo.</span><span class="sxs-lookup"><span data-stu-id="70249-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="70249-148">Si dos cadenas (por ejemplo, `str1` y `str2`) están formados por una cadena idéntica literal, establecerá el CLR `str1` y `str2` para que apunte a la misma ubicación en el montón administrado para conservar memoria.</span><span class="sxs-lookup"><span data-stu-id="70249-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="70249-149">Una llamada a <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> en la cadena de estos dos objetos producirá el mismo código hash, al contrario que el segundo elemento con viñetas en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="70249-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="70249-150">El CLR sólo agrega los literales al grupo.</span><span class="sxs-lookup"><span data-stu-id="70249-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="70249-151">Resultados de las operaciones de cadena como la concatenación no se agregan al grupo, a menos que el compilador resuelve la concatenación de cadenas como un literal de cadena único.</span><span class="sxs-lookup"><span data-stu-id="70249-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="70249-152">Por consiguiente, si `str2` se creó como el resultado de una operación de concatenación, y `str2` es idéntico a `str1`, al utilizar <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> en estos dos objetos de cadena, no se generará el mismo código hash.</span><span class="sxs-lookup"><span data-stu-id="70249-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="70249-153">Si desea agregar una cadena concatenada al grupo de forma explícita, utilice el <xref:System.String.Intern%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="70249-154">También puede usar el <xref:System.String.IsInterned%2A?displayProperty=nameWithType> método para comprobar si una cadena tiene una referencia de método Intern.</span><span class="sxs-lookup"><span data-stu-id="70249-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70249-155">En el ejemplo siguiente se muestra la diferencia entre el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> y <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="70249-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="70249-156">El resultado del ejemplo muestra lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="70249-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="70249-157">Ambos conjuntos de códigos hash para el primer conjunto de cadenas que se pasan a la `ShowHashCodes` método son diferentes, porque las cadenas son completamente diferentes.</span><span class="sxs-lookup"><span data-stu-id="70249-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="70249-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> genera el mismo código hash para el segundo conjunto de cadenas que se pasa a la `ShowHashCodes` método, porque las cadenas son iguales.</span><span class="sxs-lookup"><span data-stu-id="70249-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="70249-159">Sin embargo, el <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> método no lo hace.</span><span class="sxs-lookup"><span data-stu-id="70249-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="70249-160">La primera cadena se define mediante el uso de un literal de cadena y por lo que se esté internada.</span><span class="sxs-lookup"><span data-stu-id="70249-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="70249-161">Aunque el valor de la segunda cadena es el mismo, no esté internado, porque es devuelto por una llamada a la <xref:System.String.Format%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="70249-162">En el caso de la tercera cadena, los códigos hash generados por <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para ambas cadenas son idénticas, como son los códigos hash generados por <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="70249-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="70249-163">Esto es debido a que el compilador trata el valor asignado a ambas cadenas como un literal de cadena único, por lo que hacen referencia las variables de cadena en la misma cadena de método Intern.</span><span class="sxs-lookup"><span data-stu-id="70249-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectValue : obj -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="70249-164">Tipo de valor que se va a encuadrar.</span><span class="sxs-lookup"><span data-stu-id="70249-164">The value type to be boxed.</span></span></param>
        <summary><span data-ttu-id="70249-165">Encuadra un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="70249-165">Boxes a value type.</span></span></summary>
        <returns><span data-ttu-id="70249-166">Copia encuadrada de <paramref name="obj" /> en el caso de que sea una clase de valor; de lo contrario, se devuelve el propio <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="70249-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-167">Conversión boxing de un tipo de valor crea un objeto y realiza una copia superficial de los campos del tipo de valor especificado en el nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="70249-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="70249-168">Este método permite que una clase de valor a tratarse como un objeto mientras conserva el comportamiento de alias de una clase de valor.</span><span class="sxs-lookup"><span data-stu-id="70249-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="70249-169">El valor devuelto depende de si la clase de valor es mutable o no:</span><span class="sxs-lookup"><span data-stu-id="70249-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="70249-170">Si el valor asignado es una clase de valor mutable, el método devuelve una copia superficial de la clase, porque las clases de valor tienen semántica de copia.</span><span class="sxs-lookup"><span data-stu-id="70249-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="70249-171">Si el valor asignado es una clase de valor inmutable, el método devuelve el objeto, en lugar de una copia de la clase.</span><span class="sxs-lookup"><span data-stu-id="70249-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="70249-172">Los compiladores de lenguajes de tipo dinámico pueden usar este método para asegurarse de que los tipos de valor con conversión boxing son idénticos a los tipos de valor con conversión unboxing.</span><span class="sxs-lookup"><span data-stu-id="70249-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="70249-173">Es decir, tipos de valor con conversión boxing se clonan al pasarlos en torno a, y siempre se pasan por valor.</span><span class="sxs-lookup"><span data-stu-id="70249-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="70249-174">El compilador puede llamar a <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> para asignar un tipo de valor a un objeto o pasar un tipo de valor como un parámetro de un objeto de tipo.</span><span class="sxs-lookup"><span data-stu-id="70249-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="70249-175">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70249-176">En el ejemplo siguiente se muestra cómo boxing de una clase de valor mediante el uso de la <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="70249-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetUninitializedObject : Type -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="F#" Value="static member InitializeArray : Array * RuntimeFieldHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray (array, fldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="70249-177">Matriz que se va a inicializar.</span><span class="sxs-lookup"><span data-stu-id="70249-177">The array to be initialized.</span></span></param>
        <param name="fldHandle"><span data-ttu-id="70249-178">Identificador de campo que especifica la ubicación de los datos que se utilizan para inicializar la matriz.</span><span class="sxs-lookup"><span data-stu-id="70249-178">A field handle that specifies the location of the data used to initialize the array.</span></span></param>
        <summary><span data-ttu-id="70249-179">Proporciona un modo rápido de inicializar una matriz a partir de los datos almacenados en un módulo.</span><span class="sxs-lookup"><span data-stu-id="70249-179">Provides a fast way to initialize an array from data that is stored in a module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-180">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberSignature Language="F#" Value="static member IsReferenceOrContainsReferences : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetToStringData : int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="70249-181">Obtiene el desplazamiento, en bytes, hasta los datos de la cadena especificada.</span><span class="sxs-lookup"><span data-stu-id="70249-181">Gets the offset, in bytes, to the data in the given string.</span></span></summary>
        <value><span data-ttu-id="70249-182">El desplazamiento de bytes se realiza desde el inicio del objeto <see cref="T:System.String" /> hasta el primer carácter de la cadena.</span><span class="sxs-lookup"><span data-stu-id="70249-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-183">Los compiladores usan esta propiedad para las operaciones de puntero no seguro, pero eficaz, de los caracteres de una cadena administrada.</span><span class="sxs-lookup"><span data-stu-id="70249-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="70249-184">Los compiladores deben anclar la cadena en función de movimiento por el recolector de elementos no utilizados antes de su uso.</span><span class="sxs-lookup"><span data-stu-id="70249-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="70249-185">Tenga en cuenta que common language runtime las cadenas son inmutables; es decir, su contenido se puede leer pero no cambia.</span><span class="sxs-lookup"><span data-stu-id="70249-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegions : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70249-186">Designa un cuerpo de código como una región de ejecución limitada (CER,  Constrained Execution Region).</span><span class="sxs-lookup"><span data-stu-id="70249-186">Designates a body of code as a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-187">Los compiladores usan este método para marcar `catch`, `finally`, y `fault` bloques como regiones de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="70249-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="70249-188">Código que está marcado como región restringida solo debe llamar a otro código con contratos de confiabilidad seguro.</span><span class="sxs-lookup"><span data-stu-id="70249-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="70249-189">No debe asignar ni realizar llamadas virtuales a métodos no preparados o no confiables a menos que ya está preparado para controlar los errores.</span><span class="sxs-lookup"><span data-stu-id="70249-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="70249-190">Tenga en cuenta que no intermedio de operación de lenguaje, excepto `NOP`, se permiten entre una llamada a la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método y el `try` bloque.</span><span class="sxs-lookup"><span data-stu-id="70249-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="70249-191">Para obtener más información acerca de las CER, vea las clases en el <xref:System.Runtime.ConstrainedExecution> espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="70249-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="70249-192">Las CER que están marcadas con el <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método no funciona perfectamente cuando un <xref:System.StackOverflowException> se genera a partir del `try` bloque.</span><span class="sxs-lookup"><span data-stu-id="70249-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="70249-193">Para obtener más información, vea el método <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="70249-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="70249-194">El método <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> llama al método <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A>.</span><span class="sxs-lookup"><span data-stu-id="70249-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="70249-195">El ejemplo siguiente muestra cómo establecer identificadores de forma confiable mediante el uso de la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método.</span><span class="sxs-lookup"><span data-stu-id="70249-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="70249-196">Para establecer un identificador fiable a un identificador existente, debe asegurarse de que la asignación del identificador nativo y el registro posterior de dicho identificador en un <xref:System.Runtime.InteropServices.SafeHandle> objeto es atómico.</span><span class="sxs-lookup"><span data-stu-id="70249-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="70249-197">Cualquier error entre estas operaciones (por ejemplo, una anulación del subproceso o una excepción de memoria insuficiente) provocará la pérdida del identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="70249-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="70249-198">Puede usar el <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método para asegurarse de que el identificador no se pierdan.</span><span class="sxs-lookup"><span data-stu-id="70249-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-199">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-200">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegionsNoOP : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70249-201">Designa un cuerpo de código como una región de ejecución limitada (CER,  Constrained Execution Region) sin realizar ningún sondeo.</span><span class="sxs-lookup"><span data-stu-id="70249-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-202">Los compiladores no deben llamar directamente a este método.</span><span class="sxs-lookup"><span data-stu-id="70249-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="70249-203">En su lugar, defina una CER mediante una llamada a la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-204">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-204">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-205">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-205">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareContractedDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="70249-206">Delegado de eventos que se va a preparar.</span><span class="sxs-lookup"><span data-stu-id="70249-206">The event delegate to prepare.</span></span></param>
        <summary><span data-ttu-id="70249-207">Proporciona a las aplicaciones un modo de preparar dinámicamente delegados de eventos de <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="70249-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-208"><xref:System.AppDomain> los delegados de eventos como <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, y <xref:System.AppDomain.UnhandledException> no se preparan automáticamente al inicio.</span><span class="sxs-lookup"><span data-stu-id="70249-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="70249-209">Puede usar los métodos siguientes para prepararlos:</span><span class="sxs-lookup"><span data-stu-id="70249-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="70249-210">El método de atributo utilizando la <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="70249-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="70249-211">El método de atributo utilizando la <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="70249-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="70249-212">Llame a la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> método preparar dinámicamente el delegado.</span><span class="sxs-lookup"><span data-stu-id="70249-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="70249-213">Para obtener más información, vea el artículo [su código ejecutándose con las características de confiabilidad de .NET Framework](https://go.microsoft.com/fwlink/?LinkId=145491) en MSDN Magazine.</span><span class="sxs-lookup"><span data-stu-id="70249-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](https://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-214">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-214">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-215">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-215">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="70249-216">Tipo de delegado que se va a preparar.</span><span class="sxs-lookup"><span data-stu-id="70249-216">The delegate type to prepare.</span></span></param>
        <summary><span data-ttu-id="70249-217">Indica que el delegado especificado debe estar preparado para la inclusión en una región de ejecución limitada (CER).</span><span class="sxs-lookup"><span data-stu-id="70249-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-218">Los compiladores usan este método para preparar el método de invocación de un delegado y preparar el destino de esa invocación (gráfico de llamada determinarse estáticamente del delegado) como una región de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="70249-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-219">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-219">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-220">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-220">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="70249-221">Prepara un método para la inclusión en una región de ejecución limitada (CER, Constrained Execution Region).</span><span class="sxs-lookup"><span data-stu-id="70249-221">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="70249-222">Identificador del método que se va a preparar.</span><span class="sxs-lookup"><span data-stu-id="70249-222">A handle to the method to prepare.</span></span></param>
        <summary><span data-ttu-id="70249-223">Prepara un método para la inclusión en una región de ejecución limitada (CER, Constrained Execution Region).</span><span class="sxs-lookup"><span data-stu-id="70249-223">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-224">Los compiladores usan el <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> método para controlar llamadas virtuales que se realizan dentro de una región de ejecución restringida (CER).</span><span class="sxs-lookup"><span data-stu-id="70249-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="70249-225">En tiempo de compilación JIT, common language runtime no suelen tener suficiente información sobre el destino de una llamada virtual.</span><span class="sxs-lookup"><span data-stu-id="70249-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="70249-226">Por lo tanto, el tiempo de ejecución no prepara inicialmente ese segmento del gráfico de llamada.</span><span class="sxs-lookup"><span data-stu-id="70249-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="70249-227">Si el código que se utiliza la región CER tiene suficiente información determinar el destino en cualquier punto del tiempo antes de la CER realmente se especifica, puede llamar a <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> para realizar la misma preparación en tiempo de ejecución que normalmente se realiza para una CER con raíz en el método especificado como un argumento.</span><span class="sxs-lookup"><span data-stu-id="70249-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-228">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-229">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle * RuntimeTypeHandle[] -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod (method, instantiation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="70249-230">Identificador del método que se va a preparar.</span><span class="sxs-lookup"><span data-stu-id="70249-230">A handle to the method to prepare.</span></span></param>
        <param name="instantiation"><span data-ttu-id="70249-231">Creación de instancias que se va a pasar al método.</span><span class="sxs-lookup"><span data-stu-id="70249-231">The instantiation to pass to the method.</span></span></param>
        <summary><span data-ttu-id="70249-232">Prepara un método para la inclusión en una región de ejecución limitada (CER, Constrained Execution Region) con la creación de instancias especificada.</span><span class="sxs-lookup"><span data-stu-id="70249-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-233">Puede proporcionar compatibilidad con elementos genéricos para los compiladores utilizando el <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="70249-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="70249-234">Common language runtime no puede preparar regiones de ejecución restringida (CER) con raíz en un método que tiene parámetros de tipo genérico (un parámetro de tipo en la clase que contiene el método o uno en el propio método) cuando se crean instancias de los parámetros de tipo como tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="70249-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="70249-235">Puede utilizar esta sobrecarga para pasar una instancia específica (por ejemplo, una matriz de tipos), especificando los parámetros de tipo de clase primero (si existe), seguido de los parámetros de tipo de método (si existe).</span><span class="sxs-lookup"><span data-stu-id="70249-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="70249-236">El tiempo de ejecución prepara esa instancia del método.</span><span class="sxs-lookup"><span data-stu-id="70249-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="70249-237">(Esto es necesario solo si usa la creación de instancias contiene al menos un parámetro de tipo de referencia). Por lo tanto, puede usar un estilo de CER `try` cláusula en un método genérico (o un método no genérico en una clase genérica) y funcionará de forma confiable con creaciones de instancias de <xref:System.Int32> u otros tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="70249-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="70249-238">Para crear instancias de referencia de tipos, como <xref:System.String>, debe usar una explícita <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> método raíz del método en la CER en primer lugar.</span><span class="sxs-lookup"><span data-stu-id="70249-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-239">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-240">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberSignature Language="F#" Value="static member ProbeForSufficientStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="70249-241">Comprueba cierta cantidad de espacio de pila para asegurarse de que no puede producirse un desbordamiento de pila dentro de un bloque de código subsiguiente (suponiendo que el código solo utiliza una cantidad finita y moderada de espacio de pila).</span><span class="sxs-lookup"><span data-stu-id="70249-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span></span> <span data-ttu-id="70249-242">Se recomienda utilizar una región de ejecución limitada (CER) en lugar de este método.</span><span class="sxs-lookup"><span data-stu-id="70249-242">We recommend that you use a constrained execution region (CER) instead of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-243">Este método se usa por la infraestructura de ejecución restringida (CER) de la región al que se ejecutan en hosts que son resistentes a desbordamiento de pila como Microsoft SQL Server y Microsoft Exchange Server.</span><span class="sxs-lookup"><span data-stu-id="70249-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="70249-244">Este método sondea actualmente 48 KB de espacio de pila en el x86 plataforma, pero la cantidad exacta puede cambiar con el tiempo y puede variar en otras plataformas.</span><span class="sxs-lookup"><span data-stu-id="70249-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="70249-245">Este método también se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="70249-246">En lugar de usar el <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> método, debe usar una CER estándar.</span><span class="sxs-lookup"><span data-stu-id="70249-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="70249-247">Es decir, si va a utilizar una cantidad moderada de espacio de pila, llame a la <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> método inmediatamente antes de su `try` / `finally` o `try` / `catch` bloque.</span><span class="sxs-lookup"><span data-stu-id="70249-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="70249-248">Si se llama a un método recursivo o se planea usar una gran cantidad de espacio de pila, debe usar el <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="70249-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="70249-249">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="70249-249">requires full trust for the immediate caller.</span></span> <span data-ttu-id="70249-250">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="70249-250">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="static member RunClassConstructor : RuntimeTypeHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="70249-251">Identificador de tipo que especifica el tipo para el que se debe ejecutar un inicializador de tipos.</span><span class="sxs-lookup"><span data-stu-id="70249-251">A type handle that specifies the type for which a type initializer should be run.</span></span></param>
        <summary><span data-ttu-id="70249-252">Garantiza que el inicializador de tipos (también conocido como "constructor estático") del tipo especificado se ha ejecutado.</span><span class="sxs-lookup"><span data-stu-id="70249-252">Ensures that the type initializer (also known as a static constructor) for the specified type has been run.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-253">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="70249-254">El inicializador de tipos produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="70249-254">The type initializer throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberSignature Language="F#" Value="static member RunModuleConstructor : ModuleHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="module"><span data-ttu-id="70249-255">Identificador que especifica el método constructor de módulo que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="70249-255">A handle that specifies the module constructor method to run.</span></span></param>
        <summary><span data-ttu-id="70249-256">Ejecuta un método constructor de módulo especificado.</span><span class="sxs-lookup"><span data-stu-id="70249-256">Runs a specified module constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="70249-257">Este método se usa por los compiladores.</span><span class="sxs-lookup"><span data-stu-id="70249-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="70249-258">El constructor de módulo inicia una excepción.</span><span class="sxs-lookup"><span data-stu-id="70249-258">The module constructor throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member TryEnsureSufficientExecutionStack : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>