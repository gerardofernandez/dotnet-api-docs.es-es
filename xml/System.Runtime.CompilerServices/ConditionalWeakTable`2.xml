<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dbf347a600196f6012ffdb19e1733f7b6934173d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36541733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <typeparam name="TKey">
      <span data-ttu-id="6b57b-101">Tipo de referencia al que se adjunta el campo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-101">The reference type to which the field is attached.</span>
      </span>
    </typeparam>
    <typeparam name="TValue">
      <span data-ttu-id="6b57b-102">Tipo del campo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-102">The field's type.</span>
      </span>
      <span data-ttu-id="6b57b-103">Debe ser un tipo de referencia.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-103">This must be a reference type.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="6b57b-104">Permite a los compiladores adjuntar dinámicamente campos de objeto a objetos administrados.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-104">Enables compilers to dynamically attach object fields to managed objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-105">La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase permite a los compiladores de lenguaje adjuntar propiedades arbitrarias a objetos administrados en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="6b57b-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="6b57b-106">Un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto es un diccionario que se enlaza un objeto administrado, que se representa mediante una clave, su propiedad adjunta, que se representa mediante un valor.</span><span class="sxs-lookup"><span data-stu-id="6b57b-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="6b57b-107">Las claves del objeto son las instancias individuales de la `TKey` (clase) a la que se adjunta la propiedad y sus valores son los valores de propiedad que se asignan a los objetos correspondientes.</span><span class="sxs-lookup"><span data-stu-id="6b57b-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="6b57b-108">Las claves deben ser únicas; en otras palabras, la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase es compatible con un valor adjunto por objeto administrado.</span><span class="sxs-lookup"><span data-stu-id="6b57b-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="6b57b-109">Dos claves son iguales si pasarlas a la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`.</span><span class="sxs-lookup"><span data-stu-id="6b57b-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6b57b-110">No se puede controlar las comparaciones de igualdad invalidando <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para establecer explícitamente el código hash para una clave.</span><span class="sxs-lookup"><span data-stu-id="6b57b-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="6b57b-111">El <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase no usa el <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método para calcular los códigos hash y, por lo tanto, no se invoca <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> invalida.</span><span class="sxs-lookup"><span data-stu-id="6b57b-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="6b57b-112">Aunque la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase contiene una colección de pares clave/valor, es mejor considerar como una tabla en lugar de un objeto de diccionario.</span><span class="sxs-lookup"><span data-stu-id="6b57b-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="6b57b-113">La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase difiere de un diccionario de varias maneras:</span><span class="sxs-lookup"><span data-stu-id="6b57b-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="6b57b-114">No se conserva las claves.</span><span class="sxs-lookup"><span data-stu-id="6b57b-114">It does not persist keys.</span></span> <span data-ttu-id="6b57b-115">Es decir, una clave no se mantiene activa solo porque es un miembro de la colección.</span><span class="sxs-lookup"><span data-stu-id="6b57b-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="6b57b-116">No incluye todos los métodos (como `GetEnumerator` o `Contains`) que normalmente tiene un diccionario.</span><span class="sxs-lookup"><span data-stu-id="6b57b-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="6b57b-117">No implementa la <xref:System.Collections.Generic.IDictionary%602> interfaz.</span><span class="sxs-lookup"><span data-stu-id="6b57b-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="6b57b-118">La <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> clase difiere de otros objetos de colección en la administración de la duración de los objetos de las claves almacenadas en la colección.</span><span class="sxs-lookup"><span data-stu-id="6b57b-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="6b57b-119">Normalmente, cuando un objeto se almacena en una colección, su duración dura hasta que se quita (y no hay ninguna referencia adicional para el objeto) o hasta que se destruya el propio objeto de colección.</span><span class="sxs-lookup"><span data-stu-id="6b57b-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="6b57b-120">Sin embargo, en la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> (clase), agregar un par clave-valor a la tabla no garantiza que la clave se conservará, aunque se puede tener acceso directamente desde un valor almacenado en la tabla (por ejemplo, si la tabla contiene una clave, A, con un valor V1 y una segunda clave, B, con un valor P2 que contiene una referencia a una).</span><span class="sxs-lookup"><span data-stu-id="6b57b-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="6b57b-121">En su lugar, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> quita automáticamente la entrada de clave/valor en cuanto no existen otras referencias a una clave fuera de la tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="6b57b-122">En este ejemplo se ilustra.</span><span class="sxs-lookup"><span data-stu-id="6b57b-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b57b-123">En el ejemplo siguiente se muestra que una clave almacenada en el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla no se conserva después de que se destruyen las referencias a él fuera de la tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="6b57b-124">El ejemplo define dos clases: `ManagedClass`, que representa la clave en la tabla, y `ClassData`, que representa el valor de clave.</span><span class="sxs-lookup"><span data-stu-id="6b57b-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="6b57b-125">El ejemplo crea tres objetos de cada tipo.</span><span class="sxs-lookup"><span data-stu-id="6b57b-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="6b57b-126">También crea una instancia de un <xref:System.WeakReference> objeto que representa el segundo `ManagedClass`y, a continuación, destruye el segundo `ManagedClass` instancia.</span><span class="sxs-lookup"><span data-stu-id="6b57b-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="6b57b-127">Al intentar recuperar el segundo `ManagedClass` objeto desde el <xref:System.WeakReference.Target%2A> propiedad indica que no permanecen ninguna referencia al objeto.</span><span class="sxs-lookup"><span data-stu-id="6b57b-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="6b57b-128">Instancias de la <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> clase son seguros para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span>
      </span>
      <span data-ttu-id="6b57b-129">No requieren llamadores a hacer cualquier bloqueo adicional.</span>
      <span class="sxs-lookup">
        <span data-stu-id="6b57b-129">They do not require callers to do any additional locking.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6b57b-130">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-131">El <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor crea una instancia vacía <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla; es decir, la tabla no contiene ningún pares clave/valor.</span><span class="sxs-lookup"><span data-stu-id="6b57b-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="6b57b-132">Puede agregar pares clave/valor mediante una llamada a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6b57b-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="6b57b-133">Todas las claves de un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto debe ser único.</span><span class="sxs-lookup"><span data-stu-id="6b57b-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="6b57b-134">Las claves no son únicas si hacen referencia al mismo objeto (es decir, si se pasan como argumentos para la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).</span><span class="sxs-lookup"><span data-stu-id="6b57b-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="6b57b-135">Clave que se va a agregar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-135">The key to add.</span>
          </span>
          <span data-ttu-id="6b57b-136">
            <c>key</c> representa el objeto al que se adjunta la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-136">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="6b57b-137">Valor de propiedad de la clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-137">The key's property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6b57b-138">Agrega una clave a la tabla.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-138">Adds a key to the table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-139">Todas las claves de un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto debe ser único.</span><span class="sxs-lookup"><span data-stu-id="6b57b-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="6b57b-140">Las claves no son únicas si hacen referencia al mismo objeto (es decir, si se pasan como argumentos para la <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).</span><span class="sxs-lookup"><span data-stu-id="6b57b-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="6b57b-141">Si la clave es la recolección durante la operación de suma, se quita el par clave/valor existente y se agrega el par clave/valor nuevo sin que se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="6b57b-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b57b-142">En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia.</span><span class="sxs-lookup"><span data-stu-id="6b57b-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="6b57b-143">El ejemplo, a continuación, se llama la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="6b57b-144">Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.</span><span class="sxs-lookup"><span data-stu-id="6b57b-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6b57b-145">
            <paramref name="key" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-145">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="6b57b-146">
            <paramref name="key" /> ya existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-146">
              <paramref name="key" /> already exists.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="6b57b-147">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-147">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="6b57b-148">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-148">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="6b57b-149">Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-149">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-150">El recolector de elementos no utilizados llame <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> cuando el objeto actual está preparado para finalizarse.</span><span class="sxs-lookup"><span data-stu-id="6b57b-150">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="6b57b-151">Clave que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-151">The key to search for.</span>
          </span>
          <span data-ttu-id="6b57b-152">
            <c>key</c> representa el objeto al que se adjunta la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-152">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6b57b-153">Busca de forma atómica una clave especificada en la tabla y devuelve el valor correspondiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-153">Atomically searches for a specified key in the table and returns the corresponding value.</span>
          </span>
          <span data-ttu-id="6b57b-154">Si la clave no existe en la tabla, el método invoca el constructor predeterminado de la clase que representa el valor de la tabla para crear un valor enlazado a la clave especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-154">If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6b57b-155">El valor correspondiente a <paramref name="key" />, si <paramref name="key" /> ya existe en la tabla; en caso contrario, un nuevo valor creado por el constructor predeterminado de la clase definida por el parámetro de tipo genérico <paramref name="TValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-155">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-156">Si `key` no existe en la tabla, el método agrega, junto con el objeto cuyas instancias se crean mediante una llamada al constructor predeterminado de la clase definida por el `TValue` parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="6b57b-156">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="6b57b-157">Si el `TValue` clase no tiene ningún constructor predeterminado, un <xref:System.MissingMethodException> se produce.</span><span class="sxs-lookup"><span data-stu-id="6b57b-157">If the `TValue` class has no default constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="6b57b-158">Este es el método recomendado para recuperar un valor existente o agregar un nuevo valor para el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla si la clase de valor de la tabla define un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="6b57b-158">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a default constructor.</span></span> <span data-ttu-id="6b57b-159">Si no define un constructor predeterminado, puede llamar en su lugar el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método, que se basa en un método proporcionado por devolución de llamada a una instancia del objeto que representa el valor de la tabla</span><span class="sxs-lookup"><span data-stu-id="6b57b-159">If it does not define a default constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="6b57b-160">Para recuperar el valor de una clave existente sin agregar el par clave/valor si la clave no se encuentra en la tabla, llame a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6b57b-160">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b57b-161">En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia.</span><span class="sxs-lookup"><span data-stu-id="6b57b-161">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="6b57b-162">El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-162">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="6b57b-163">Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.</span><span class="sxs-lookup"><span data-stu-id="6b57b-163">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6b57b-164">
            <paramref name="key" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-164">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="6b57b-165">
            <block subset="none" type="note">
              <para> En [.NET para aplicaciones de la Tienda Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), detecte la excepción de clase base, <see cref="T:System.MissingMemberException" />, en su lugar.  </para>
            </block>  La clase que representa el valor de la tabla no define un constructor predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-165">
              <block subset="none" type="note">
                <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.  </para>
              </block>  The class that represents the table's value does not define a default constructor.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="6b57b-166">Clave que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-166">The key to search for.</span>
          </span>
          <span data-ttu-id="6b57b-167">
            <c>key</c> representa el objeto al que se adjunta la propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-167">
              <c>key</c> represents the object to which the property is attached.</span>
          </span>
        </param>
        <param name="createValueCallback">
          <span data-ttu-id="6b57b-168">Un delegado para un método que puede crear un valor para el parámetro <c>key</c> dado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-168">A delegate to a method that can create a value for the given <c>key</c>.</span>
          </span>
          <span data-ttu-id="6b57b-169">Tiene un único parámetro de tipo <c>TKey</c> y devuelve un valor de tipo <c>TValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-169">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6b57b-170">Busca de forma atómica una clave especificada en la tabla y devuelve el valor correspondiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-170">Atomically searches for a specified key in the table and returns the corresponding value.</span>
          </span>
          <span data-ttu-id="6b57b-171">Si la clave no existe en la tabla, el método invoca un método de devolución de llamada para crear un valor enlazado a la clave especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-171">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6b57b-172">El valor adjunto a <paramref name="key" />, si <paramref name="key" /> ya existe en la tabla; en caso contrario, el nuevo valor devuelto por el delegado <paramref name="createValueCallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-172">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-173">Si `key` no existe en la tabla, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invoca el método definido por el `createValueCallback` parámetro y pasa la clave.</span><span class="sxs-lookup"><span data-stu-id="6b57b-173">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="6b57b-174">Un nuevo valor se enlaza a la clave en la tabla y se devuelve como resultado.</span><span class="sxs-lookup"><span data-stu-id="6b57b-174">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="6b57b-175">Use este método solo cuando la clase que representa el valor de la tabla no define un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="6b57b-175">Use this method only when the class that represents the table's value does not define a default constructor.</span></span> <span data-ttu-id="6b57b-176">Si define un constructor predeterminado, use el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="6b57b-176">If it does define a default constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="6b57b-177">Para recuperar el valor de una clave existente sin agregar el par clave/valor si la clave no se encuentra en la tabla, llame a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6b57b-177">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="6b57b-178">Si varios subprocesos intentan crear la misma clave, `createValueCallback` se puede invocar varias veces con la misma clave.</span><span class="sxs-lookup"><span data-stu-id="6b57b-178">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="6b57b-179">Solo una de estas llamadas se realizará correctamente y su valor devuelto se agregará a la tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-179">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="6b57b-180">El subproceso se realiza correctamente para crear el valor es indeterminado.</span><span class="sxs-lookup"><span data-stu-id="6b57b-180">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="6b57b-181">Esta regla permite a la tabla para invocar `createValueCallback` fuera el bloqueo de tabla interno para evitar interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="6b57b-181">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b57b-182">En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia.</span><span class="sxs-lookup"><span data-stu-id="6b57b-182">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="6b57b-183">También define una variable static (`Shared` en Visual Basic) `CreateAttachedValue` método que se puede asignar a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegar y pasa a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="6b57b-183">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="6b57b-184">El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método para agregar un `MainClass` objeto y sus asociados `MainInfo` el objeto a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-184">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="6b57b-185">Este ejemplo también muestra las llamadas a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> métodos para agregar pares clave/valor a la tabla y a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar el valor de una clave existente.</span><span class="sxs-lookup"><span data-stu-id="6b57b-185">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6b57b-186">El valor de <paramref name="key" /> o <paramref name="createValueCallback" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-186">
              <paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="6b57b-187">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-187">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="6b57b-188">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-188">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="6b57b-189">Clave que se va a quitar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-189">The key to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6b57b-190">Quita una clave y su valor de la tabla.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-190">Removes a key and its value from the table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6b57b-191">Es <see langword="true" /> si la clave se encuentra y se quita; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-191">
              <see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-192">Si la clave es la recolección durante esta operación, el método no provoca una excepción y el valor devuelto es indefinido.</span><span class="sxs-lookup"><span data-stu-id="6b57b-192">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6b57b-193">
            <paramref name="key" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-193">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="6b57b-194">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-194">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="6b57b-195">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-195">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="6b57b-196">Clave que representa un objeto con una propiedad adjunta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-196">The key that represents an object with an attached property.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="6b57b-197">Cuando este método devuelve un valor, contiene el valor de la propiedad adjunta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-197">When this method returns, contains the attached property value.</span>
          </span>
          <span data-ttu-id="6b57b-198">Si <c>key</c> no se encuentra, <c>value</c> contiene el valor predeterminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-198">If <c>key</c> is not found, <c>value</c> contains the default value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="6b57b-199">Obtiene el valor de la clave especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-199">Gets the value of the specified key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="6b57b-200">Es <see langword="true" /> si se encuentra <paramref name="key" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-200">
              <see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6b57b-201">Si la clave es recolección durante esta operación, el método puede devolver `false` y establecer `value` con el valor predeterminado el valor (como si la clave no estaban presente).</span><span class="sxs-lookup"><span data-stu-id="6b57b-201">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6b57b-202">En el ejemplo siguiente se define un `MainClass` clase y un `MainInfo` (clase), que proporciona información sobre la `MainClass` instancia.</span><span class="sxs-lookup"><span data-stu-id="6b57b-202">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="6b57b-203">El ejemplo se llama el <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, y <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para agregar pares de clave/valor a un <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-203">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="6b57b-204">En cada caso, el ejemplo llama a la <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para confirmar que el par clave-valor se ha agregado a la tabla.</span><span class="sxs-lookup"><span data-stu-id="6b57b-204">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="6b57b-205">
            <paramref name="key" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-205">
              <paramref name="key" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="6b57b-206">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-206">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="6b57b-207">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="6b57b-207">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>