<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="91e3f8eb255ecea49f114ef22b5e0be3116e0a0f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52737040" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="99585-101">Representa un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-102">Un número complejo es un número que consta de un número real y un elemento de número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="99585-103">Una número complejo de z se escribe normalmente en forma de z = x + yi, donde *x* y *y* son números reales, y \*\* es la unidad imaginaria que tiene la propiedad *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="99585-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="99585-104">La parte real del número complejo que se representa mediante *x*, y la parte imaginaria del número complejo que se representa mediante *y*.</span><span class="sxs-lookup"><span data-stu-id="99585-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="99585-105">El <xref:System.Numerics.Complex> tipo utiliza el sistema de coordenadas cartesiano (real, imaginario) al crear instancias y manipular números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="99585-106">Un número complejo se puede representar como un punto en un sistema de coordenadas bidimensional, que se conoce como el plano complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="99585-107">La parte real del número complejo se coloca en el eje x (el eje horizontal) y la parte imaginaria se coloca en el eje y (el eje vertical).</span><span class="sxs-lookup"><span data-stu-id="99585-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="99585-108">También se puede expresar cualquier punto en el plano complejo basado en su valor absoluto, mediante el sistema de coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="99585-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="99585-109">En coordenadas polares, un punto se caracteriza por dos números:</span><span class="sxs-lookup"><span data-stu-id="99585-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="99585-110">Su magnitud, que es la distancia del punto desde el origen (es decir, 0,0 o punto en el que se cortan el eje x y el eje y).</span><span class="sxs-lookup"><span data-stu-id="99585-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="99585-111">La fase, que es el ángulo entre el eje real y la línea que se dibuja desde el origen hasta el punto.</span><span class="sxs-lookup"><span data-stu-id="99585-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="99585-112">Crear instancias de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="99585-113">Puede asignar un valor a un número complejo en una de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="99585-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="99585-114">Pasando dos <xref:System.Double> valores a su constructor.</span><span class="sxs-lookup"><span data-stu-id="99585-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="99585-115">El primer valor representa la parte real del número complejo y el segundo valor representa su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="99585-116">Estos valores representan la posición del número complejo en el sistema de coordenadas cartesiano bidimensional.</span><span class="sxs-lookup"><span data-stu-id="99585-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="99585-117">Mediante una llamada a estático (`Shared` en Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> método para crear un número complejo a partir de sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="99585-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="99585-118">Asignando un <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, o <xref:System.Double> valor a un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="99585-119">El valor se convierte en la parte real del número complejo y su parte imaginaria es igual a 0.</span><span class="sxs-lookup"><span data-stu-id="99585-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="99585-120">Conversión (en C#) o convirtiendo (en Visual Basic) un <xref:System.Decimal> o <xref:System.Numerics.BigInteger> valor a un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="99585-121">El valor se convierte en la parte real del número complejo y su parte imaginaria es igual a 0.</span><span class="sxs-lookup"><span data-stu-id="99585-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="99585-122">Asignando el número complejo que es devuelto por un método u operador para un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="99585-123">Por ejemplo, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> es un método estático que devuelve un número complejo que es la suma de dos números complejos, y el <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operador agrega dos números complejos y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="99585-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="99585-124">En el ejemplo siguiente se muestra cada una de estas cinco formas de asignar un valor a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="99585-125">Operaciones con números complejos</span><span class="sxs-lookup"><span data-stu-id="99585-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="99585-126">El <xref:System.Numerics.Complex> estructura en .NET Framework incluye miembros que proporcionan la funcionalidad siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="99585-127">Métodos para comparar dos números complejos para determinar si son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="99585-128">Operadores para realizar operaciones aritméticas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="99585-129"><xref:System.Numerics.Complex> los operadores permiten realizar suma, resta, multiplicación, división y negación unaria con números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="99585-130">Métodos para realizar otras operaciones numéricas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="99585-131">Además de las cuatro operaciones aritméticas básicas, puede elevar un número complejo a una potencia especificada, encontrar la raíz cuadrada de un número complejo y obtener el valor absoluto de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="99585-132">Métodos para realizar operaciones trigonométricas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="99585-133">Por ejemplo, puede calcular la tangente de un ángulo representado por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="99585-134">Tenga en cuenta que, dado el <xref:System.Numerics.Complex.Real%2A> y <xref:System.Numerics.Complex.Imaginary%2A> propiedades son de solo lectura, no se puede modificar el valor de una existente <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="99585-135">Todos los métodos que realizan una operación en un <xref:System.Numerics.Complex> número, si su valor devuelto es de tipo <xref:System.Numerics.Complex>, devuelven un nuevo <xref:System.Numerics.Complex> número.</span><span class="sxs-lookup"><span data-stu-id="99585-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="99585-136">Precisión y números complejos</span><span class="sxs-lookup"><span data-stu-id="99585-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="99585-137">Las partes reales e imaginarias de un número complejo se representan mediante dos valores de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="99585-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="99585-138">Esto significa que <xref:System.Numerics.Complex> valores como valores de punto flotante de precisión doble, pueden perder precisión como resultado de las operaciones numéricas.</span><span class="sxs-lookup"><span data-stu-id="99585-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="99585-139">Esto significa que estricta las comparaciones de igualdad de dos <xref:System.Numerics.Complex> valores pueden fallar, incluso si la diferencia entre los dos valores es debido a una pérdida de precisión.</span><span class="sxs-lookup"><span data-stu-id="99585-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="99585-140">Para obtener más información, vea <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="99585-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="99585-141">Por ejemplo, al realizar la exponenciación en el logaritmo de un número debe devolver el número original.</span><span class="sxs-lookup"><span data-stu-id="99585-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="99585-142">Sin embargo, en algunos casos, la pérdida de precisión de los valores de punto flotante puede producir ligeras diferencias entre los dos valores, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="99585-143">De forma similar, el ejemplo siguiente, que calcula la raíz cuadrada de un <xref:System.Numerics.Complex> número, genera resultados ligeramente diferentes en las versiones de IA64 de .NET Framework y de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="99585-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="99585-144">Números complejos, Infinity y NaN</span><span class="sxs-lookup"><span data-stu-id="99585-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="99585-145">Las partes reales e imaginarias de un número complejo que se representan mediante <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="99585-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="99585-146">Además de que abarcan desde <xref:System.Double.MinValue?displayProperty=nameWithType> a <xref:System.Double.MaxValue?displayProperty=nameWithType>, la parte real o imaginaria de un número complejo puede tener un valor de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, y <xref:System.Double.NaN?displayProperty=nameWithType> todos se propagan en cualquier operación aritmética o trigonométrica.</span><span class="sxs-lookup"><span data-stu-id="99585-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="99585-148">En el ejemplo siguiente, la división por <xref:System.Numerics.Complex.Zero> genera un número complejo cuyas partes reales e imaginarias son ambos <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-149">Como resultado, realizar la multiplicación con este valor también genera un número complejo cuyas partes reales e imaginarias son <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-150">De forma similar, realizar una multiplicación que desborda el intervalo de la <xref:System.Double> tipo genera un número complejo cuya parte real es <xref:System.Double.NaN?displayProperty=nameWithType> y cuya parte imaginaria es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-151">Al realizar la división con este número complejo a continuación devuelve un número complejo cuya parte real es <xref:System.Double.NaN?displayProperty=nameWithType> y cuya parte imaginaria es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="99585-152">Operaciones matemáticas con números complejos que no son válidos o que desbordara el intervalo de la <xref:System.Double> tipo de datos no producen una excepción.</span><span class="sxs-lookup"><span data-stu-id="99585-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="99585-153">En su lugar, devuelven un <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> en las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="99585-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="99585-154">La división de un número positivo por cero devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="99585-155">Cualquier operación que desborda el límite superior de la <xref:System.Double> del tipo de datos devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="99585-156">La división de un número negativo por cero devuelve <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="99585-157">Cualquier operación que desborde el límite inferior de la <xref:System.Double> del tipo de datos devuelve <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="99585-158">Devuelve la división del cero por cero <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="99585-159">Cualquier operación que se realiza en operandos cuyos valores son <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>, dependiendo de la operación específica.</span><span class="sxs-lookup"><span data-stu-id="99585-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="99585-160">Tenga en cuenta que esto se aplica a cualquier cálculo intermedio realizada por un método.</span><span class="sxs-lookup"><span data-stu-id="99585-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="99585-161">Por ejemplo, la multiplicación de `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` utiliza la fórmula (ac - bd) + (ad + bc).</span><span class="sxs-lookup"><span data-stu-id="99585-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="99585-162">El cálculo del componente real que es el resultado de la multiplicación evalúa la expresión 9e308 \* 2.5 - 9e308 \* 3.5.</span><span class="sxs-lookup"><span data-stu-id="99585-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="99585-163">Cada multiplicación intermedia en esta expresión devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>y el intento para restar <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> desde <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> devuelve <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="99585-164">Aplicar formato a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="99585-165">De forma predeterminada, la representación de cadena de un número complejo toma la forma `(` *real* `,` *imaginaria*`)`, donde *real* y *imaginaria* son las representaciones de cadena de la <xref:System.Double> valores que forman los componentes reales e imaginarias del número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="99585-166">Algunas sobrecargas de los <xref:System.Numerics.Complex.ToString%2A> método permite la personalización de las representaciones de cadena de estos <xref:System.Double> valores para reflejar las convenciones de formato de una referencia cultural determinada o que aparezcan en un formato determinado definido por un valor numérico estándar o personalizado cadena de formato.</span><span class="sxs-lookup"><span data-stu-id="99585-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="99585-167">(Para obtener más información, consulte [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="99585-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="99585-168">Una de las maneras más comunes de expresar la representación de cadena de un número complejo toma la forma a + bi, donde una es el componente real del número complejo y b es el componente imaginario del número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="99585-169">En ingeniería eléctrica, un número complejo con más frecuencia se expresa como un + bj.</span><span class="sxs-lookup"><span data-stu-id="99585-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="99585-170">Puede devolver la representación de cadena de un número complejo de cualquiera de estas dos formas.</span><span class="sxs-lookup"><span data-stu-id="99585-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="99585-171">Para ello, defina un proveedor de formato personalizado implementando la <xref:System.ICustomFormatter> y <xref:System.IFormatProvider> interfaces y, a continuación, llame el <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="99585-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="99585-172">En el ejemplo siguiente se define un `ComplexFormatter` clase que representa un número complejo como una cadena en formato de a + bi o + bj.</span><span class="sxs-lookup"><span data-stu-id="99585-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="99585-173">En el siguiente ejemplo, a continuación, usa a este formateador personalizado para mostrar la representación de cadena de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="99585-174">Parte real del número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="99585-175">Parte imaginaria del número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="99585-176">Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.Complex" /> utilizando el valor real y el valor imaginario especificados.</span><span class="sxs-lookup"><span data-stu-id="99585-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-177">El `real` o `imaginary` argumentos pueden perder precisión si son tipos de datos que requieren una conversión explícita a <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="99585-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-178">El ejemplo siguiente se crea una instancia de dos números complejos y, a continuación, utiliza en operaciones de suma, resta, multiplicación y división.</span><span class="sxs-lookup"><span data-stu-id="99585-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-179">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-180">Obtiene el valor absoluto (o magnitud) de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-181">Valor absoluto de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-182">El valor absoluto de un número complejo es equivalente a su <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="99585-183">El valor absoluto de un número real un + bi se calcula como sigue:</span><span class="sxs-lookup"><span data-stu-id="99585-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="99585-184">Si b = 0, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="99585-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="99585-185">Si un > b, el resultado es un \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="99585-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="99585-186">Si b >, el resultado es b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="99585-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="99585-187">Si el cálculo del valor absoluto da como resultado un desbordamiento, el método devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-188">Si el <xref:System.Numerics.Complex.Real%2A> o <xref:System.Numerics.Complex.Imaginary%2A> propiedad es <xref:System.Double.NaN?displayProperty=nameWithType> y la otra propiedad no es ni <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ni <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, el método devuelve <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-189">El ejemplo siguiente se calcula el valor absoluto de un número complejo y demuestra que es equivalente al valor de la <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-190">Número complejo que representa un coseno.</span><span class="sxs-lookup"><span data-stu-id="99585-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="99585-191">Devuelve el ángulo que es el arco coseno del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-192">Ángulo, medido en radianes, que es el arco coseno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-193">El <xref:System.Numerics.Complex.Acos%2A> método para los números complejos corresponde a la <xref:System.Math.Acos%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-194">El <xref:System.Numerics.Complex.Acos%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="99585-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="99585-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="99585-196">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="99585-197">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Acos%2A> método a la <xref:System.Numerics.Complex.Cos%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-198">Primer número complejo que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="99585-198">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="99585-199">Segundo número complejo que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="99585-199">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="99585-200">Suma dos valores complejos y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="99585-200">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="99585-201">La suma de <paramref name="left" /> y <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="99585-201">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-202">La adición de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-202">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-203">(a + c) + (b + d).</span><span class="sxs-lookup"><span data-stu-id="99585-203">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="99585-204">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor del componente es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-204">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-205">Los lenguajes que no admiten operadores personalizados pueden usar el <xref:System.Numerics.Complex.Add%2A> método para sumar con números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-205">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-206">El ejemplo siguiente muestra la suma con números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-206">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-207">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-207">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-208">Devuelve el ángulo que es el arco seno del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-208">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-209">Ángulo que es el arco seno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-209">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-210">El <xref:System.Numerics.Complex.Asin%2A> método para los números complejos corresponde a la <xref:System.Math.Asin%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-210">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-211">El <xref:System.Numerics.Complex.Asin%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-211">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="99585-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valor + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valor \* valor))</span><span class="sxs-lookup"><span data-stu-id="99585-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="99585-213">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Asin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-213">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="99585-214">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Asin%2A> método a la <xref:System.Numerics.Complex.Sin%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-214">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-215">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-215">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-216">Devuelve el ángulo que es el arco tangente del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-216">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-217">Ángulo que es el arco tangente de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-217">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-218">El <xref:System.Numerics.Complex.Atan%2A> método para los números complejos corresponde a la <xref:System.Math.Atan%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-218">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-219">El <xref:System.Numerics.Complex.Atan%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-219">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="99585-220"><xref:System.Numerics.Complex.ImaginaryOne> / nuevo complejo (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valor)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valor)</span><span class="sxs-lookup"><span data-stu-id="99585-220"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="99585-221">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Atan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-221">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="99585-222">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Atan%2A> método a la <xref:System.Numerics.Complex.Tan%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-222">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-223">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-223">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-224">Calcula el conjugado de un número complejo y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="99585-224">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="99585-225">Conjugado de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-225">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-226">El conjugado de un número complejo invierte el signo del componente imaginario; es decir, negación unaria se aplica al componente imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-226">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="99585-227">Si un + bi es un número complejo, su conjugado es a - bi.</span><span class="sxs-lookup"><span data-stu-id="99585-227">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-228">El ejemplo siguiente muestra el conjugado de dos números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-228">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-229">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-229">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-230">Devuelve el coseno del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-230">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-231">Coseno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-231">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-232">El <xref:System.Numerics.Complex.Cos%2A> método para los números complejos corresponde a la <xref:System.Math.Cos%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-232">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-233">El <xref:System.Numerics.Complex.Cos%2A> método usa la siguiente fórmula para calcular el coseno del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="99585-233">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="99585-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="99585-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-235">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-235">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="99585-236">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Acos%2A> método a la <xref:System.Numerics.Complex.Cos%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-236">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-237">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-237">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-238">Devuelve el coseno hiperbólico del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-238">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-239">Coseno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-239">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-240">El <xref:System.Numerics.Complex.Cosh%2A> método para los números complejos corresponde a la <xref:System.Math.Cosh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-240">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-241">El <xref:System.Numerics.Complex.Cosh%2A> método usa la siguiente fórmula para calcular el coseno hiperbólico del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="99585-241">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="99585-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="99585-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="99585-243">Número complejo que se va a dividir.</span><span class="sxs-lookup"><span data-stu-id="99585-243">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="99585-244">Número complejo por el cual se va a dividir.</span><span class="sxs-lookup"><span data-stu-id="99585-244">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="99585-245">Divide un número complejo por otro y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="99585-245">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="99585-246">Cociente de la división.</span><span class="sxs-lookup"><span data-stu-id="99585-246">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-247">La división de un número complejo, un + bi, por un segundo número complejo, número, c + di, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-247">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-248">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>)</span><span class="sxs-lookup"><span data-stu-id="99585-248">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="99585-249">Si el cálculo del cociente provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-249">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-250">El <xref:System.Numerics.Complex.Divide%2A> método puede usarse por los lenguajes que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="99585-250">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="99585-251">Su comportamiento es idéntico a la división utilizando el operador de división.</span><span class="sxs-lookup"><span data-stu-id="99585-251">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-252">El ejemplo siguiente divide un número complejo por cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-252">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-253">Devuelve un valor que indica si dos números complejos son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-253">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-254">Número complejo que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-254">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="99585-255">Devuelve un valor que indica si la instancia actual y el número complejo especificado tienen el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="99585-255">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="99585-256">Es <see langword="true" /> si este número complejo y <paramref name="value" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="99585-256"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-257">El <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método proporciona la <xref:System.IEquatable%601> implementación para el <xref:System.Numerics.Complex> estructura.</span><span class="sxs-lookup"><span data-stu-id="99585-257">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="99585-258">Tiene un rendimiento ligeramente mejor que <xref:System.Numerics.Complex.Equals%28System.Object%29> método porque no tiene que convertir el parámetro en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-258">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="99585-259">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-259">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="99585-260">El <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="99585-260">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="99585-261">Use el <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método con precaución, porque dos valores que son aparentemente equivalentes pueden considerarse iguales debido a la precisión diferente de sus componentes reales e imaginarias.</span><span class="sxs-lookup"><span data-stu-id="99585-261">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="99585-262">En el ejemplo siguiente se notifica que <c>(3.33333, 0.142857)</c> y <c>(10/3, 1/7)</c> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-262">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="99585-263">[! código csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! código vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="99585-263">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="99585-264">Una técnica recomendada consiste en definir un margen aceptable de diferencia entre los dos valores (como. 01% de uno de los componentes de los valores reales e imaginarias) en lugar de comparar los valores para la igualdad.</span><span class="sxs-lookup"><span data-stu-id="99585-264">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="99585-265">Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a una diferencia en precisión y, por lo tanto, los valores suelen ser iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-265">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="99585-266">En el ejemplo siguiente se usa esta técnica para comparar los dos valores complejos que en el ejemplo de código anterior se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-266">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="99585-267">Busca los dos números complejos son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-267">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="99585-268">[! código csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! código vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="99585-268">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="99585-269">Objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-269">The object to compare.</span></span></param>
        <summary><span data-ttu-id="99585-270">Devuelve un valor que indica si la instancia actual y un objeto especificado tienen el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="99585-270">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="99585-271">Es <see langword="true" /> si el parámetro <paramref name="obj" /> es un objeto <see cref="T:System.Numerics.Complex" /> o un tipo capaz de realizar una conversión implícita a un objeto <see cref="T:System.Numerics.Complex" />, y su valor es igual al valor del objeto <see cref="T:System.Numerics.Complex" /> actual; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="99585-271"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-272">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-272">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="99585-273">El <xref:System.Numerics.Complex.Equals%28System.Object%29> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="99585-273">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="99585-274">Si el `obj` parámetro no es un <xref:System.Numerics.Complex> objeto, pero es un tipo de datos para el que se define una conversión implícita, el <xref:System.Numerics.Complex.Equals%28System.Object%29> método convierte `obj` a un <xref:System.Numerics.Complex> objeto cuya parte real es igual al valor de `obj`y cuya parte imaginaria es igual a cero antes de realizar la comparación.</span><span class="sxs-lookup"><span data-stu-id="99585-274">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="99585-275">El ejemplo siguiente ilustra esto mediante la búsqueda de que un número complejo y un valor de punto flotante de doble precisión son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-275">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="99585-276">Use el <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método con precaución, porque dos valores que son aparentemente equivalentes pueden considerarse iguales debido a la precisión diferente de sus componentes reales e imaginarias.</span><span class="sxs-lookup"><span data-stu-id="99585-276">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="99585-277">El problema puede ser acentúa si <paramref name="obj" /> deben convertirse a un <see cref="T:System.Double" /> antes de realizar la comparación.</span><span class="sxs-lookup"><span data-stu-id="99585-277">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="99585-278">En el ejemplo siguiente se compara un número complejo cuyo componente real parece ser igual que un <see cref="T:System.Single" /> valor con el que <see cref="T:System.Single" /> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-278">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="99585-279">Como se muestra en la salida, la comparación de igualdad devuelve <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="99585-279">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="99585-280">[! código csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! código vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="99585-280">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="99585-281">Una técnica recomendada consiste en definir un margen aceptable de diferencia entre los dos valores (como. 01% de uno de los componentes de los valores reales e imaginarias) en lugar de comparar los valores para la igualdad.</span><span class="sxs-lookup"><span data-stu-id="99585-281">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="99585-282">Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a una diferencia en precisión y, por lo tanto, los valores suelen ser iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-282">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="99585-283">El ejemplo siguiente utiliza esta técnica para comparar los dos valores que en el ejemplo de código anterior se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-283">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="99585-284">Ahora busca que son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-284">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="99585-285">[! código csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! código vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="99585-285">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-286">Número complejo que especifica una potencia.</span><span class="sxs-lookup"><span data-stu-id="99585-286">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="99585-287">Devuelve un <see langword="e" /> elevado a la potencia especificada por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-287">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-288">Número <see langword="e" /> elevado a la potencia <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-288">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-289">Use el <xref:System.Numerics.Complex.Pow%2A> método para calcular las potencias de otras bases.</span><span class="sxs-lookup"><span data-stu-id="99585-289">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="99585-290">El <xref:System.Numerics.Complex.Exp%2A> método para los números complejos corresponde a la <xref:System.Math.Exp%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-290">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="99585-291"><xref:System.Numerics.Complex.Exp%2A> es el inverso de <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="99585-291"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-292">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Exp%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-292">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="99585-293">Muestra que, con algunas máximo permitido de la falta de precisión de la <xref:System.Double> tipo de datos, pasando el valor devuelto por la <xref:System.Numerics.Complex.Log%2A> método a la <xref:System.Numerics.Complex.Exp%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-293">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="99585-294">Magnitud, que es la distancia del origen (la intersección de los ejes X e Y) al número.</span><span class="sxs-lookup"><span data-stu-id="99585-294">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="99585-295">Fase, que es el ángulo desde la línea al eje horizontal, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="99585-295">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="99585-296">Crea un número complejo a partir de las coordenadas polares de un punto.</span><span class="sxs-lookup"><span data-stu-id="99585-296">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="99585-297">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-297">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-298">El <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método crea una instancia de un número complejo según sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="99585-298">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="99585-299">Dado que hay varias representaciones de un punto en un plano complejo, el valor devuelto de la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> se normaliza el método.</span><span class="sxs-lookup"><span data-stu-id="99585-299">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="99585-300">La magnitud se normaliza a un número positivo, y la fase se normaliza a un valor en el intervalo de -<xref:System.Math.PI> a <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="99585-300">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="99585-301">Como resultado, los valores de la <xref:System.Numerics.Complex.Phase%2A> y <xref:System.Numerics.Complex.Magnitude%2A> propiedades del número complejo resultante no puede ser igual a los valores originales de la `magnitude` y `phase` parámetros.</span><span class="sxs-lookup"><span data-stu-id="99585-301">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="99585-302">Para convertir un valor de grados en radianes para el `phase` parámetro, multiplicar, por  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="99585-302">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-303">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.FromPolarCoordinates%2A> según sus coordenadas polares de método para crear instancias de un número complejo y, a continuación, muestra el valor de su <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="99585-303">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="99585-304">Devuelve el código hash del objeto <see cref="T:System.Numerics.Complex" /> actual.</span><span class="sxs-lookup"><span data-stu-id="99585-304">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="99585-305">Código hash de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="99585-305">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-306">Obtiene el componente imaginario del objeto <see cref="T:System.Numerics.Complex" /> actual.</span><span class="sxs-lookup"><span data-stu-id="99585-306">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="99585-307">Componente imaginario de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-307">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-308">Dado un número complejo a + bi, el <xref:System.Numerics.Complex.Imaginary%2A> propiedad devuelve el valor de b.</span><span class="sxs-lookup"><span data-stu-id="99585-308">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-309">El ejemplo siguiente crea una matriz de <xref:System.Numerics.Complex> objetos y se muestran los componentes reales e imaginarios de cada uno en el formulario a + bi.</span><span class="sxs-lookup"><span data-stu-id="99585-309">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-310">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a cero y un número imaginario igual a uno.</span><span class="sxs-lookup"><span data-stu-id="99585-310">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99585-311">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.ImaginaryOne> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-311">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="99585-312">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a cero y una parte imaginaria igual a uno.</span><span class="sxs-lookup"><span data-stu-id="99585-312">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="99585-313">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-313">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-314">Devuelve el logaritmo de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-314">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-315">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-315">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-316">Devuelve el logaritmo natural (en la base <see langword="e" />) del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-316">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-317">Logaritmo natural (en la base <see langword="e" />) de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-317">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-318">El <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> método para los números complejos corresponde a la <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-318">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-319">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Log%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-319">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="99585-320">Muestra que, con algunas máximo permitido de la falta de precisión de la <xref:System.Double> tipo de datos, pasando el valor devuelto por la <xref:System.Numerics.Complex.Log%2A> método a la <xref:System.Numerics.Complex.Exp%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-320">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-321">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-321">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="99585-322">Base del logaritmo.</span><span class="sxs-lookup"><span data-stu-id="99585-322">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="99585-323">Devuelve el logaritmo del número complejo especificado en la base especificada.</span><span class="sxs-lookup"><span data-stu-id="99585-323">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="99585-324">Logaritmo de <paramref name="value" /> en la base <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="99585-324">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-325">El <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> método para los números complejos corresponde a la <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-325">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-326">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-326">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-327">Devuelve el logaritmo en la base 10 del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-327">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-328">Logaritmo en base 10 de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-328">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-329">El <xref:System.Numerics.Complex.Log10%2A> método para los números complejos corresponde a la <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-329">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-330">Obtiene la magnitud (o valor absoluto) de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-330">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="99585-331">Magnitud de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="99585-331">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-332">El <xref:System.Numerics.Complex.Magnitude%2A> propiedad es equivalente al valor absoluto de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-332">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="99585-333">Especifica la distancia desde el origen (la intersección del eje x y el eje y en el sistema de coordenadas cartesiano) al punto bidimensional representado por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-333">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="99585-334">El valor absoluto se calcula como sigue:</span><span class="sxs-lookup"><span data-stu-id="99585-334">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="99585-335">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(un \* un + b \* b)</span><span class="sxs-lookup"><span data-stu-id="99585-335">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="99585-336">Si el cálculo del valor absoluto da como resultado un desbordamiento, esta propiedad devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-336">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-337">El <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades definen la posición de un punto que representa un número complejo en el sistema de coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="99585-337">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="99585-338">Puede crear una instancia de un número complejo según sus coordenadas polares, en lugar de sus coordenadas cartesianas mediante una llamada a la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-338">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-339">El ejemplo siguiente se calcula el valor absoluto de un número complejo y demuestra que es equivalente al valor de la <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-339">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-340">Primer número complejo que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="99585-340">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="99585-341">Segundo número complejo que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="99585-341">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="99585-342">Devuelve el producto de dos números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-342">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="99585-343">Producto de los parámetros <paramref name="left" /> y <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="99585-343">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-344">La multiplicación de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-344">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-345">(ac - bd) + (ad + bc)</span><span class="sxs-lookup"><span data-stu-id="99585-345">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="99585-346">Si la multiplicación provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-346">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-347">El <xref:System.Numerics.Complex.Multiply%2A> método se implementa para los idiomas que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="99585-347">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="99585-348">Su comportamiento es idéntico a la multiplicación utilizando el operador de multiplicación.</span><span class="sxs-lookup"><span data-stu-id="99585-348">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-349">El ejemplo siguiente se multiplica un número complejo por cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-349">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-350">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-350">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-351">Devuelve el inverso aditivo de un número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-351">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-352">Resultado de multiplicar por -1 los componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parámetro <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-352">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-353">El inverso aditivo de un número complejo es un número complejo que genera un valor de <xref:System.Numerics.Complex> cuando se agrega al número complejo original.</span><span class="sxs-lookup"><span data-stu-id="99585-353">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="99585-354">Este método devuelve un número complejo en el que los componentes reales e imaginarios del número complejo original se multiplican por -1.</span><span class="sxs-lookup"><span data-stu-id="99585-354">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="99585-355">El <xref:System.Numerics.Complex.Negate%2A> método se implementa para los idiomas que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="99585-355">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="99585-356">Su comportamiento es idéntico a la negación utilizando el operador unario de negación, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="99585-356">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-357">El ejemplo siguiente obtiene el inverso aditivo de cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-357">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-358">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a uno y un número imaginario igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-358">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="99585-359">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.One> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-359">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="99585-360">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a uno y una parte imaginaria igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-360">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="99585-361">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-361">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-362">Primer valor que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="99585-362">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="99585-363">Segundo valor que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="99585-363">The second value to add.</span></span></param>
        <summary><span data-ttu-id="99585-364">Suma dos números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-364">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="99585-365">La suma de <paramref name="left" /> y <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="99585-365">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-366">El <xref:System.Numerics.Complex.op_Addition%2A> método define la operación de suma de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-366">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="99585-367">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-367">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="99585-368">La adición de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-368">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-369">(a + c) + (b + d)</span><span class="sxs-lookup"><span data-stu-id="99585-369">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="99585-370">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-370">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-371">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Add%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-371">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="99585-372">Es el método equivalente para este operador <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-372">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="99585-373">El ejemplo siguiente muestra la suma con números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-373">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-374">Valor que se va a dividir.</span><span class="sxs-lookup"><span data-stu-id="99585-374">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="99585-375">Valor por el que se va a dividir.</span><span class="sxs-lookup"><span data-stu-id="99585-375">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="99585-376">Divide el número complejo especificado por otro.</span><span class="sxs-lookup"><span data-stu-id="99585-376">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-377">Resultado de dividir <paramref name="left" /> entre <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="99585-377">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-378">El <xref:System.Numerics.Complex.op_Division%2A> método define la operación de división de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-378">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="99585-379">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-379">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="99585-380">La división de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-380">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-381">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>)</span><span class="sxs-lookup"><span data-stu-id="99585-381">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="99585-382">Si la división provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-382">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-383">Los lenguajes que no admiten la sobrecarga de operadores y los operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Divide%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-383">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="99585-384">Es el método equivalente para este operador <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-384">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-385">Primer número complejo que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-385">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="99585-386">Segundo número complejo que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-386">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="99585-387">Devuelve un valor que indica si dos números complejos son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-387">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="99585-388">Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="99585-388"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-389">El <xref:System.Numerics.Complex.op_Equality%2A> método define la operación del operador de igualdad para <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="99585-389">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="99585-390">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-390">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="99585-391">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-391">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="99585-392">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-392">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="99585-393">El <xref:System.Numerics.Complex.op_Equality%2A> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="99585-393">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="99585-394">Tenga en cuenta que, debido a diferencias en precisión, dos números complejos que son aparentemente equivalentes pueden considerarse iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-394">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="99585-395">Para obtener más información y una posible solución alternativa, vea el <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método.</span><span class="sxs-lookup"><span data-stu-id="99585-395">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="99585-396">Es el método equivalente para este operador <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-396">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-397">Define una conversión explícita entre un objeto <see cref="T:System.Numerics.Complex" /> y otro tipo.</span><span class="sxs-lookup"><span data-stu-id="99585-397">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-398">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-398">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-399">Define una conversión explícita de un valor <see cref="T:System.Decimal" /> a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-399">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-400">Número complejo con un componente real igual a <paramref name="value" /> y un componente imaginario igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-400">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-401">Operadores de conversión explícitos definen tipos que se pueden convertir en un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-401">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="99585-402">Los compiladores de lenguaje no realizan esta conversión automáticamente porque puede implicar pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="99585-402">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="99585-403">En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza.</span><span class="sxs-lookup"><span data-stu-id="99585-403">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="99585-404">En caso contrario, muestra un error del compilador.</span><span class="sxs-lookup"><span data-stu-id="99585-404">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="99585-405">La conversión de un <xref:System.Decimal> valor a la parte real de un número complejo puede provocar una pérdida de precisión porque un <xref:System.Double>, que es el tipo del número complejo <xref:System.Numerics.Complex.Real%2A> propiedad, tiene menos dígitos significativos que un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="99585-405">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="99585-406">El ejemplo siguiente muestra la conversión explícita de <xref:System.Decimal> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="99585-406">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-407">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-407">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-408">Define una conversión explícita de un valor <see cref="T:System.Numerics.BigInteger" /> a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-408">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-409">Número complejo con un componente real igual a <paramref name="value" /> y un componente imaginario igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-409">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-410">Operadores de conversión explícitos definen tipos que se pueden convertir en un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="99585-410">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="99585-411">Los compiladores de lenguaje no realizan esta conversión automáticamente porque puede implicar pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="99585-411">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="99585-412">En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza.</span><span class="sxs-lookup"><span data-stu-id="99585-412">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="99585-413">En caso contrario, muestra un error del compilador.</span><span class="sxs-lookup"><span data-stu-id="99585-413">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="99585-414">La conversión de un <xref:System.Numerics.BigInteger> valor a la parte real de un número complejo puede provocar una pérdida de precisión porque un <xref:System.Double>, que es el tipo del número complejo <xref:System.Numerics.Complex.Real%2A> propiedad, tiene menos dígitos significativos que un <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="99585-414">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="99585-415">Si la conversión se realiza correctamente porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Double> tipo, la operación no se produce un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-415">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="99585-416">En su lugar, si `value` es menor que <xref:System.Double.MinValue>, el resultado es un número complejo que tiene un <xref:System.Numerics.Complex.Real%2A> igual al valor de la propiedad <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="99585-416">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="99585-417">Si `value` es mayor que <xref:System.Double.MaxValue>, el resultado es un número complejo que tiene un <xref:System.Numerics.Complex.Real%2A> igual al valor de la propiedad <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="99585-417">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="99585-418">El ejemplo siguiente muestra la conversión explícita de <xref:System.Numerics.BigInteger> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="99585-418">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-419">Define una conversión implícita entre un objeto <see cref="T:System.Numerics.Complex" /> y otro tipo.</span><span class="sxs-lookup"><span data-stu-id="99585-419">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-420">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-420">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-421">Define una conversión implícita de un byte sin signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-421">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-422">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-422">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-423">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-423">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-424">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-424">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-425">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Byte> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-425">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-426">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Byte> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-426">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-427">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-427">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-428">Define una conversión implícita de un número de punto flotante de precisión doble en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-428">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-429">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-429">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-430">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-430">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-431">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-431">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-432">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Double> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-432">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-433">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Double> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-433">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-434">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-434">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-435">Define una conversión implícita de un entero de 16 bits con signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-435">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-436">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-436">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-437">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-437">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-438">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-438">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-439">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 16 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-439">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-440">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 16 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-440">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-441">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-441">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-442">Define una conversión implícita de un entero de 32 bits con signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-442">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-443">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-443">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-444">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-444">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-445">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-445">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-446">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 32 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-446">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-447">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 32 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-447">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-448">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-448">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-449">Define una conversión implícita de un entero de 64 bits con signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-449">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-450">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-450">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-451">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-451">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-452">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-452">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-453">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 64 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-453">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-454">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 64 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-454">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-455">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-455">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-456">Define una conversión implícita de un byte con signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-456">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="99585-457">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="99585-457">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="99585-458">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-458">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-459">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-459">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-460">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-460">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-461">Esta sobrecarga permite al compilador administrar las conversiones de un byte con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-461">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-462">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a byte con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-462">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-463">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-463">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-464">Define una conversión implícita de un número de punto flotante de precisión sencilla en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-464">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-465">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-465">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-466">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-466">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-467">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-467">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-468">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Single> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-468">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-469">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Single> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-469">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-470">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-470">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-471">Define una conversión implícita de un entero de 16 bits sin signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-471">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="99585-472">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="99585-472">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="99585-473">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-473">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-474">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-474">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-475">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-475">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-476">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 16 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-476">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-477">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 16 bits sin signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-477">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-478">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-478">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-479">Define una conversión implícita de un entero de 32 bits sin signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-479">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="99585-480">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="99585-480">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="99585-481">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-481">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-482">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-482">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-483">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-483">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-484">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 32 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-484">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-485">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero sin signo de 32 bits y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-485">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-486">Valor que se va a convertir en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-486">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="99585-487">Define una conversión implícita de un entero de 64 bits sin signo en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-487">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="99585-488">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="99585-488">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="99585-489">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span><span class="sxs-lookup"><span data-stu-id="99585-489">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-490">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="99585-490">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="99585-491">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="99585-491">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="99585-492">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 64 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="99585-492">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="99585-493">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 64 bits sin signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-493">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-494">Primer valor que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-494">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="99585-495">Segundo valor que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="99585-495">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="99585-496">Devuelve un valor que indica si dos números complejos no son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-496">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="99585-497"><see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="99585-497"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-498">El <xref:System.Numerics.Complex.op_Equality%2A> método define la operación del operador de desigualdad para los números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-498">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="99585-499">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-499">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="99585-500">Los lenguajes que no admiten operadores personalizados pueden probar la desigualdad mediante una llamada a la <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método e invertir su valor.</span><span class="sxs-lookup"><span data-stu-id="99585-500">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="99585-501">Tenga en cuenta que, debido a diferencias en precisión, dos números complejos que son aparentemente equivalentes pueden considerarse iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-501">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="99585-502">Una posible solución consiste en implementar un método de comparación devuelve `true` solo si la diferencia entre las dos partes reales e imaginarias de los números complejos supera un umbral determinado (como. 01% del valor del componente real o imaginario de uno de los números complejos).</span><span class="sxs-lookup"><span data-stu-id="99585-502">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="99585-503">Para obtener más información, vea el método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="99585-503">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-504">Primer valor que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="99585-504">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="99585-505">Segundo valor que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="99585-505">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="99585-506">Multiplica los dos números complejos especificados.</span><span class="sxs-lookup"><span data-stu-id="99585-506">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="99585-507">Producto de <paramref name="left" /> y <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="99585-507">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-508">El <xref:System.Numerics.Complex.op_Multiply%2A> método define la operación del operador de multiplicación de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-508">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="99585-509">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-509">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="99585-510">La multiplicación de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-510">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-511">(ac - bd) + (ad + bc)</span><span class="sxs-lookup"><span data-stu-id="99585-511">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="99585-512">Si la multiplicación provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-512">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-513">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Multiply%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-513">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="99585-514">Es el método equivalente para este operador <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-514">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-515">Valor del que se va a restar (minuendo).</span><span class="sxs-lookup"><span data-stu-id="99585-515">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="99585-516">Valor que se va a restar (sustraendo).</span><span class="sxs-lookup"><span data-stu-id="99585-516">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="99585-517">Resta un número complejo de otro número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-517">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-518">Resultado de restar <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="99585-518">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-519">El <xref:System.Numerics.Complex.op_Subtraction%2A> método define la operación del operador de sustracción de números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-519">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="99585-520">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-520">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="99585-521">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-521">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-522">El resultado de restar un número complejo, c + di, de otro número complejo, un + bi, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-522">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-523">(a - c) + (b - d.)</span><span class="sxs-lookup"><span data-stu-id="99585-523">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="99585-524">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Subtract%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-524">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="99585-525">Es el método equivalente para este operador <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-525">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-526">Valor que se va a negar.</span><span class="sxs-lookup"><span data-stu-id="99585-526">The value to negate.</span></span></param>
        <summary><span data-ttu-id="99585-527">Devuelve el inverso aditivo de un número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-527">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-528">Resultado de multiplicar por -1 los componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parámetro <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-528">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-529">El <xref:System.Numerics.Complex.op_UnaryNegation%2A> método define el funcionamiento del operador unario de negación (inverso aditivo) para los números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-529">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="99585-530">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-530">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="99585-531">El número complejo resultante genera un valor de <xref:System.Numerics.Complex> 0 (cero) cuando se agrega al número complejo original.</span><span class="sxs-lookup"><span data-stu-id="99585-531">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="99585-532">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Negate%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="99585-532">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="99585-533">Es el método equivalente para este operador <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="99585-533">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-534">Obtiene la fase de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-534">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="99585-535">Fase de un número complejo, en radianes.</span><span class="sxs-lookup"><span data-stu-id="99585-535">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-536">Para un número complejo un + bi, la fase se calcula como <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, una).</span><span class="sxs-lookup"><span data-stu-id="99585-536">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="99585-537">Puede identificar un número complejo por sus coordenadas cartesianas en el plano complejo o por sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="99585-537">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="99585-538">La fase (argumento) de un número complejo es el ángulo en el eje real de una línea trazada desde el punto de origen (la intersección del eje x y el eje y) para el punto representado por el número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-538">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="99585-539">La magnitud (representado por la <xref:System.Numerics.Complex.Magnitude%2A> propiedad) es la distancia desde el punto de origen hasta el punto que representa el número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-539">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="99585-540">Puede crear una instancia de un número complejo según sus coordenadas polares, en lugar de sus coordenadas cartesianas mediante una llamada a la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-540">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="99585-541">Para convertir la fase de radianes en grados, multiplíquelo por 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-541">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-542">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para crear instancias de un número complejo según sus coordenadas polares y, a continuación, muestra el valor de su <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="99585-542">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-543">Devuelve el número complejo especificado elevado a la potencia especificada.</span><span class="sxs-lookup"><span data-stu-id="99585-543">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-544">Número complejo que se va a elevar a una potencia.</span><span class="sxs-lookup"><span data-stu-id="99585-544">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="99585-545">Número de punto flotante de precisión doble que especifica una potencia.</span><span class="sxs-lookup"><span data-stu-id="99585-545">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="99585-546">Devuelve un número complejo especificado elevado a la potencia indicada por un número de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="99585-546">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="99585-547">Número complejo <paramref name="value" /> elevado a la potencia indicada por <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="99585-547">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-548">Si el valor de `value` es <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, el método devuelve <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-548">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-549">Para otros valores, si `power` es 0, el método devuelve <xref:System.Numerics.Complex.One?displayProperty=nameWithType>y si `power` es 1, devuelve `value`.</span><span class="sxs-lookup"><span data-stu-id="99585-549">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="99585-550">Este método corresponde a la <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.</span><span class="sxs-lookup"><span data-stu-id="99585-550">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-551">En el siguiente ejemplo se muestra exponenciación mediante un número complejo y un exponente cuyo valor varía entre -1 y 10.</span><span class="sxs-lookup"><span data-stu-id="99585-551">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-552">Número complejo que se va a elevar a una potencia.</span><span class="sxs-lookup"><span data-stu-id="99585-552">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="99585-553">Número complejo que especifica una potencia.</span><span class="sxs-lookup"><span data-stu-id="99585-553">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="99585-554">Devuelve el número complejo especificado elevado a la potencia indicada por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-554">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-555">Número complejo <paramref name="value" /> elevado a la potencia indicada por <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="99585-555">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-556">Obtiene el componente real del objeto <see cref="T:System.Numerics.Complex" /> actual.</span><span class="sxs-lookup"><span data-stu-id="99585-556">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="99585-557">Componente real de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-557">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-558">Dado un número complejo a + bi, el <xref:System.Numerics.Complex.Real%2A> propiedad devuelve el valor de una.</span><span class="sxs-lookup"><span data-stu-id="99585-558">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-559">El ejemplo siguiente crea una matriz de <xref:System.Numerics.Complex> objetos y se muestran los componentes reales e imaginarios de cada uno en el formulario a + bi.</span><span class="sxs-lookup"><span data-stu-id="99585-559">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-560">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-560">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-561">Devuelve el inverso multiplicativo de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-561">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-562">Recíproco de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-562">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-563">El recíproco, o inverso multiplicativo, de un número *x* es un número *y* donde *x* multiplicado por *y* da como resultado 1.</span><span class="sxs-lookup"><span data-stu-id="99585-563">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="99585-564">El recíproco de un número complejo es el número complejo que genera <xref:System.Numerics.Complex.One?displayProperty=nameWithType> cuando se multiplican los dos números.</span><span class="sxs-lookup"><span data-stu-id="99585-564">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="99585-565">Si se representa un número complejo a + bi, su recíproco representado por la expresión un / (un<sup>2</sup>+ b<sup>2</sup>) + b-/ (un<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="99585-565">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="99585-566">Si el valor es <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, el método devuelve <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-566">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99585-567">En caso contrario, devuelve el resultado de la expresión <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="99585-567">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-568">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.Reciprocal%2A> método para calcular los valores recíprocos de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-568">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="99585-569">También se muestra que es el resultado de multiplicar un número complejo por su recíproco <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-569">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-570">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-570">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-571">Devuelve el seno del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-571">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-572">Seno de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-572">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-573">El <xref:System.Numerics.Complex.Sin%2A> método para los números complejos corresponde a la <xref:System.Math.Sin%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-573">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-574">El <xref:System.Numerics.Complex.Sin%2A> método usa la siguiente fórmula para calcular el seno del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="99585-574">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="99585-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="99585-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-576">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Sin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-576">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="99585-577">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Asin%2A> método a la <xref:System.Numerics.Complex.Sin%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-577">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-578">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-578">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-579">Devuelve el seno hiperbólico del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-579">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-580">Seno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-580">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-581">El <xref:System.Numerics.Complex.Sinh%2A> método para los números complejos corresponde a la <xref:System.Math.Sinh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-581">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-582">El <xref:System.Numerics.Complex.Sinh%2A> método usa la siguiente fórmula para calcular el seno hiperbólico del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="99585-582">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="99585-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="99585-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-584">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-584">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-585">Devuelve la raíz cuadrada del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-585">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-586">Raíz cuadrada de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-586">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-587">La raíz cuadrada del número complejo `value` se calcula mediante la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-587">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="99585-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="99585-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="99585-589">El <xref:System.Numerics.Complex.Sqrt%2A> método para los números complejos corresponde a la <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-589">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="99585-590">Valor del que se va a restar (minuendo).</span><span class="sxs-lookup"><span data-stu-id="99585-590">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="99585-591">Valor que se va a restar (sustraendo).</span><span class="sxs-lookup"><span data-stu-id="99585-591">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="99585-592">Resta un número complejo de otro y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="99585-592">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="99585-593">Resultado de restar <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="99585-593">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-594">El resultado de restar un número complejo, c + di, de otro número complejo, un + bi, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="99585-594">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="99585-595">(a - c) + (b - d.)</span><span class="sxs-lookup"><span data-stu-id="99585-595">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="99585-596">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="99585-596">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="99585-597">Los lenguajes que no admiten operadores personalizados pueden usar el <xref:System.Numerics.Complex.Subtract%2A> método para realizar la resta con números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-597">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-598">El ejemplo siguiente resta cada número complejo en una matriz a partir de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-598">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-599">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-599">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-600">Devuelve la tangente del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-600">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-601">Tangente de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-601">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-602">El <xref:System.Numerics.Complex.Tan%2A> método para los números complejos corresponde a la <xref:System.Math.Tan%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-602">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-603">El <xref:System.Numerics.Complex.Tan%2A> método utiliza la siguiente fórmula para calcular la tangente del número complejo `value`:</span><span class="sxs-lookup"><span data-stu-id="99585-603">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="99585-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="99585-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-605">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Tan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="99585-605">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="99585-606">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Atan%2A> método a la <xref:System.Numerics.Complex.Tan%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="99585-606">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="99585-607">Número complejo.</span><span class="sxs-lookup"><span data-stu-id="99585-607">A complex number.</span></span></param>
        <summary><span data-ttu-id="99585-608">Devuelve la tangente hiperbólica del número complejo especificado.</span><span class="sxs-lookup"><span data-stu-id="99585-608">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="99585-609">Tangente hiperbólica de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="99585-609">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-610">El <xref:System.Numerics.Complex.Tanh%2A> método para los números complejos corresponde a la <xref:System.Math.Tanh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="99585-610">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="99585-611">El <xref:System.Numerics.Complex.Tanh%2A> método utiliza la siguiente fórmula para calcular la tangente hiperbólica del número complejo `value`:</span><span class="sxs-lookup"><span data-stu-id="99585-611">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="99585-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="99585-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="99585-613">Convierte el valor de un número complejo en su representación de cadena equivalente.</span><span class="sxs-lookup"><span data-stu-id="99585-613">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="99585-614">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="99585-614">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="99585-615">Representación de cadena de la instancia actual en formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="99585-615">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-616">La representación de cadena del valor predeterminado de un número complejo muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-616">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="99585-617">Ambos *un* y *b* formateados con el especificador de formato general ("G") y las convenciones de la referencia cultural actual del sistema.</span><span class="sxs-lookup"><span data-stu-id="99585-617">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-618">El ejemplo siguiente muestra la representación de cadena de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-618">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="99585-619">La salida usa las convenciones de formato de inglés - referencia cultural de Estados Unidos ("en-US"), que, en este caso, es la referencia cultural actual del sistema.</span><span class="sxs-lookup"><span data-stu-id="99585-619">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="99585-620">Objeto que proporciona información de formato específica de la referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="99585-620">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="99585-621">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando la información de formato específica de la referencia cultural indicada.</span><span class="sxs-lookup"><span data-stu-id="99585-621">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="99585-622">Representación de cadena de la instancia actual en formato cartesiano, tal como especifica <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="99585-622">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-623">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-623">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="99585-624">Ambos *un* y *b* formateados con el especificador de formato general ("G") y las convenciones de la referencia cultural definida por `provider`.</span><span class="sxs-lookup"><span data-stu-id="99585-624">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="99585-625">El `provider` parámetro es un <xref:System.IFormatProvider> implementación.</span><span class="sxs-lookup"><span data-stu-id="99585-625">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="99585-626">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural sobre el formato de los números reales e imaginarios en la cadena devuelta.</span><span class="sxs-lookup"><span data-stu-id="99585-626">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="99585-627">Si `provider` es `null`, la cadena devuelta se da formato mediante el <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="99585-627">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="99585-628">El `provider` parámetro puede ser uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="99585-628">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="99585-629">Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato</span><span class="sxs-lookup"><span data-stu-id="99585-629">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="99585-630">La <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="99585-630">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="99585-631">Un objeto personalizado que implementa el <xref:System.IFormatProvider> interfaz.</span><span class="sxs-lookup"><span data-stu-id="99585-631">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="99585-632">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="99585-632">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-633">El ejemplo siguiente muestra la representación de cadena de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="99585-633">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="99585-634">El resultado usa las convenciones de formato del inglés - Estados Unidos ("en-US") y francés - referencias culturales de Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="99585-634">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="99585-635">Cadena de formato numérico estándar o personalizada.</span><span class="sxs-lookup"><span data-stu-id="99585-635">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="99585-636">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando el formato especificado para la parte real y la parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="99585-637">Representación de cadena de la instancia actual en formato cartesiano.</span><span class="sxs-lookup"><span data-stu-id="99585-637">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-638">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="99585-639">Ambos *un* y *b* tienen el formato especificada por la cadena de formato `format`.</span><span class="sxs-lookup"><span data-stu-id="99585-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="99585-640">El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido, o cualquier combinación de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="99585-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="99585-641">Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o es `null`, se da formato a las partes reales e imaginarias del número complejo con el especificador de formato general ("G").</span><span class="sxs-lookup"><span data-stu-id="99585-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="99585-642">Si `format` es cualquier otro valor, el método inicia una <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="99585-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="99585-643">.NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="99585-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="99585-644">Para obtener más información acerca de las cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="99585-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="99585-645">Para obtener más información sobre el formato de .NET Framework, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="99585-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="99585-646">El formato de la cadena devuelta viene determinada por la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="99585-646">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="99585-647">En función de la `format` parámetro, este objeto controla símbolos como el signo negativo, el separador de grupos y el símbolo de separador decimal en la cadena de salida.</span><span class="sxs-lookup"><span data-stu-id="99585-647">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="99585-648">Para proporcionar información de formato para las referencias culturales distintas de la referencia cultural actual, llame a la <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="99585-648">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-649">El ejemplo siguiente inicializa un número complejo y lo muestra mediante varias cadenas de formato estándar.</span><span class="sxs-lookup"><span data-stu-id="99585-649">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="99585-650"><paramref name="format" /> no es una cadena de formato válido.</span><span class="sxs-lookup"><span data-stu-id="99585-650"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="99585-651">Cadenas con formato numérico estándar</span><span class="sxs-lookup"><span data-stu-id="99585-651">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="99585-652">Cadenas con formato numérico personalizado</span><span class="sxs-lookup"><span data-stu-id="99585-652">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="99585-653">Cadena de formato numérico estándar o personalizada.</span><span class="sxs-lookup"><span data-stu-id="99585-653">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="99585-654">Objeto que proporciona información de formato específica de la referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="99585-654">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="99585-655">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando el formato especificado y la información de formato específica de la referencia cultural indicada para la parte real y la parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-655">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="99585-656">Representación de cadena de la instancia actual en formato cartesiano, tal como especifican <paramref name="format" /> y <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="99585-656">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-657">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="99585-657">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="99585-658">Ambos *un* y *b* tienen el formato especificada por la cadena de formato `format`.</span><span class="sxs-lookup"><span data-stu-id="99585-658">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="99585-659">El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido, o cualquier combinación de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="99585-659">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="99585-660">Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o es `null`, se da formato a las partes reales e imaginarias del número complejo con el especificador de formato general ("G").</span><span class="sxs-lookup"><span data-stu-id="99585-660">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="99585-661">Si `format` es cualquier otro valor, el método inicia una <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="99585-661">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="99585-662">.NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="99585-662">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="99585-663">Para obtener más información acerca de las cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="99585-663">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="99585-664">Para obtener más información sobre el formato de .NET Framework, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="99585-664">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="99585-665">El `provider` parámetro es un <xref:System.IFormatProvider> implementación.</span><span class="sxs-lookup"><span data-stu-id="99585-665">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="99585-666">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural sobre el formato de los números reales e imaginarios en la cadena devuelta.</span><span class="sxs-lookup"><span data-stu-id="99585-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="99585-667">En función de la `format` parámetro, este objeto controla símbolos como el signo negativo, el separador de grupos y el símbolo de separador decimal en la cadena de salida.</span><span class="sxs-lookup"><span data-stu-id="99585-667">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="99585-668">Si `provider` es `null`, la cadena devuelta se da formato mediante el <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="99585-668">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="99585-669">El `provider` parámetro puede ser uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="99585-669">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="99585-670">Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato</span><span class="sxs-lookup"><span data-stu-id="99585-670">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="99585-671">La <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="99585-671">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="99585-672">Un objeto personalizado que implementa el <xref:System.IFormatProvider> interfaz.</span><span class="sxs-lookup"><span data-stu-id="99585-672">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="99585-673">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="99585-673">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-674">En el ejemplo siguiente se crea una matriz de números complejos y muestra cada una con varias cadenas de formato estándar, así como <xref:System.Globalization.CultureInfo> objetos que representan las referencias culturales de inglés - Estados Unidos ("en-US") y Francés - Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="99585-674">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="99585-675"><paramref name="format" /> no es una cadena de formato válido.</span><span class="sxs-lookup"><span data-stu-id="99585-675"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="99585-676">Cadenas con formato numérico estándar</span><span class="sxs-lookup"><span data-stu-id="99585-676">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="99585-677">Cadenas con formato numérico personalizado</span><span class="sxs-lookup"><span data-stu-id="99585-677">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="99585-678">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a cero y un número imaginario igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-678">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="99585-679">El <xref:System.Numerics.Complex.Zero> propiedad se utiliza con más frecuencia para comparar un <xref:System.Numerics.Complex> valor en cero.</span><span class="sxs-lookup"><span data-stu-id="99585-679">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="99585-680">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.Zero> propiedad.</span><span class="sxs-lookup"><span data-stu-id="99585-680">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="99585-681">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a cero y una parte imaginaria igual a cero.</span><span class="sxs-lookup"><span data-stu-id="99585-681">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="99585-682">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="99585-682">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>