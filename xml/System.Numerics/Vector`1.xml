<Type Name="Vector&lt;T&gt;" FullName="System.Numerics.Vector&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="628942233a31c650334fa221b939e742f0977288" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57917132" /></Metadata><TypeSignature Language="C#" Value="public struct Vector&lt;T&gt; : IEquatable&lt;System.Numerics.Vector&lt;T&gt;&gt;, IFormattable where T : struct" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Vector`1&lt;struct .ctor (class System.ValueType) T&gt; extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Vector`1&lt;!T&gt;&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Vector`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Vector(Of T)&#xA;Implements IEquatable(Of Vector(Of T)), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA; where T : value classpublic value class Vector : IEquatable&lt;System::Numerics::Vector&lt;T&gt;&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Vector&lt;'T (requires 'T : struct)&gt; = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Vectors</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>4.1.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
        <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
        <BaseTypeName>System.ValueType</BaseTypeName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Vector&lt;T&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Tipo de vector. <c>T</c> puede ser cualquier tipo numérico primitivo.</typeparam>
    <summary>Representa un vector único de un tipo numérico especificado que es adecuado para la optimización de bajo nivel de algoritmos paralelos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Numerics.Vector%601> es una estructura inmutable que representa un vector único de un tipo numérico especificado. El recuento de un <xref:System.Numerics.Vector%601> instancia es fijo, pero su límite superior es el registro de la CPU dependientes. Se está diseñado para usarse como un bloque de creación para la vectorización de algoritmos de gran tamaño.  
  
 El <xref:System.Numerics.Vector%601> estructura proporciona compatibilidad para la aceleración de hardware.  
 
 La siguiente tabla muestra qué tipo de datos numéricos primitivos y combinación de la operación utiliza instrucciones intrínsecas para las ejecuciones más rápidas:
 
| Tipo primitivo | `+` | `-` | `*` | `/` |
| --- | :---: | :---: | :---: | :---: |
|`sbyte` | Sí | Sí | No | No |
|`byte` | Sí | Sí | No | No |
|`short` | Sí | Sí | Sí | No |
|`ushort` | Sí | Sí | No | No |
| `int` | Sí | Sí | Sí | No |
| `uint` | Sí | Sí | No | No |
| `long` | Sí | Sí | No | No |
| `ulong` | Sí | Sí | No | No |
| `float` | Sí | Sí | Sí | Sí |
| `double` | Sí | Sí | Sí | Sí |

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (Span&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Span`1&lt;!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(Span&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : Span&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(T value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Tipo numérico que define el tipo de los componentes del vector.</param>
        <summary>Crea un vector cuyos componentes son de un tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` puede ser cualquier tipo numérico primitivo (es decir, un valor numérico tipo cuya <xref:System.Type.IsPrimitive%2A?displayProperty=nameWithType> propiedad devuelve `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(cli::array &lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T[] -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; values" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="values">Matriz numérica.</param>
        <summary>Crea un vector a partir de una matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `values` debe contener al menos <xref:System.Numerics.Vector%601.Count%2A> elementos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Vector (T[] values, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] values, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.#ctor(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (values As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Vector(cli::array &lt;T&gt; ^ values, int index);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; : 'T[] * int -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="new System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; (values, index)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="values">Matriz numérica.</param>
        <param name="index">Posición de índice inicial a partir de la cual se va a crear el vector.</param>
        <summary>Crea un vector a partir de una matriz especificada comenzando en una posición de índice especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz debe contener al menos <xref:System.Numerics.Vector%601.Count%2A?displayProperty=nameWithType> elementos desde el índice especificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
La longitud de <paramref name="values" /> menos <paramref name="index" /> es menor que <see cref="P:System.Numerics.Vector`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="vector.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="destination">Matriz que se va a recibir una copia de los valores del vector.</param>
        <summary>Copia la instancia de vector en una matriz de destino especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la operación de copia en el índice 0 de `destination`. La matriz de destino debe tener al menos <xref:System.Numerics.Vector%601.Count%2A?displayProperty=nameWithType> elementos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos del vector actual es mayor que el número de elementos disponibles en la matriz <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As T(), startIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ destination, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="vector.CopyTo (destination, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Matriz que se va a recibir una copia de los valores del vector.</param>
        <param name="startIndex">Índice inicial de <paramref name="destination" /> donde debe comenzar la operación de copia.</param>
        <summary>Copia la instancia de vector en una matriz de destino especificada a partir de una posición de índice especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comienza la operación de copia en el índice `startIndex` de `destination`. La matriz de destino debe tener al menos `startIndex`  +  <xref:System.Numerics.Vector%601.Count%2A?displayProperty=nameWithType> elementos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de la instancia actual es mayor que el número de elementos disponibles desde <paramref name="startIndex" /> hasta el final de la matriz <paramref name="destination" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que el último indice de <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public static int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el número de elementos almacenado en el vector.</summary>
        <value>Número de elementos almacenado en el vector.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">No se admite el acceso al captador de propiedad mediante reflexión.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Vector&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Vector`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.Equals(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Vector&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="vector.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">Vector con el que se va a comparar esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia es igual que un vector especificado.</summary>
        <returns><see langword="true" /> si la instancia actual y <paramref name="other" /> son iguales; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos vectores son iguales si son del mismo tipo, tienen el mismo número de valores, y cada valor de la instancia actual es igual al valor correspondiente en `other`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="vector.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</summary>
        <returns><see langword="true" /> si la instancia actual y <paramref name="obj" /> son iguales; de lo contrario, <see langword="false" />. El método devuelve <see langword="false" /> si <paramref name="obj" /> es NULL o si <paramref name="obj" /> es un vector de un tipo diferente al de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos vectores son iguales si son del mismo tipo, tienen el mismo número de valores, y cada valor de la instancia actual es igual al valor correspondiente en `other`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="vector.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice del elemento que se va a devolver.</param>
        <summary>Obtiene el elemento situado en un índice especificado.</summary>
        <value>Elemento situado en el índice <paramref name="index" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es mayor o igual que <see cref="P:System.Numerics.Vector`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Vector`1&lt;!T&gt; One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Vector&lt;T&gt; One { System::Numerics::Vector&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve un vector que únicamente contiene unos.</summary>
        <value>Vector que contiene únicamente unos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator + (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Addition(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Addition(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator +(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector que se va a agregar.</param>
        <param name="right">Segundo vector que se va a agregar.</param>
        <summary>Suma dos vectores.</summary>
        <returns>Vector sumado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Addition%2A> método define la operación de suma para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator &amp; (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_BitwiseAnd(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_BitwiseAnd(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator &amp;(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Devuelve un nuevo vector realizando una operación <see langword="And" /> bit a bit en cada uno de los elementos de dos vectores.</summary>
        <returns>Vector resultante de la operación <see langword="And" /> bit a bit de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_BitwiseAnd%2A> método define bit a bit `And` operación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator | (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_BitwiseOr(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_BitwiseOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator |(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Devuelve un nuevo vector realizando una operación <see langword="Or" /> bit a bit en cada uno de los elementos de dos vectores.</summary>
        <returns>Vector resultante de la operación <see langword="Or" /> bit a bit de los elementos de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_BitwiseOr%2A> método define bit a bit `Or` operación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator / (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Division(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Division(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator /(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Divide el primer vector entre el segundo.</summary>
        <returns>Vector resultante de dividir <paramref name="left" /> entre <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Division%2A> método define la operación de división para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Equality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector que se va a comparar.</param>
        <param name="right">Segundo vector que se va a comparar.</param>
        <summary>Devuelve un valor que indica si cada par de elementos de los dos vectores especificados son iguales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos vectores son iguales si son del mismo tipo, tienen el mismo número de valores y cada valor de `left` es igual al valor correspondiente en `right`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator ^ (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_ExclusiveOr(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_ExclusiveOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator ^(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Devuelve un nuevo vector realizando una operación <see langword="XOr" /> bit a bit en cada uno de los elementos de dos vectores.</summary>
        <returns>Vector resultante de la operación <see langword="XOr" /> bit a bit de los elementos de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_ExclusiveOr%2A> método define bit a bit `XOr` operación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;byte&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int8&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Byte}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::Byte&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;byte&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Byte" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;double&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;float64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Double}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;double&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;double&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Double" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;short&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int16&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int16}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;short&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int16&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Int16" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;int&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;int&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Int32" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;long&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;long&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;int64&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Int64" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;sbyte&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;int8&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.SByte}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::SByte&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;sbyte&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.SByte&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.SByte" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;float&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;float32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Single}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;float&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;single&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.Single" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;ushort&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int16&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt16}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt16&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint16&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt16&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.UInt16" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;uint&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int32&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt32&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint32&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.UInt32" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Vector&lt;ulong&gt; (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;unsigned int64&gt; op_Explicit(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Vector(Of T)) As Vector(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Vector&lt;System::UInt64&gt;(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;uint64&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a reinterpretar.</param>
        <summary>Reinterpreta los bits del vector especificado en un vector del tipo <see cref="T:System.UInt64" />.</summary>
        <returns>Vector reinterpretado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Explicit%2A> operador define una conversión de restricción; requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Inequality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Vector(Of T), right As Vector(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; bool" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector que se va a comparar.</param>
        <param name="right">Segundo vector que se va a comparar.</param>
        <summary>Devuelve un valor que indica si cada par de elementos de los vectores especificados es igual.</summary>
        <returns><see langword="true" /> si los pares de elementos de la izquierda y la derecha son iguales. <see langword="false" /> si no hay ningún par de elementos iguales.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Devuelve un nuevo vector cuyos valores son el producto de cada par de elementos de dos vectores especificados.</summary>
        <returns>El vector de producto basado en elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Multiply%2A> método define la operación de multiplicación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (System.Numerics.Vector&lt;T&gt; value, T factor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(valuetype System.Numerics.Vector`1&lt;!T&gt; value, !T factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (value As Vector(Of T), factor As T) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(System::Numerics::Vector&lt;T&gt; value, T factor);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * 'T -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="value * factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="factor" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Vector de origen.</param>
        <param name="factor">Valor escalar.</param>
        <summary>Multiplica un vector por un valor escalar especificado.</summary>
        <returns>Vector escalado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Multiply%2A> método define la operación de multiplicación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator * (T factor, System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Multiply(!T factor, valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Multiply(`0,System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (factor As T, value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator *(T factor, System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member ( * ) : 'T * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="factor * value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="T" />
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="factor">Valor escalar.</param>
        <param name="value">Vector de origen.</param>
        <summary>Multiplica un vector por un valor escalar especificado.</summary>
        <returns>Vector escalado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Multiply%2A> método define la operación de multiplicación para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator ~ (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_OnesComplement(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_OnesComplement(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator ~(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector de origen.</param>
        <summary>Devuelve un nuevo vector cuyos elementos se obtienen tomando el complemento de uno de los elementos de un vector especificado.</summary>
        <returns>Vector complemento de uno.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator - (System.Numerics.Vector&lt;T&gt; left, System.Numerics.Vector&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_Subtraction(valuetype System.Numerics.Vector`1&lt;!T&gt; left, valuetype System.Numerics.Vector`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_Subtraction(System.Numerics.Vector{`0},System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Vector(Of T), right As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator -(System::Numerics::Vector&lt;T&gt; left, System::Numerics::Vector&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; * System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Vector&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Primer vector.</param>
        <param name="right">Segundo vector.</param>
        <summary>Resta el segundo vector del primero.</summary>
        <returns>Vector resultante de restar <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_Subtraction%2A> método define la operación de resta para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; operator - (System.Numerics.Vector&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Vector`1&lt;!T&gt; op_UnaryNegation(valuetype System.Numerics.Vector`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.op_UnaryNegation(System.Numerics.Vector{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Vector(Of T)) As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Vector&lt;T&gt; operator -(System::Numerics::Vector&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt; -&gt; System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Vector&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Vector que se va a convertir en negativo.</param>
        <summary>Convierte en negativo un vector concreto.</summary>
        <returns>Vector convertido en negativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.Vector%601.op_UnaryNegation%2A> método define la operación de negación unaria para <xref:System.Numerics.Vector%601> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="vector.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la representación de cadena de este vector usando el formato predeterminado.</summary>
        <returns>Representación de cadena de este vector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una cadena en la que cada elemento del vector con formato utilizando la cadena de formato (general) de la "G" y las convenciones de formato de la referencia cultural del subproceso actual. La referencia cultural actual <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> seguida por un espacio de propiedad se usa para separar cada elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="vector.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">o  que define el formato de los elementos individuales.</param>
        <summary>Devuelve la representación de cadena de este vector usando la cadena de formato especificada para dar formato a los elementos individuales.</summary>
        <returns>Representación de cadena de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una cadena en la que cada elemento del vector con formato utilizando `format` y las convenciones de formato de la referencia cultural actual. La referencia cultural actual <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> seguida por un espacio de propiedad se usa para separar cada elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Vector`1.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, formatProvider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="vector.ToString (format, formatProvider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">o  que define el formato de los elementos individuales.</param>
        <param name="formatProvider">Proveedor de formato que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Devuelve la representación de cadena de este vector usando la cadena de formato especificada para dar formato a los elementos individuales y el proveedor de formato especificado para definir el formato específico de la referencia cultural.</summary>
        <returns>Representación de cadena de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una cadena en la que cada elemento del vector con formato mediante `format` y `formatProvider`y el proveedor de formato <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A?displayProperty=nameWithType> seguida por un espacio de propiedad se usa para separar cada elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.Vector&lt;T&gt; Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Vector`1&lt;!T&gt; Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Vector`1.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As Vector(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Vector&lt;T&gt; Zero { System::Numerics::Vector&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;" Usage="System.Numerics.Vector&lt;'T (requires 'T : struct)&gt;.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Vectors</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>4.1.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Vector&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve un vector que únicamente contiene ceros.</summary>
        <value>Vector que contiene únicamente  ceros.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>